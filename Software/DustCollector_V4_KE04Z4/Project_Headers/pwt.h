/**
 * @file      pwt.h (180.ARM_Peripherals/Project_Headers/pwt-MKE.h)
 * @brief    Abstraction layer for PWT interface
 */

#ifndef PROJECT_HEADERS_PWT_H_
#define PROJECT_HEADERS_PWT_H_

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "pin_mapping.h"

// No handler defined for PWT


namespace USBDM {

/**
 * Peripheral information for PWT, PWT, Pulse Width Timer.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Positive Pulse Width
    * (pwt_r1_ppw)
    *
    * Captured positive pulse width value. It is suggested to use half-word (16-bit) or word (32-bit) to read out 
    * this value
    */
   enum PositivePulseWidth : uint16_t {
   };

   /**
    * PWT Module Enable
    * (pwt_r1_pwten)
    *
    * Enables/disables the PWT module.
    * To avoid unexpected behaviour, do not change any PWT configurations while PWTEN is set
    */
   enum PwtEnable : uint16_t {
      PwtEnable_Disabled   = PWT_R1_PWTEN(0),  ///< Disabled
      PwtEnable_Enabled    = PWT_R1_PWTEN(1),  ///< Enabled
   };

   /**
    * PWT Clock Source Selection
    * (pwt_r1_pclks)
    *
    * Controls the selection of clock source for the PWT counter
    */
   enum PwtClockSource : uint16_t {
      PwtClockSource_TimerClock         = PWT_R1_PCLKS(0),  ///< Timer clock
      PwtClockSource_AlternativeClock   = PWT_R1_PCLKS(1),  ///< Alternative clock(TCLK)
   };

   /**
    * PWT Pulse Input Selection
    * (pwt_r1_pinsel)
    *
    * Enables the corresponding PWT input port, if this PWT input comes from an external source
    */
   enum PwtInput : uint16_t {
      PwtInput_PTC4      = PWT_R1_PINSEL(0),  ///< PTC4
      PwtInput_PTB0      = PWT_R1_PINSEL(1),  ///< PTB0
      PwtInput_ACMP0_O   = PWT_R1_PINSEL(2),  ///< ACMP0_O
      PwtInput_ACMP1_O   = PWT_R1_PINSEL(3),  ///< ACMP1_O
   };

   /**
    * PWT Input Edge Sensitivity
    * (pwt_r1_edge)
    *
    * Selects which edge triggers the pulse width measurement and which edges trigger the capture.
    * If user needs to change the trigger and capture mode by changing the value of EDGE[1:0], 
    * a PWT software reset is required after changing the EDGE[1:0] value.
    * Clearing PWTEN and then setting it has the same effect
    */
   enum PwtEdges : uint16_t {
      PwtEdges_FallingStart_FallingCaptured   = PWT_R1_EDGE(0b00),  ///< Falling-edge start, falling edges captured
      PwtEdges_RisingStart_BothCaptured       = PWT_R1_EDGE(0b01),  ///< Rising edge start, both edges captured
      PwtEdges_FallingStart_BothCaptured      = PWT_R1_EDGE(0b10),  ///< Falling edge start, both edges captured
      PwtEdges_RisingStart_RisingCaptured     = PWT_R1_EDGE(0b11),  ///< Rising edge start, rising edges captured
   };

   /**
    * PWT Clock Prescaler (CLKPRE) Setting
    * (pwt_r1_pre)
    *
    * Selects the value by which the clock is divided to clock the PWT counter
    */
   enum PwtClockDivider : uint16_t {
      PwtClockDivider_ClockDiv1     = PWT_R1_PRE(0),  ///< Clock div 1
      PwtClockDivider_ClockDiv2     = PWT_R1_PRE(1),  ///< Clock div 2
      PwtClockDivider_ClockDiv4     = PWT_R1_PRE(2),  ///< Clock div 4
      PwtClockDivider_ClockDiv8     = PWT_R1_PRE(3),  ///< Clock div 8
      PwtClockDivider_ClockDiv16    = PWT_R1_PRE(4),  ///< Clock div 16
      PwtClockDivider_ClockDiv32    = PWT_R1_PRE(5),  ///< Clock div 32
      PwtClockDivider_ClockDiv64    = PWT_R1_PRE(6),  ///< Clock div 64
      PwtClockDivider_ClockDiv128   = PWT_R1_PRE(7),  ///< Clock div 128
   };

   /**
    * PWT Module Interrupt Enable
    * (pwt_r1_pwtie)
    *
    * Enables the PWT module to generate an interrupt
    */
   enum PwtInterrupt : uint16_t {
      PwtInterrupt_Disable   = PWT_R1_PWTIE(0),  ///< Disable
      PwtInterrupt_Enable    = PWT_R1_PWTIE(1),  ///< Enable
   };

   /**
    * PWT Pulse Width Data Ready Interrupt Enable
    * (pwt_r1_prdyie)
    *
    * Enables/disables the PWT to generate an interrupt when PWTRDY is set as long as PWTIE is set
    */
   enum PwtReadyInterrupt : uint16_t {
      PwtReadyInterrupt_Disable   = PWT_R1_PRDYIE(0),  ///< Disable
      PwtReadyInterrupt_Enable    = PWT_R1_PRDYIE(1),  ///< Enable
   };

   /**
    * PWT Counter Overflow Interrupt Enable
    * (pwt_r1_povie)
    *
    * Enables/disables the PWT to generate an interrupt when PWTOV is set due to PWT counter overflow
    */
   enum PwtOverflowInterrupt : uint16_t {
      PwtOverflowInterrupt_Disable   = PWT_R1_POVIE(0),  ///< Disable
      PwtOverflowInterrupt_Enable    = PWT_R1_POVIE(1),  ///< Enable
   };

   /**
    * PWT Soft Reset
    * (pwt_r1_pwtsr)
    *
    * Performs a soft reset to the PWT. This field always reads as 0
    */
   enum PwtSoftReset : uint16_t {
      PwtSoftReset_NoAction    = PWT_R1_PWTSR(0),  ///< No action
      PwtSoftReset_SoftReset   = PWT_R1_PWTSR(1),  ///< Soft reset
   };

   /**
    * PWT Pulse Width Valid
    * (pwt_r1_pwtrdy)
    *
    * Indicates that the PWT Pulse Width register(s) has been updated and is ready to be read.
    * This field is cleared by reading PWTRDY and then writing 0 to PWTRDY bit when PWTRDY is set.
    * Writing 1 to this field has no effect. PWTRDY setting is associated with the EDGE[1:0] bits
    */
   enum PwtReady : uint16_t {
      PwtReady_NotUpdated   = PWT_R1_PWTRDY(0),  ///< Not Updated
      PwtReady_Updated      = PWT_R1_PWTRDY(1),  ///< Updated
   };

   /**
    * PWT Counter Overflow
    * (pwt_r1_pwtov)
    *
    * Indicates that the PWT counter has run from 0x0000_0xFFFF to 0x0000_0x0000.
    * This field is cleared by writing 0 to PWTOV when PWTOV is set.
    * Writing 1 to this field has no effect.
    * If another overflow occurs when this field is being cleared, the clearing fails
    */
   enum PwtOverflow : uint16_t {
      PwtOverflow_NoOverflow   = PWT_R1_PWTOV(0),  ///< No overflow
      PwtOverflow_Overflow     = PWT_R1_PWTOV(1),  ///< Overflow
   };

class PwtBasicInfo {

public:
}; // class PwtBasicInfo 

class PwtInfo : public PwtBasicInfo {

public:
   /*
    * Template:pwt_mke
    */
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = PWT_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(irqNums[0]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[0], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(irqNums[0]);
   }
   
   /**
    *  Enable clock to Pwt
    */
   static void enableClock() {
      SIM->SCGC = SIM->SCGC | SIM_SCGC_PWT_MASK;
   }
   
   /**
    *  Disable clock to Pwt
    */
   static void disableClock() {
      SIM->SCGC = SIM->SCGC & ~SIM_SCGC_PWT_MASK;
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = PWT_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<PWT_Type> pwt = baseAddress;
   
}; // class PwtInfo


template <class Info>
class PwtBase_T : public PwtInfo {

protected:
   /** Hardware instance */
   static constexpr HardwarePtr<PWT_Type> pwt = baseAddress;

// No /PWT/protectedMethods found
public:
// No /PWT/publicMethods found
// No /PWT/InitMethod found
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnablePWT(Info::irqNums[0]);
   }

   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(Info::irqNums[0], nvicPriority);
   }

   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisablePWT(Info::irqNums[0]);
   }

};




}; // namespace USBDM

#endif /* PROJECT_HEADERS_PWT_H_ */
