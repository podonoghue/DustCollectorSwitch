/**
 * @file     adc.h (180.ARM_Peripherals/Project_Headers/adc-MKE.h)
 * @brief    ADC routines
 */

#ifndef HEADER_ADC_H
#define HEADER_ADC_H

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <climits>
#include <cstddef>
#include "pin_mapping.h"
#include "gpio.h"

#if true // /ADC/_BasicInfoGuard

namespace USBDM {
// Forward declaration
enum AdcChannelNum : uint8_t;
}

// No handler defined for ADC0

namespace USBDM {

/**
 * @addtogroup ADC_Group ADC, Analogue Input
 * @brief Abstraction for Analogue Input
 * @{
 */
/**
 * Peripheral information for ADC, Analogue Input.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * ADC Channel number
    * (adc_sc1_channel)
    *
    * Selects an ADC channel
    */
   enum AdcChannelNum : uint8_t {
      AdcChannelNum_Se0        = ADC_SC1_ADCH(0),   ///< Channel SE0
      AdcChannelNum_Se1        = ADC_SC1_ADCH(1),   ///< Channel SE1
      AdcChannelNum_Se2        = ADC_SC1_ADCH(2),   ///< Channel SE2
      AdcChannelNum_Se3        = ADC_SC1_ADCH(3),   ///< Channel SE3
      AdcChannelNum_Se4        = ADC_SC1_ADCH(4),   ///< Channel SE4
      AdcChannelNum_Se5        = ADC_SC1_ADCH(5),   ///< Channel SE5
      AdcChannelNum_Se6        = ADC_SC1_ADCH(6),   ///< Channel SE6
      AdcChannelNum_Se7        = ADC_SC1_ADCH(7),   ///< Channel SE7
      AdcChannelNum_Se8        = ADC_SC1_ADCH(8),   ///< Channel SE8
      AdcChannelNum_Se9        = ADC_SC1_ADCH(9),   ///< Channel SE9
      AdcChannelNum_Se10       = ADC_SC1_ADCH(10),  ///< Channel SE10
      AdcChannelNum_Se11       = ADC_SC1_ADCH(11),  ///< Channel SE11
      AdcChannelNum_Se12       = ADC_SC1_ADCH(12),  ///< Channel SE12
      AdcChannelNum_Se13       = ADC_SC1_ADCH(13),  ///< Channel SE13
      AdcChannelNum_Se14       = ADC_SC1_ADCH(14),  ///< Channel SE14
      AdcChannelNum_Se15       = ADC_SC1_ADCH(15),  ///< Channel SE15
      AdcChannelNum_Se16       = ADC_SC1_ADCH(16),  ///< Channel SE16
      AdcChannelNum_Se17       = ADC_SC1_ADCH(17),  ///< Channel SE17
      AdcChannelNum_Se18       = ADC_SC1_ADCH(18),  ///< Channel SE18
      AdcChannelNum_Se19       = ADC_SC1_ADCH(19),  ///< Channel SE19
      AdcChannelNum_Se20       = ADC_SC1_ADCH(20),  ///< Channel SE20
      AdcChannelNum_Se21       = ADC_SC1_ADCH(21),  ///< Channel SE21
      AdcChannelNum_Se22       = ADC_SC1_ADCH(22),  ///< Channel SE22
      AdcChannelNum_Se23       = ADC_SC1_ADCH(23),  ///< Channel SE23
      AdcChannelNum_Se24       = ADC_SC1_ADCH(24),  ///< Channel SE24
      AdcChannelNum_Se25       = ADC_SC1_ADCH(25),  ///< Channel SE25
      AdcChannelNum_Se26       = ADC_SC1_ADCH(26),  ///< Channel SE26
      AdcChannelNum_Se27       = ADC_SC1_ADCH(27),  ///< Channel SE27
      AdcChannelNum_Se28       = ADC_SC1_ADCH(28),  ///< Channel SE28
      AdcChannelNum_Se29       = ADC_SC1_ADCH(29),  ///< Channel SE29
      AdcChannelNum_Se30       = ADC_SC1_ADCH(30),  ///< Channel SE30
      AdcChannelNum_Disabled   = ADC_SC1_ADCH(31),  ///< Disabled
   };

   /**
    * ADC Channel number
    * (adc0_sc1_channel)
    *
    * Selects an ADC channel
    */
   static constexpr AdcChannelNum Adc0ChannelNum_Se0            = AdcChannelNum_Se0;   ///< ADC0_SE0 [-]
   static constexpr AdcChannelNum Adc0ChannelNum_Se1            = AdcChannelNum_Se1;   ///< Reference level for ISample OPAMPs [PTA1(15)]
   static constexpr AdcChannelNum Adc0ChannelNum_Reference      = AdcChannelNum_Se1;   ///< Reference level for ISample OPAMPs
   static constexpr AdcChannelNum Adc0ChannelNum_PTA1           = AdcChannelNum_Se1;   ///< Pin PTA1
   static constexpr AdcChannelNum Adc0ChannelNum_Se2            = AdcChannelNum_Se2;   ///< ADC0_SE2 [-]
   static constexpr AdcChannelNum Adc0ChannelNum_Se3            = AdcChannelNum_Se3;   ///< ADC0_SE3 [-]
   static constexpr AdcChannelNum Adc0ChannelNum_Se4            = AdcChannelNum_Se4;   ///< Current Sample [PTB0(12)]
   static constexpr AdcChannelNum Adc0ChannelNum_I_Sample       = AdcChannelNum_Se4;   ///< Current Sample
   static constexpr AdcChannelNum Adc0ChannelNum_PTB0           = AdcChannelNum_Se4;   ///< Pin PTB0
   static constexpr AdcChannelNum Adc0ChannelNum_Se5            = AdcChannelNum_Se5;   ///< Delay Control [PTB1(11)]
   static constexpr AdcChannelNum Adc0ChannelNum_DelayControl   = AdcChannelNum_Se5;   ///< Delay Control
   static constexpr AdcChannelNum Adc0ChannelNum_PTB1           = AdcChannelNum_Se5;   ///< Pin PTB1
   static constexpr AdcChannelNum Adc0ChannelNum_Se6            = AdcChannelNum_Se6;   ///< Hold time control [PTB2(10)]
   static constexpr AdcChannelNum Adc0ChannelNum_HoldControl    = AdcChannelNum_Se6;   ///< Hold time control
   static constexpr AdcChannelNum Adc0ChannelNum_PTB2           = AdcChannelNum_Se6;   ///< Pin PTB2
   static constexpr AdcChannelNum Adc0ChannelNum_Se7            = AdcChannelNum_Se7;   ///< Current threshold control [PTB3(9)]
   static constexpr AdcChannelNum Adc0ChannelNum_LevelControl   = AdcChannelNum_Se7;   ///< Current threshold control
   static constexpr AdcChannelNum Adc0ChannelNum_PTB3           = AdcChannelNum_Se7;   ///< Pin PTB3
   static constexpr AdcChannelNum Adc0ChannelNum_Se8            = AdcChannelNum_Se8;   ///< ADC0_SE8 [-]
   static constexpr AdcChannelNum Adc0ChannelNum_Se9            = AdcChannelNum_Se9;   ///< HoldControl [-]
   static constexpr AdcChannelNum Adc0ChannelNum_Se10           = AdcChannelNum_Se10;  ///< LevelControl [-]
   static constexpr AdcChannelNum Adc0ChannelNum_Se11           = AdcChannelNum_Se11;  ///< DelayControl [-]
   static constexpr AdcChannelNum Adc0ChannelNum_Se22           = AdcChannelNum_Se22;  ///< ADC0_SE22 [TEMP_SENSOR(Internal)]
   static constexpr AdcChannelNum Adc0ChannelNum_TEMP_SENSOR    = AdcChannelNum_Se22;  ///< Pin TEMP_SENSOR
   static constexpr AdcChannelNum Adc0ChannelNum_Se23           = AdcChannelNum_Se23;  ///< ADC0_SE23 [BANDGAP(Internal)]
   static constexpr AdcChannelNum Adc0ChannelNum_BANDGAP        = AdcChannelNum_Se23;  ///< Pin BANDGAP


   /**
    * Action on conversion completion
    * (adc_sc1_aien)
    *
    * Controls whether an interrupt is triggered at the end of each conversion
    */
   enum AdcAction : uint8_t {
      AdcAction_None        = ADC_SC1_AIEN(0),  ///< None
      AdcAction_Interrupt   = ADC_SC1_AIEN(1),  ///< Interrupt
   };

   /**
    * Conversion Complete Flag
    * (adc_sc1_coco)
    *
    * 
    */
   enum AdcCompleteFlag : uint8_t {
      AdcCompleteFlag_NotComplete   = ADC_SC1_COCO(0),  ///< Not complete
      AdcCompleteFlag_Complete      = ADC_SC1_COCO(1),  ///< Complete
   };

   /**
    * ADC Input Clock
    * (adc_sc3_adiclk)
    *
    * Clock source for the ADC module
    */
   enum AdcClockSource : uint8_t {
      AdcClockSource_BusClock       = ADC_SC3_ADICLK(0),  ///< Bus clock
      AdcClockSource_BusClockDiv2   = ADC_SC3_ADICLK(1),  ///< Bus clock/2
      AdcClockSource_OscerClk       = ADC_SC3_ADICLK(2),  ///< Alternate clock (OSCERCLK)
      AdcClockSource_Asynch         = ADC_SC3_ADICLK(3),  ///< Asynchronous clock (ADACK)
   };

   /**
    * Clock Divide Select
    * (adc_sc3_adiv)
    *
    * Sets the division of the available clock for use by the ADC
    */
   enum AdcClockDivider : uint8_t {
      AdcClockDivider_DivBy1   = ADC_SC3_ADIV(0),  ///< Divide by 1
      AdcClockDivider_DivBy2   = ADC_SC3_ADIV(1),  ///< Divide by 2
      AdcClockDivider_DivBy4   = ADC_SC3_ADIV(2),  ///< Divide by 4
      AdcClockDivider_DivBy8   = ADC_SC3_ADIV(3),  ///< Divide by 8
   };

   /**
    * ADC resolution
    * (adc_sc3_mode)
    *
    * Resolution used for conversion
    */
   enum AdcResolution : uint8_t {
      AdcResolution_8bit_se    = ADC_SC3_MODE(0),  ///< 8-bit unsigned (single-ended mode)
      AdcResolution_10bit_se   = ADC_SC3_MODE(1),  ///< 10-bit unsigned (single-ended mode)
      AdcResolution_12bit_se   = ADC_SC3_MODE(2),  ///< 12-bit unsigned (single-ended mode)
   };

   /**
    * Low-Power Configuration
    * (adc_sc3_adlpc)
    *
    * Controls trade-off between speed and power consumption
    * It also affects the speed of the asynchronous clock
    */
   enum AdcPower : uint8_t {
      AdcPower_Normal   = ADC_SC3_ADLPC(0),  ///< Normal power configuration
      AdcPower_Low      = ADC_SC3_ADLPC(1),  ///< Low-power configuration (reduced speed)
   };

   /**
    * Sample Time Configuration
    * (adc_sc3_adlsmp)
    *
    * Selects between long and short sample times.
    * Longer sample times allow higher impedance inputs to be accurately sampled or
    * shorter sample times maximizes the conversion speed for lower impedance inputs.
    * Longer sample times can also be used to lower overall power consumption when
    * continuous conversions are enabled.
    */
   enum AdcSampleMode : uint8_t {
      AdcSampleMode_ShortSampleTime   = ADC_SC3_ADLSMP(0),  ///< Short sample time
      AdcSampleMode_LongSampleTime    = ADC_SC3_ADLSMP(1),  ///< Long sample time
   };

   /**
    * Voltage Reference Selection
    * (adc_sc2_refsel)
    *
    * Selects the voltage reference source used for conversions
    */
   enum AdcReferenceSel : uint8_t {
      AdcReferenceSel_VrefhAndVrefl   = ADC_SC2_REFSEL(0),  ///< VRefH and VRefl
      AdcReferenceSel_ValthAndValtl   = ADC_SC2_REFSEL(0),  ///< VAltH and VAltl
      AdcReferenceSel_Default         = ADC_SC2_REFSEL(0),  ///< Default
   };

   /**
    * Single or continuous conversion
    * (adc_sc1_adco)
    *
    * Selects between single and multiple conversions.
    * Conversions are triggered by a write to the ADC_SC1 when software triggered operation is selected,
    * or following assertion of ADHWT when hardware triggered operation is selected.
    * When the FIFO function is enabled (AFDEP != 0), looped sets of conversions are triggered.
    */
   enum AdcOperation : uint8_t {
      AdcOperation_Single       = ADC_SC1_ADCO(0),  ///< Single
      AdcOperation_Continuous   = ADC_SC1_ADCO(1),  ///< Continuous
   };

   /**
    * FIFO Depth
    * (adc_sc4_afdep)
    *
    * Emables the FIFO and selects FIFO depth
    */
   enum AdcFifoDepth : uint16_t {
      AdcFifoDepth_FifoDisabled   = ADC_SC4_AFDEP(0),  ///< FIFO disabled
      AdcFifoDepth_2LevelFifo     = ADC_SC4_AFDEP(1),  ///< 2-level FIFO
      AdcFifoDepth_3LevelFifo     = ADC_SC4_AFDEP(2),  ///< 3-level FIFO
      AdcFifoDepth_4LevelFifo     = ADC_SC4_AFDEP(3),  ///< 4-level FIFO
      AdcFifoDepth_5LevelFifo     = ADC_SC4_AFDEP(4),  ///< 5-level FIFO
      AdcFifoDepth_6LevelFifo     = ADC_SC4_AFDEP(5),  ///< 6-level FIFO
      AdcFifoDepth_7LevelFifo     = ADC_SC4_AFDEP(6),  ///< 7-level FIFO
      AdcFifoDepth_8LevelFifo     = ADC_SC4_AFDEP(7),  ///< 8-level FIFO
   };

   /**
    * FIFO Scan Mode Enable
    * (adc_sc4_ascane)
    *
    * When enabled, the FIFO always use the first channel written to SC1. 
    * The ADC will repeat conversions using this channel until the result
    * FIFO is fulfilled.
    * In continuous mode (SC1.ADCO = 1), the ADC will start the next
    * conversion with the same channel after SC1.COCO is set.
    */
   enum AdcFifoScanMode : uint16_t {
      AdcFifoScanMode_Disabled   = ADC_SC4_ASCANE(0),  ///< Disabled
      AdcFifoScanMode_Enabled    = ADC_SC4_ASCANE(1),  ///< Enabled
   };

   /**
    * Result FIFO empty
    * (adc_sc2_fempty)
    *
    * Indicates if the FIFO is empty
    */
   enum AdcFifoEmpty : uint8_t {
      AdcFifoEmpty_FifoHasData   = ADC_SC2_FEMPTY(0),  ///< FIFO has data
      AdcFifoEmpty_FifoEmpty     = ADC_SC2_FEMPTY(1),  ///< FIFO empty
   };

   /**
    * Result FIFO full
    * (adc_sc2_ffull)
    *
    * Indicates if the FIFO is full
    */
   enum AdcFifofull : uint8_t {
      AdcFifofull_FifoNotFull   = ADC_SC2_FFULL(0),  ///< FIFO not full
      AdcFifofull_FifoFull      = ADC_SC2_FFULL(1),  ///< FIFO full
   };

   /**
    * Compare Function Control
    * (adc_sc2_compare)
    *
    * Configures when the ADC compare function will generate events
    */
   enum AdcCompare : uint8_t {
      AdcCompare_Disabled             = ADC_SC2_ACFE(0)|ADC_SC2_ACFGT(0),  ///< No comparison done
      AdcCompare_LessThan             = ADC_SC2_ACFE(1)|ADC_SC2_ACFGT(0),  ///< ADC value < compare value
      AdcCompare_GreaterThanOrEqual   = ADC_SC2_ACFE(1)|ADC_SC2_ACFGT(1),  ///< ADC value >= compare value
   };

   /**
    * Compare function OR/AND selection.
    * (adc_sc4_acfsel)
    *
    * This controls how the compare events from the FIFO values are combined.
    * If cleared, ADC will OR all of the compare events and set COCO if at least one events occurs. 
    * If set, ADC will AND all of compare events and set COCO only when all events have occurred
    */
   enum AdcCompareCombine : uint16_t {
      AdcCompareCombine_AsOredEvents    = ADC_SC4_ACFSEL(0),  ///< ORed events
      AdcCompareCombine_AsAndedEvents   = ADC_SC4_ACFSEL(1),  ///< ANDed events
   };

   /**
    * Conversion Trigger Select
    * (adc_sc2_adtrg)
    *
    * Controls whether conversions are triggered by writes to ADC_SC1 (software)
    * or assertion of ADHWT input (hardware)
    */
   enum AdcTrigger : uint8_t {
      AdcTrigger_Software   = ADC_SC2_ADTRG(0),  ///< Software trigger (write to SC1[0])
      AdcTrigger_Hardware   = ADC_SC2_ADTRG(1),  ///< Hardware trigger (ADHWT source)
   };

   /**
    * Hardware Trigger Mask
    * (adc_sc5_htrigger)
    *
    * Control hardware trigger
    */
   enum AdcHardwareTriggerMask : uint8_t {
      AdcHardwareTriggerMask_Unmasked               = ADC_SC5_HTRIGGER(0b00),  ///< Masking disabled
      AdcHardwareTriggerMask_Masked                 = ADC_SC5_HTRIGGER(0b10),  ///< Masked
      AdcHardwareTriggerMask_MaskedIfFifoNotEmpty   = ADC_SC5_HTRIGGER(0b01),  ///< Masked when FIFO is not empty
   };

   /**
    * Hardware Trigger Multiple Conversion Enable
    * (adc_sc4_htrgme)
    *
    * Selects whether a hardware trigger event initiates a single conversion
    * or multiple conversions until the FIFO is full
    */
   enum AdcHardwareAction : uint16_t {
      AdcHardwareAction_SingleConversion      = ADC_SC4_HTRGME(0),  ///< Single conversion
      AdcHardwareAction_MultipleConversions   = ADC_SC4_HTRGME(1),  ///< Multiple conversions filling FIFO
   };

   /**
    * Conversion Status
    * (adc_sc2_adact)
    *
    * Indicates that a conversion or sequence of conversions is in progress.
    * Set when a conversion is initiated and cleared when a conversion is completed or aborted
    */
   enum AdcStatus : uint8_t {
      AdcStatus_Idle   = ADC_SC2_ADACT(0),  ///< Conversion not in progress.
      AdcStatus_Busy   = ADC_SC2_ADACT(1),  ///< Conversion in progress.
   };

   /**
    * GPIO Pin Disable
    * (adc_apctl1_adpc)
    *
    * Bit mask disabling the GPIO function on the pin corresponding to a ADC channel.
    * This is only necessary for Channels 0-15.
    * The GPIO corresponding to the Input Channel Selected will also be disabled.
    * 0:pin is GPIO, 1:pin is Analogue
    */
   enum AdcChannelMask : uint16_t {
      AdcChannelMask_PTA0   = ADC_APCTL1_ADPC(1U<<0),   ///< Channel 0
      AdcChannelMask_PTA1   = ADC_APCTL1_ADPC(1U<<1),   ///< Channel 1
      AdcChannelMask_PTA6   = ADC_APCTL1_ADPC(1U<<2),   ///< Channel 2
      AdcChannelMask_PTA7   = ADC_APCTL1_ADPC(1U<<3),   ///< Channel 3
      AdcChannelMask_PTB0   = ADC_APCTL1_ADPC(1U<<4),   ///< Channel 4
      AdcChannelMask_PTB1   = ADC_APCTL1_ADPC(1U<<5),   ///< Channel 5
      AdcChannelMask_PTB2   = ADC_APCTL1_ADPC(1U<<6),   ///< Channel 6
      AdcChannelMask_PTB3   = ADC_APCTL1_ADPC(1U<<7),   ///< Channel 7
      AdcChannelMask_PTC0   = ADC_APCTL1_ADPC(1U<<8),   ///< Channel 8
      AdcChannelMask_PTC1   = ADC_APCTL1_ADPC(1U<<9),   ///< Channel 9
      AdcChannelMask_PTC2   = ADC_APCTL1_ADPC(1U<<10),  ///< Channel 10
      AdcChannelMask_PTC3   = ADC_APCTL1_ADPC(1U<<11),  ///< Channel 11
   };


   /**
    * Combines two AdcChannelMask values (by ORing)
    * Used to create new AdcChannelMask mask
    * 
    * @param left    Left operand
    * @param right   Right operand
    * 
    * @return  Combined value
    */
   constexpr AdcChannelMask operator|(AdcChannelMask left, AdcChannelMask right) {
      return AdcChannelMask(long(left)|long(right));
   }
   
   /**
    * Combines two AdcChannelMask values (by ANDing) to produce a bool result
    * Used to check a value against a AdcChannelMask mask
    * 
    * @param left    Left operand
    * @param right   Right operand
    * 
    * @return boolean value indicating if the result is non-zero
    */
   constexpr bool operator&(AdcChannelMask left, AdcChannelMask right) {
      return bool(long(left)&long(right));
   }
   
class AdcBasicInfo {

public:
   //! Common class based callback code has been generated for this class of peripheral
   // (_BasicInfoIrqGuard)
   static constexpr bool irqHandlerInstalled = false;
   
   // Pointer to ADC hardware instance
   volatile ADC_Type * const adc;
   
   /**
    * Constructor
    *
    * @param adc ADC hardware instance
    */
   constexpr AdcBasicInfo(volatile ADC_Type * adc) : adc(adc) {
   }
   
   /**
    * Get ADC Input Clock
    *
    * @param adcClockSource Clock source for the ADC module
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getInputClockFrequency(AdcClockSource adcClockSource) {
   
      switch(adcClockSource) {
         default: return 0;
         case AdcClockSource_BusClock     : return SystemBusClock;          ///< Bus clock
         case AdcClockSource_BusClockDiv2 : return SystemBusClock/2;        ///< Bus clock/2
         case AdcClockSource_OscerClk     : return Osc0Info::getOscClock(); ///< Alternate clock (OSCERCLK)
         case AdcClockSource_Asynch       : return 3300000;     ///< Asynchronous clock (ADACK)

      }
   }
   
   /**
    * Calculate ADC clock divider (ADC_SC3_ADIV) and confirm clock source (ADC_SC3_ADICLK)
    *
    * @param sc3 ADC SC3  register value
    *
    * @return modified sc3 value (ADC_SC3_ADIV|ADC_SC3_ADICLK fields may be changed)
    */
   static unsigned calculateClockDivider(uint8_t sc3) {
   
      AdcClockSource adcClockSource = AdcClockSource(ADC_SC3_ADICLK_MASK&sc3);
      AdcPower       adcPower       = AdcPower(ADC_SC3_ADLPC_MASK&sc3);
   
      // Clear existing fields
      sc3 &= ~(ADC_SC3_ADICLK_MASK|ADC_SC3_ADIV_MASK);
   
      if (adcClockSource == AdcClockSource_Asynch) {
         // Internal clock is always OK with /1
         return sc3|AdcClockSource_Asynch|AdcClockDivider_DivBy1;
      }
      static constexpr unsigned MinClock =  2000000;
      unsigned maxClock = 0;
      switch(adcPower) {
         case AdcPower_Low :
         maxClock =  4000000;
         break;
         case AdcPower_Normal :
         maxClock =  8000000;
         break;
      }
      unsigned adiv;
      for(;;) {
         unsigned clockFrequency = getInputClockFrequency(adcClockSource);
         for (adiv=0; adiv<=3; adiv++) {
            if ((clockFrequency <= maxClock) && (clockFrequency >= MinClock)) {
               break;
            }
            clockFrequency /= 2;
         }
#if false
         if ((adiv>3) && (adcClockSource == AdcClockSource_BusClock)) {
            // Automatically switch from  AdcClockSource_Bus -> AdcClockSource_Busdiv2
            adcClockSource = AdcClockSource_BusClockDiv2;
            continue;
         }
#endif
         break;
      }
      usbdm_assert(adiv<4, "Unable to find suitable ADC clock");
      return sc3|adcClockSource|ADC_SC3_ADIV(adiv);
   }
   
   /**
    * Get ADC maximum conversion value for an single-ended range
    *
    * @param adcResolution
    *
    * @return range e.g. AdcResolution_8bit_se => (2^8)-1
    */
   static constexpr int getSingleEndedMaximum(AdcResolution adcResolution) {
      switch(adcResolution) {
         case AdcResolution_8bit_se:  return (1<<8)-1;
         case AdcResolution_10bit_se: return (1<<10)-1;
         case AdcResolution_12bit_se: return (1<<12)-1;
         default:                     return 0;
      }
   }

protected:
   /**
    * Initiates a conversion at the current resolution but does not wait for it to complete.
    * Intended for use with interrupts or DMA.
    *
    * @param[in] sc1Value SC1 register value.
    *                     This includes channel, differential mode, interrupt and mux selection.
    */
   void startConversion(int sc1Value) const {
   
      // Trigger conversion
      adc->SC1[0] = sc1Value;
      (void)adc->SC1[0];
   };
   
   /**
    * Initiates a conversion but does not wait for it to complete.
    * Intended for use with interrupts or DMA.
    *
    * @param[in] sc1Value SC1 register value.
    *                     This includes channel, differential mode, interrupt and mux selection.
    * @param adcResolution      New Resolution to use (persistent)
    */
   void startConversion(const int sc1Value, AdcResolution adcResolution) const {
   
      // Set resolution
      adc->SC3 = (adc->SC3&~ADC_SC3_MODE_MASK)|adcResolution;
      startConversion(sc1Value);
   };
   
   /**
    * Initiates a conversion at the current resolution and waits for it to complete.
    *
    * @param[in] sc1Value SC1 register value.
    *                     This includes channel, differential mode, interrupt and mux selection.
    *
    * @return - The result of the conversion as an integer converted from 16-bit ADC value
    *           For single-ended conversions this will be zero extended
    *           For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    */
   int readAnalogue(uint32_t sc1Value) const {
   
      startConversion(sc1Value);
      while ((adc->SC1[0]&ADC_SC1_COCO_MASK) == 0) {
         __asm__("nop");
      }
      return getConversionResult();
   };
   
   /**
    * Initiates a conversion and waits for it to complete.
    *
    * @param[in] sc1Value SC1 register value.
    *                     This includes channel, differential mode, interrupt and mux selection.
    * @param[in] adcResolution Resolution for converter e.g. AdcResolution_16bit_se
    *
    * @return - The result of the conversion as an integer converted from 16-bit ADC value
    *           For single-ended conversions this will be zero extended
    *           For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    * @note The resolution used affects all future conversion on all channels on the ADC
    */
   int readAnalogue(uint32_t sc1Value, AdcResolution adcResolution) const {
      adc->SC3 = (adc->SC3&~ADC_SC3_MODE_MASK)|adcResolution;
      return readAnalogue(sc1Value);
   };
   
public:
   /**
    * Initiates a conversion and waits for it to complete.
    *
    * @param adcChannelNum Number of channel to convert
    *
    * @return - The result of the conversion as an integer converted from 16-bit ADC value
    *           For single-ended conversions this will be zero extended
    *           For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    */
   int readAnalogue(AdcChannelNum adcChannelNum) const {
   
      return readAnalogue((uint32_t)adcChannelNum);
   }
   
   /**
    * Enables hardware trigger mode of operation and configures the channel.
    * Note this does not configure the MUX which should be done beforehand
    *
    * @param[in] sc1Value        SC1 register value including the ADC channel, Differential mode and interrupt enable
    */
   void enableHardwareConversion(int sc1Value) const {
   
      // Enable hardware triggers
      adc->SC2 = (adc->SC2)|ADC_SC2_ADTRG_MASK;
   
      adc->SC1[0] = sc1Value;
   }
   
   /**
    * Configure comparison mode.
    *
    * @param[in] adcCompare   Comparison operation to enable
    * @param[in] threshold    Threshold for comparison
    */
   void enableComparison(AdcCompare adcCompare, int threshold) const {
   
      adc->CV = threshold;
   
      // The mask for valid bits (note adcCompare value may contain out-of-bound bits)
      static constexpr uint32_t mask = ADC_SC2_ACFE_MASK|ADC_SC2_ACFGT_MASK;
   
      // Set comparison fields
      adc->SC2 = (adc->SC2&~mask)|adcCompare;
   }
   
   /**
    * Gets result of last software initiated conversion
    *
    * @return The result of the conversion as an integer converted from 16-bit ADC value
    *         For single-ended conversions this will be zero extended
    *         For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    * @note This will also clear the conversion flag if set
    */
   int getConversionResult() const {
   
      // This is a 32-bit value with leading zeroes i.e unsigned
      int value = ADC_R_D_MASK & (adc->R[0]);
   
      return value;
   };
   
   /**
    * Gets result of hardware initiated conversion
    *
    * @return The result of the conversion as an integer converted from 16-bit ADC value
    *         For single-ended conversions this will be zero extended
    *         For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    * @note This will also clear the conversion flag if set
    */
   int getHardwareConversionResult() const {
   
      // This is a 32-bit value with leading zeroes i.e unsigned
      int value = ADC_R_D_MASK & (adc->R[0]);
   
      return value;
   };
   
   /**
    * Set clock source
    *
    * @param[in] adcClockSource  Clock source e.g. AdcClockSource_Asynch
    * @param[in] adcClockDivider Clock divider e.g. AdcClockDivider_4
    *
    * @note This affects all channels on the ADC.

    * The resulting ADC clock rate should be restricted to the following ranges:

    *  [400kHz..4MHz] for low power mode  

    *  [400kHz..8MHz] for normal mode
    */
   void setClockSource(
                          AdcClockSource adcClockSource,
                          AdcClockDivider adcClockDivider=AdcClockDivider_DivBy1) const {
      adc->SC3 = (adc->SC3&~(ADC_SC3_ADIV_MASK|ADC_SC3_ADICLK_MASK))|adcClockSource|adcClockDivider;
   }
   
   
   /**
    * Get Conversion Status
    * (adc_sc2_adact)
    *
    * @return Indicates that a conversion or sequence of conversions is in progress.
    *        Set when a conversion is initiated and cleared when a conversion is completed or aborted
    */
   AdcStatus getConversionActive() const {
      return AdcStatus(adc->SC2&ADC_SC2_ADACT_MASK);
   }
   
   /**
    * Get Conversion Complete Flag
    * (adc_sc1_coco)
    *
    * @return 
    */
   AdcCompleteFlag getConversionComplete() const {
      return AdcCompleteFlag(adc->SC1[0]&ADC_SC1_COCO_MASK);
   }
   
   /**
    * Get ADC Channel number
    * (adc_sc1_channel)
    *
    * @return Selects an ADC channel
    */
   AdcChannelNum getChannel() const {
      return AdcChannelNum(adc->SC1[0]&ADC_SC1_ADCH_MASK);
   }
   
   /**
    * Set Compare Function Control and Compare Value
    *
    * @param adcCompare Configures when the ADC compare function will generate events
    * @param value      Value compared against ADC conversion result to generate compare events
    */
    void configureCompare(
         AdcCompare adcCompare,
         int        value) const {
   
         adc->SC2 =  (adc->SC2 & ~(ADC_SC2_ACFE_MASK|ADC_SC2_ACFGT_MASK))| adcCompare;
         adc->CV =  value;
      }

   /**
    * Allocate ADC Channel number
    * The GPIO function on the associated pin is disabled
    *
    * @param adcChannelNum  Selects an ADC channel
    */
    void allocateAnaloguePin(AdcChannelNum adcChannelNum) const {
      adc->APCTL1 = adc->APCTL1 | (1<<adcChannelNum);
   }
   
   /**
    * Release ADC Channel number
    * The GPIO function on the associated pin is enabled
    *
    * @param adcChannelNum  Selects an ADC channel
    */
    void releaseAnaloguePin(AdcChannelNum adcChannelNum) const {
      adc->APCTL1 = adc->APCTL1 & ~(1<<adcChannelNum);
   }

   /**
    * Class used to do initialisation of the Adc
    *
    * This class has a templated constructor that accepts various values.
    * Parameters available may vary with device - see Adc0::DefaultInitValue for relevant example.
    * Omitted parameters default to zero (disabled) or unchanged if initialiser is provided as last parameter.
    *
    * @note This constructor may be used to create a const instance in Flash
    *
    * Example:
    * @code
    * static const Adc0::Init adc0Init {
    *
    *   // Setup values
AdcAction_None ,                       // (adc_sc1_aien)             Action on conversion completion - None
AdcOperation_Continuous ,              // (adc_sc1_adco)             Single or continuous conversion - Continuous
Adc0ChannelNum_Se5 ,                   // (adc_sc1_adch)             ADC Channel number - [PTB1(11)]
AdcTrigger_Software ,                  // (adc_sc2_adtrg)            Conversion Trigger Select - Software trigger (write to SC1[0])
AdcCompare_Disabled ,                  // (adc_sc2_compare)          Compare Function Control - No comparison done
0 ,                                    // (adc_cv_cv)                Compare Value
AdcReferenceSel_VrefhAndVrefl ,        // (adc_sc2_refsel)           Voltage Reference Selection - VRefH and VRefl
AdcPower_Normal ,                      // (adc_sc3_adlpc)            Low-Power Configuration - Normal power configuration
AdcClockDivider_DivBy8 ,               // (adc_sc3_adiv)             Clock Divide Select - Divide by 8
AdcSampleMode_ShortSampleTime ,        // (adc_sc3_adlsmp)           Sample Time Configuration - Short sample time
AdcResolution_12bit_se ,               // (adc_sc3_mode)             ADC resolution - 12-bit unsigned (single-ended mode)
AdcClockSource_Asynch ,                // (adc_sc3_adiclk)           ADC Input Clock - Asynchronous clock (ADACK)
AdcHardwareAction_SingleConversion ,   // (adc_sc4_htrgme)           Hardware Trigger Multiple Conversion Enable - Single conversion
AdcFifoScanMode_Disabled ,             // (adc_sc4_ascane)           FIFO Scan Mode Enable - Disabled
AdcCompareCondition_OredEvents ,       // (adc_sc4_acfsel)           Compare function OR/AND selection. - ORed events
AdcFifoDepth_FifoDisabled ,            // (adc_sc4_afdep)            FIFO Depth - FIFO disabled
AdcChannelMask_PTA1,
AdcChannelMask_PTB0,
AdcChannelMask_PTB1,
AdcChannelMask_PTB2,
AdcChannelMask_PTB3,                   // (adc_apctl1_adpc)          GPIO Pin Disable
AdcHardwareTriggerMask_Unmasked,       // (adc_sc5_htrigger)         Hardware Trigger Mask - Masking disabled
    *
    *   // Optional base value to start with (must be last parameter)
    *   Adc0::DefaultInitValue   // Used as base value modified by above
    * };
    *
    * // Initialise Adc0 from values specified above
    * Adc0::configure(adc0Init)
    * @endcode
    */
   class Init {
   
   private:
      /**
       * Prevent implicit parameter conversions
       */
      template <typename... Types>
      constexpr Init(Types...) = delete;
   
   public:
      /**
       * Copy Constructor
       */
      constexpr Init(const Init &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr Init() = default;
   
      // Action on conversion completion (adc_sc1_aien)
      // Single or continuous conversion (adc_sc1_adco)
      // ADC Channel number (adc_sc1_channel)
      uint8_t sc1 = 0;

      // Conversion Trigger Select (adc_sc2_adtrg)
      // Compare Function Control (adc_sc2_compare)
      // Voltage Reference Selection (adc_sc2_refsel)
      uint8_t sc2 = 0;

      // Low-Power Configuration (adc_sc3_adlpc)
      // Clock Divide Select (adc_sc3_adiv)
      // Sample Time Configuration (adc_sc3_adlsmp)
      // ADC resolution (adc_sc3_mode)
      // ADC Input Clock (adc_sc3_adiclk)
      uint8_t sc3 = 0;

      // Hardware Trigger Multiple Conversion Enable (adc_sc4_htrgme)
      // FIFO Scan Mode Enable (adc_sc4_ascane)
      // Compare function OR/AND selection. (adc_sc4_acfsel)
      // FIFO Depth (adc_sc4_afdep)
      uint16_t sc4 = 0;

      // Compare Value (adc_cv_cv)
      int cv = 0;

      // GPIO Pin Disable (adc_apctl1_adpc)
      uint16_t apctl1 = 0;

      // Hardware Trigger Mask (adc_sc5_htrigger)
      uint8_t sc5 = 0;

      /**
       * Constructor for Action on conversion completion
       * (adc_sc1_aien)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcAction Controls whether an interrupt is triggered at the end of each conversion
       */
      template <typename... Types>
      constexpr Init(AdcAction adcAction, Types... rest) : Init(rest...) {
   
         sc1 = (sc1&~ADC_SC1_AIEN_MASK) | adcAction;
      }
   
      /**
       * Constructor for Single or continuous conversion
       * (adc_sc1_adco)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcOperation Selects between single and multiple conversions.
       *        Conversions are triggered by a write to the ADC_SC1 when software triggered operation is selected,
       *        or following assertion of ADHWT when hardware triggered operation is selected.
       *        When the FIFO function is enabled (AFDEP != 0), looped sets of conversions are triggered.
       */
      template <typename... Types>
      constexpr Init(AdcOperation adcOperation, Types... rest) : Init(rest...) {
   
         sc1 = (sc1&~ADC_SC1_ADCO_MASK) | adcOperation;
      }
   
      /**
       * Constructor for Conversion Trigger Select
       * (adc_sc2_adtrg)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcTrigger Controls whether conversions are triggered by writes to ADC_SC1 (software)
       *        or assertion of ADHWT input (hardware)
       */
      template <typename... Types>
      constexpr Init(AdcTrigger adcTrigger, Types... rest) : Init(rest...) {
   
         sc2 = (sc2&~ADC_SC2_ADTRG_MASK) | adcTrigger;
      }
   
      /**
       * Constructor for Voltage Reference Selection
       * (adc_sc2_refsel)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcReferenceSel Selects the voltage reference source used for conversions
       */
      template <typename... Types>
      constexpr Init(AdcReferenceSel adcReferenceSel, Types... rest) : Init(rest...) {
   
         sc2 = (sc2&~ADC_SC2_REFSEL_MASK) | adcReferenceSel;
      }
   
      /**
       * Constructor for Low-Power Configuration
       * (adc_sc3_adlpc)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcPower Controls trade-off between speed and power consumption
       *        It also affects the speed of the asynchronous clock
       */
      template <typename... Types>
      constexpr Init(AdcPower adcPower, Types... rest) : Init(rest...) {
   
         sc3 = (sc3&~ADC_SC3_ADLPC_MASK) | adcPower;
      }
   
      /**
       * Constructor for Clock Divide Select
       * (adc_sc3_adiv)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcClockDivider Sets the division of the available clock for use by the ADC
       */
      template <typename... Types>
      constexpr Init(AdcClockDivider adcClockDivider, Types... rest) : Init(rest...) {
   
         sc3 = (sc3&~ADC_SC3_ADIV_MASK) | adcClockDivider;
      }
   
      /**
       * Constructor for Sample Time Configuration
       * (adc_sc3_adlsmp)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcSampleMode Selects between long and short sample times.
       *        Longer sample times allow higher impedance inputs to be accurately sampled or
       *        shorter sample times maximizes the conversion speed for lower impedance inputs.
       *        Longer sample times can also be used to lower overall power consumption when
       *        continuous conversions are enabled.
       */
      template <typename... Types>
      constexpr Init(AdcSampleMode adcSampleMode, Types... rest) : Init(rest...) {
   
         sc3 = (sc3&~ADC_SC3_ADLSMP_MASK) | adcSampleMode;
      }
   
      /**
       * Constructor for ADC resolution
       * (adc_sc3_mode)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcResolution Resolution used for conversion
       */
      template <typename... Types>
      constexpr Init(AdcResolution adcResolution, Types... rest) : Init(rest...) {
   
         sc3 = (sc3&~ADC_SC3_MODE_MASK) | adcResolution;
      }
   
      /**
       * Constructor for ADC Input Clock
       * (adc_sc3_adiclk)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcClockSource Clock source for the ADC module
       */
      template <typename... Types>
      constexpr Init(AdcClockSource adcClockSource, Types... rest) : Init(rest...) {
   
         sc3 = (sc3&~ADC_SC3_ADICLK_MASK) | adcClockSource;
      }
   
      /**
       * Constructor for Hardware Trigger Multiple Conversion Enable
       * (adc_sc4_htrgme)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcHardwareAction Selects whether a hardware trigger event initiates a single conversion
       *        or multiple conversions until the FIFO is full
       */
      template <typename... Types>
      constexpr Init(AdcHardwareAction adcHardwareAction, Types... rest) : Init(rest...) {
   
         sc4 = (sc4&~ADC_SC4_HTRGME_MASK) | adcHardwareAction;
      }
   
      /**
       * Constructor for FIFO Scan Mode Enable
       * (adc_sc4_ascane)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcFifoScanMode When enabled, the FIFO always use the first channel written to SC1. 
       *        The ADC will repeat conversions using this channel until the result
       *        FIFO is fulfilled.
       *        In continuous mode (SC1.ADCO = 1), the ADC will start the next
       *        conversion with the same channel after SC1.COCO is set.
       */
      template <typename... Types>
      constexpr Init(AdcFifoScanMode adcFifoScanMode, Types... rest) : Init(rest...) {
   
         sc4 = (sc4&~ADC_SC4_ASCANE_MASK) | adcFifoScanMode;
      }
   
      /**
       * Constructor for Compare function OR/AND selection.
       * (adc_sc4_acfsel)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcCompareCombine This controls how the compare events from the FIFO values are combined.
       *        If cleared, ADC will OR all of the compare events and set COCO if at least one events occurs. 
       *        If set, ADC will AND all of compare events and set COCO only when all events have occurred
       */
      template <typename... Types>
      constexpr Init(AdcCompareCombine adcCompareCombine, Types... rest) : Init(rest...) {
   
         sc4 = (sc4&~ADC_SC4_ACFSEL_MASK) | adcCompareCombine;
      }
   
      /**
       * Constructor for FIFO Depth
       * (adc_sc4_afdep)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcFifoDepth Emables the FIFO and selects FIFO depth
       */
      template <typename... Types>
      constexpr Init(AdcFifoDepth adcFifoDepth, Types... rest) : Init(rest...) {
   
         sc4 = (sc4&~ADC_SC4_AFDEP_MASK) | adcFifoDepth;
      }
   
      /**
       * Constructor for Hardware Trigger Mask
       * (adc_sc5_htrigger)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcHardwareTriggerMask Control hardware trigger
       */
      template <typename... Types>
      constexpr Init(AdcHardwareTriggerMask adcHardwareTriggerMask, Types... rest) : Init(rest...) {
   
         sc5 = (sc5&~ADC_SC5_HTRIGGER_MASK) | adcHardwareTriggerMask;
      }
   
      /**
       * Constructor for Compare Function Control, Compare Value
       * (adc_sc2_compare,adc_cv_cv)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcCompare Configures when the ADC compare function will generate events
       * @param value      Value compared against ADC conversion result to generate compare events
       */
      template <typename... Types>
      constexpr Init(
            AdcCompare adcCompare,
            int        value, Types... rest) : Init(rest...) {
   
         sc2 =  (sc2 & ~(ADC_SC2_ACFE_MASK|ADC_SC2_ACFGT_MASK))| adcCompare;
         cv =  value;
      }
   
      /**
       * Constructor for GPIO Pin Disable using a bit mask
       * (adc_apctl1_adpc)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param value Bit mask disabling the GPIO function on the pin corresponding to a ADC channel.
       *        This is only necessary for Channels 0-15.
       *        The GPIO corresponding to the Input Channel Selected will also be disabled.
       *        0:pin is GPIO, 1:pin is Analogue
       */
      template <typename... Types>
      constexpr Init(AdcChannelMask adcChannelMask, Types... rest) : Init(rest...) {
   
         apctl1 |= adcChannelMask;
      }
   
      /**
       * Constructor for ADC Channel number
       * This will set the initial channel and also disable the GPIO function on
       * the pin associated with the ADC channel
   
       * @tparam   Types
       * @param    rest
       *
       * @param value ADC Channel number and GPIO Pin Disable
       */
      template <typename... Types>
      constexpr Init(AdcChannelNum  adcChannelNum, Types... rest) : Init(rest...) {
   
         apctl1 |= 1<<adcChannelNum;
         sc1 = (sc1&~ADC_SC1_ADCH_MASK) | adcChannelNum;
      }
   
   }; // class AdcBasicInfo::Init
   
   /**
    * Configure ADC from values specified in init
    * This routine does not configure pins or interrupt handlers
    *
    * @param adc            Hardware instance pointer
    * @param init            Class containing initialisation values
    */
   static void configure(
                  volatile ADC_Type *adc,
                  const Init    &init) {
   
      // Calculate clock dividers and update sc3
      uint8_t sc3 = calculateClockDivider(init.sc3);
   
   
      // ADC Channel number (adc_sc1_channel)
      adc->SC1[0] = AdcChannelNum_Disabled;
   
      // GPIO Pin Disable (adc_apctl1_adpc)
      adc->APCTL1 = init.apctl1;
   
      // Conversion Trigger Select (adc_sc2_adtrg)
      // Voltage Reference Selection (adc_sc2_refsel)
      adc->SC2 = init.sc2;
   
      // Low-Power Configuration (adc_sc3_adlpc)
      // Clock Divide Select (adc_sc3_adiv)
      // Sample Time Configuration (adc_sc3_adlsmp)
      // ADC resolution (adc_sc3_mode)
      // ADC Input Clock (adc_sc3_adiclk)
      adc->SC3 = sc3;
   
      // Hardware Trigger Multiple Conversion Enable (adc_sc4_htrgme)
      // FIFO Scan Mode Enable (adc_sc4_ascane)
      // Compare function OR/AND selection. (adc_sc4_acfsel)
      // FIFO Depth (adc_sc4_afdep)
      adc->SC4 = init.sc4;
   
      // Compare Value (adc_cv_cv)
      adc->CV = init.cv;
   
      // Hardware Trigger Mask (adc_sc5_htrigger)
      adc->SC5 = init.sc5;
   
      // Action on conversion completion (adc_sc1_aien)
      // Single or continuous conversion (adc_sc1_adco)
      // ADC Channel number (adc_sc1_channel)
      adc->SC1[0] = init.sc1;
   }
   
   /**
    * Configure ADC from values specified in init
    * This routine does not configure pins or interrupt handlers
    *
    * @param init Class containing initialisation values
    */
   void configure(const Init &init) const {
   
      configure(adc, init);
   }
   
}; // class AdcBasicInfo 

class Adc0Info : public AdcBasicInfo {

public:
   /*
    * Template:adc0_mke04
    */
   //! Class based interrupt code has been generated for this class of peripheral
   // (_BasicInfoIrqGuard)
   static constexpr bool irqHandlerInstalled = false;
   
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = ADC0_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(irqNums[0]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[0], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(irqNums[0]);
   }
   
   /**
    *  Enable clock to Adc0
    */
   static void enableClock() {
      SIM->SCGC = SIM->SCGC | SIM_SCGC_ADC0_MASK;
   }
   
   /**
    *  Disable clock to Adc0
    */
   static void disableClock() {
      SIM->SCGC = SIM->SCGC & ~SIM_SCGC_ADC0_MASK;
   }
   
   /**
    * Basic enable of Adc0
    * Includes enabling clock and configuring all mapped pins if mapPinsOnEnable is selected in configuration
    */
   static void enable() {
      enableClock();
   }
   
   /**
    * Disables Adc0
    */
   static void disable() {
   
      adc->SC1[0] = ADC_SC1_ADCH(-1);
      disableNvicInterrupts();
      disableClock();
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = ADC0_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<ADC_Type> adc = baseAddress;
   
   //! Peripheral instance number
   static constexpr unsigned instance = 0;
   
protected:
   /**
    * Initiates a conversion at the current resolution but does not wait for it to complete.
    * Intended for use with interrupts or DMA.
    *
    * @param[in] sc1Value SC1 register value.
    *                     This includes channel, differential mode, interrupt and mux selection.
    */
   static void startConversion(int sc1Value) {
   
      // Trigger conversion
      adc->SC1[0] = sc1Value;
      (void)adc->SC1[0];
   };
   
   /**
    * Initiates a conversion but does not wait for it to complete.
    * Intended for use with interrupts or DMA.
    *
    * @param[in] sc1Value SC1 register value.
    *                     This includes channel, differential mode, interrupt and mux selection.
    * @param adcResolution      New Resolution to use (persistent)
    */
   static void startConversion(const int sc1Value, AdcResolution adcResolution) {
   
      // Set resolution
      adc->SC3 = (adc->SC3&~ADC_SC3_MODE_MASK)|adcResolution;
      startConversion(sc1Value);
   };
   
   /**
    * Initiates a conversion at the current resolution and waits for it to complete.
    *
    * @param[in] sc1Value SC1 register value.
    *                     This includes channel, differential mode, interrupt and mux selection.
    *
    * @return - The result of the conversion as an integer converted from 16-bit ADC value
    *           For single-ended conversions this will be zero extended
    *           For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    */
   static int readAnalogue(uint32_t sc1Value) {
   
      startConversion(sc1Value);
      while ((adc->SC1[0]&ADC_SC1_COCO_MASK) == 0) {
         __asm__("nop");
      }
      return getConversionResult();
   };
   
   /**
    * Initiates a conversion and waits for it to complete.
    *
    * @param[in] sc1Value SC1 register value.
    *                     This includes channel, differential mode, interrupt and mux selection.
    * @param[in] adcResolution Resolution for converter e.g. AdcResolution_16bit_se
    *
    * @return - The result of the conversion as an integer converted from 16-bit ADC value
    *           For single-ended conversions this will be zero extended
    *           For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    * @note The resolution used affects all future conversion on all channels on the ADC
    */
   static int readAnalogue(uint32_t sc1Value, AdcResolution adcResolution) {
      adc->SC3 = (adc->SC3&~ADC_SC3_MODE_MASK)|adcResolution;
      return readAnalogue(sc1Value);
   };
   
public:
   /**
    * Initiates a conversion and waits for it to complete.
    *
    * @param adcChannelNum Number of channel to convert
    *
    * @return - The result of the conversion as an integer converted from 16-bit ADC value
    *           For single-ended conversions this will be zero extended
    *           For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    */
   static int readAnalogue(AdcChannelNum adcChannelNum) {
   
      return readAnalogue((uint32_t)adcChannelNum);
   }
   
   /**
    * Enables hardware trigger mode of operation and configures the channel.
    * Note this does not configure the MUX which should be done beforehand
    *
    * @param[in] sc1Value        SC1 register value including the ADC channel, Differential mode and interrupt enable
    */
   static void enableHardwareConversion(int sc1Value) {
   
      // Enable hardware triggers
      adc->SC2 = (adc->SC2)|ADC_SC2_ADTRG_MASK;
   
      adc->SC1[0] = sc1Value;
   }
   
   /**
    * Configure comparison mode.
    *
    * @param[in] adcCompare   Comparison operation to enable
    * @param[in] threshold    Threshold for comparison
    */
   static void enableComparison(AdcCompare adcCompare, int threshold) {
   
      adc->CV = threshold;
   
      // The mask for valid bits (note adcCompare value may contain out-of-bound bits)
      static constexpr uint32_t mask = ADC_SC2_ACFE_MASK|ADC_SC2_ACFGT_MASK;
   
      // Set comparison fields
      adc->SC2 = (adc->SC2&~mask)|adcCompare;
   }
   
   /**
    * Gets result of last software initiated conversion
    *
    * @return The result of the conversion as an integer converted from 16-bit ADC value
    *         For single-ended conversions this will be zero extended
    *         For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    * @note This will also clear the conversion flag if set
    */
   static int getConversionResult() {
   
      // This is a 32-bit value with leading zeroes i.e unsigned
      int value = ADC_R_D_MASK & (adc->R[0]);
   
      return value;
   };
   
   /**
    * Gets result of hardware initiated conversion
    *
    * @return The result of the conversion as an integer converted from 16-bit ADC value
    *         For single-ended conversions this will be zero extended
    *         For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    * @note This will also clear the conversion flag if set
    */
   static int getHardwareConversionResult() {
   
      // This is a 32-bit value with leading zeroes i.e unsigned
      int value = ADC_R_D_MASK & (adc->R[0]);
   
      return value;
   };
   
   /**
    * Set clock source
    *
    * @param[in] adcClockSource  Clock source e.g. AdcClockSource_Asynch
    * @param[in] adcClockDivider Clock divider e.g. AdcClockDivider_4
    *
    * @note This affects all channels on the ADC.

    * The resulting ADC clock rate should be restricted to the following ranges:

    *  [400kHz..4MHz] for low power mode  

    *  [400kHz..8MHz] for normal mode
    */
   static void setClockSource(
                          AdcClockSource adcClockSource,
                          AdcClockDivider adcClockDivider=AdcClockDivider_DivBy1) {
      adc->SC3 = (adc->SC3&~(ADC_SC3_ADIV_MASK|ADC_SC3_ADICLK_MASK))|adcClockSource|adcClockDivider;
   }
   
   
   /**
    * Get Conversion Status
    * (adc_sc2_adact)
    *
    * @return Indicates that a conversion or sequence of conversions is in progress.
    *        Set when a conversion is initiated and cleared when a conversion is completed or aborted
    */
   static AdcStatus getConversionActive() {
      return AdcStatus(adc->SC2&ADC_SC2_ADACT_MASK);
   }
   
   /**
    * Get Conversion Complete Flag
    * (adc_sc1_coco)
    *
    * @return 
    */
   static AdcCompleteFlag getConversionComplete() {
      return AdcCompleteFlag(adc->SC1[0]&ADC_SC1_COCO_MASK);
   }
   
   /**
    * Get ADC Channel number
    * (adc_sc1_channel)
    *
    * @return Selects an ADC channel
    */
   static AdcChannelNum getChannel() {
      return AdcChannelNum(adc->SC1[0]&ADC_SC1_ADCH_MASK);
   }
   
   /**
    * Set Compare Function Control and Compare Value
    *
    * @param adcCompare Configures when the ADC compare function will generate events
    * @param value      Value compared against ADC conversion result to generate compare events
    */
   static  void configureCompare(
         AdcCompare adcCompare,
         int        value) {
   
         adc->SC2 =  (adc->SC2 & ~(ADC_SC2_ACFE_MASK|ADC_SC2_ACFGT_MASK))| adcCompare;
         adc->CV =  value;
      }

   /**
    * Allocate ADC Channel number
    * The GPIO function on the associated pin is disabled
    *
    * @param adcChannelNum  Selects an ADC channel
    */
   static  void allocateAnaloguePin(AdcChannelNum adcChannelNum) {
      adc->APCTL1 = adc->APCTL1 | (1<<adcChannelNum);
   }
   
   /**
    * Release ADC Channel number
    * The GPIO function on the associated pin is enabled
    *
    * @param adcChannelNum  Selects an ADC channel
    */
   static  void releaseAnaloguePin(AdcChannelNum adcChannelNum) {
      adc->APCTL1 = adc->APCTL1 & ~(1<<adcChannelNum);
   }

   /** Get reference to ADC hardware as struct */
   static volatile ADC_Type &adcPtr() { return *adc; }
   
   /** @return Base address of ADC hardware as uint32_t */
   static constexpr uint32_t adcBase() { return baseAddress; }
   /** @return Base address of ADC.SC1[index] registers as uint32_t */
   static constexpr uint32_t adcSC(unsigned index) { return adcBase() + offsetof(ADC_Type, SC1) + index*sizeof(ADC_Type::SC1[0]); }
   /** @return Base address of ADC.R[index] registers as uint32_t */
   static constexpr uint32_t adcR(unsigned index) { return adcBase() + offsetof(ADC_Type, R) + index*sizeof(ADC_Type::R[0]); }
   
   /**
    *   Default Constructor
    */
   Adc0Info() : AdcBasicInfo(adc) {
      defaultConfigure();
   }
   
   /**
    *   Constructor
    */
   Adc0Info(const Init &init) : AdcBasicInfo(adc) {
      configure(init);
   }
   
   /**
    * Configure with default settings.
    * Configuration determined from Configure.usbdmProject
    */
   static void defaultConfigure() {
   
      configure(DefaultInitValue);
   }
   
   /**
    * Configure ADC from values specified in init
    *
    * @param init Class containing initialisation values
    */
   static void configure(const Init &init) {
   
      // Enable peripheral
      enable();
   
      AdcBasicInfo::configure(adc, init);
   }
   
   /**
    * Default initialisation value for Adc0
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr Init DefaultInitValue = {
   
      AdcAction_None ,                       // (adc_sc1_aien)             Action on conversion completion - None
      AdcOperation_Single ,                  // (adc_sc1_adco)             Single or continuous conversion - Single
      AdcChannelNum_Se0 ,                    // (adc_sc1_adch)             ADC Channel number - ADC0_SE0 [-]
      AdcTrigger_Software ,                  // (adc_sc2_adtrg)            Conversion Trigger Select - Software trigger (write to SC1[0])
      AdcCompare_Disabled ,                  // (adc_sc2_compare)          Compare Function Control - No comparison done
      0 ,                                    // (adc_cv_cv)                Compare Value
      AdcReferenceSel_VrefhAndVrefl ,        // (adc_sc2_refsel)           Voltage Reference Selection - VRefH and VRefl
      AdcClockSource_Asynch ,                // (adc_sc3_adiclk)           ADC Input Clock - Asynchronous clock (ADACK)
      AdcClockDivider_DivBy8 ,               // (adc_sc3_adiv)             Clock Divide Select - Divide by 8
      AdcPower_Normal ,                      // (adc_sc3_adlpc)            Low-Power Configuration - Normal power configuration
      AdcSampleMode_LongSampleTime ,         // (adc_sc3_adlsmp)           Sample Time Configuration - Long sample time
      AdcResolution_12bit_se ,               // (adc_sc3_mode)             ADC resolution - 12-bit unsigned (single-ended mode)
      AdcHardwareAction_SingleConversion ,   // (adc_sc4_htrgme)           Hardware Trigger Multiple Conversion Enable - Single conversion
      AdcFifoScanMode_Disabled ,             // (adc_sc4_ascane)           FIFO Scan Mode Enable - Disabled
      AdcCompareCombine_AsOredEvents ,       // (adc_sc4_acfsel)           Compare function OR/AND selection. - ORed events
      AdcFifoDepth_FifoDisabled ,            // (adc_sc4_afdep)            FIFO Depth - FIFO disabled
      AdcChannelMask_PTA1|
       AdcChannelMask_PTB0|
       AdcChannelMask_PTB1|
       AdcChannelMask_PTB2|
       AdcChannelMask_PTB3 , // (adc_apctl1_adpc)          GPIO Pin Disable
      AdcHardwareTriggerMask_Unmasked,       // (adc_sc5_htrigger)         Hardware Trigger Mask - Masking disabled
   };
   
   /** Internal ADC clock */
   static constexpr unsigned adiclk = 3300000;
   
   /**
    * Set ADC Input Clock
    *
    * @param adcClockSource Clock source for the ADC module
    */
   static void setClock(AdcClockSource adcClockSource) {
      adc->SC3 = (adc->SC3&~ADC_SC3_ADICLK_MASK) | adcClockSource;
   }
   
   /**
    * Get ADC Input Clock
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getClockFrequency(AdcClockSource adcClockSource) {
   
      switch(adcClockSource) {
         default: return 0;
         case AdcClockSource_BusClock     : return SystemBusClock;          ///< Bus clock
         case AdcClockSource_BusClockDiv2 : return SystemBusClock/2;        ///< Bus clock/2
         case AdcClockSource_OscerClk     : return Osc0Info::getOscClock(); ///< Alternate clock (OSCERCLK)
         case AdcClockSource_Asynch       : return 3300000;     ///< Asynchronous clock (ADACK)

      }
   }
   
   /**
    * Get clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getClockFrequency() {
      return getClockFrequency((AdcClockSource)(adc->SC3&ADC_SC3_ADICLK_MASK));
   }; 

}; // class Adc0Info



/**
 * Class representing a minimal ADC channel
 *
 * This class is not intended to be instantiated directly.
 */
class AdcChannel : public AdcBasicInfo {

private:
   AdcChannel() = delete;
   AdcChannel(const AdcChannel&) = delete;
   AdcChannel(AdcChannel&&) = delete;

protected:
   /// ADC channel (including ADC_SC1_DIFF_MASK mask)
   const uint32_t sc1Value;

   /**
    * Constructor
    *
    * @param adcAddress  ADC address
    * @param channel     ADC channel to use
    */
   constexpr AdcChannel(uint32_t adcAddress, uint8_t channel) : AdcBasicInfo((volatile ADC_Type *)adcAddress), sc1Value(channel) {}

public:
   /**
    * Initiates a conversion and waits for it to complete.
    *
    * @return The result of the conversion as an integer converted from 16-bit ADC value\n
    *         For single-ended conversions this will be zero extended\n
    *         For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    */
   int readAnalogue() const {
      return AdcBasicInfo::readAnalogue(sc1Value);
   };

   /**
    * Initiates a conversion and waits for it to complete.
    *
    * @param[in] adcResolution Resolution for converter e.g. AdcResolution_16bit_se
    *
    * @return The result of the conversion as an integer converted from 16-bit ADC value\n
    *         For single-ended conversions this will be zero extended\n
    *         For differential conversions this will be sign-extended
    *
    * @note Result is signed but will always be positive for single-ended conversions.
    * @note The resolution used here affects all future conversion on all channels on the ADC
    */
   int readAnalogue(AdcResolution adcResolution) const {
      return AdcBasicInfo::readAnalogue(sc1Value, adcResolution);
   };

   /**
    * Enables hardware trigger mode of operation and configures a channel.
    *
    * @param[in] adcAction     Whether to generate an interrupt when each conversion completes
    */
   void enableHardwareConversion(AdcAction adcAction) const {
      AdcBasicInfo::enableHardwareConversion(adcAction|sc1Value);
   }

   /**
    * Initiates a conversion but does not wait for it to complete.
    * Intended for use with interrupts or DMA.
    *
    * @param[in] adcAction   Determines if an interrupt is generated when conversions are complete
    */
   void startConversion(AdcAction adcAction=AdcAction_None) const {
      AdcBasicInfo::startConversion(sc1Value|adcAction);
   };

}; // class AdcChannel

/**
 * Template class representing an ADC.
 * This class is not intended to be instantiated.
 *
 * Example
 * @code
 *  // Access to ADC0
 *  using Adc0 = AdcBase_T<Adc0Info>;
 *
 *  // Initialise ADC
 *  Adc0::setMode(AdcResolution_16bit_se);
 *  @endcode
 *
 * @tparam info Table of information describing ADC
 */
template<class Info>
class AdcBase_T : public Info {

public:
   /** Hardware instance pointer */
   static constexpr HardwarePtr<ADC_Type> adc = Info::baseAddress;

   /** Get reference to ADC hardware as struct */
   static volatile ADC_Type &adcPtr() { return Info::adc(); }

   /** @return Base address of SPI hardware as uint32_t */
   static constexpr uint32_t adcBase() { return Info::baseAddress; }
   /** @return Base address of ADC.SC1[index] registers as uint32_t */
   static constexpr uint32_t adcSC(unsigned index) { return adcBase() + offsetof(ADC_Type, SC1) + index*sizeof(ADC_Type::SC1[0]); }
   /** @return Base address of ADC.R[index] registers as uint32_t */
   static constexpr uint32_t adcR(unsigned index) { return adcBase() + offsetof(ADC_Type, R) + index*sizeof(ADC_Type::R[0]); }

   using Info::configure;

public:

   AdcBase_T() = default;

   /**
    * Template class representing an ADC channel.
    *
    * Example
    * @code
    * // Instantiate the ADC and the channel (for ADC0 channel 6)
    * using Adc0    = AdcBase_T<Adc0Info>;
    * using Adc0Ch6 = Adc0::Channel<6>;
    *
    * // Set ADC resolution
    * Adc0::setMode(AdcResolution_16bit_se);
    *
    * // Read ADC value
    * uint32_t value = Adc0Ch6::readAnalogue();
    * @endcode
    *
    * @tparam channel ADC channel
    */
   template<AdcChannelNum channel>
   class ChannelCommon : public AdcChannel {
   private:
      /**
       * This class is not intended to be instantiated
       */
      ChannelCommon(const ChannelCommon&) = delete;
      ChannelCommon(ChannelCommon&&) = delete;

   public:
      constexpr ChannelCommon() : AdcChannel(AdcInfo::baseAddress, channel) {}

      /** The ADC that owns this channel */
      using Owner = AdcBase_T;

      /** Information about this ADC */
      using AdcInfo = Info;

      /** Channel number */
      static constexpr AdcChannelNum CHANNEL=channel;

      /**
       * Initiates a conversion but does not wait for it to complete.
       * Intended for use with interrupts or DMA.
       *
       * @param[in] adcAction   Determines if an interrupt is generated when conversions are complete
       */
      static void startConversion(AdcAction adcAction=AdcAction_None) {
         if constexpr(!Info::irqHandlerInstalled) {
            usbdm_assert((adcAction == AdcAction_None),
                  "ADC not configured for interrupts. Modify Configure.usbdmProject");
         }
         AdcBase_T::startConversion(channel|adcAction);
      };

      /**
       * Initiates a conversion but does not wait for it to complete.
       * Intended for use with interrupts or DMA.
       *
       * @param adcResolution      New Resolution to use (persistent)
       * @param[in] adcAction   Determines if an interrupt is generated when conversions are complete
       */
      static void startConversion(AdcResolution adcResolution, AdcAction adcAction=AdcAction_None) {
         if constexpr(!Info::irqHandlerInstalled) {
            usbdm_assert((adcAction == AdcAction_None),
                  "ADC not configured for interrupts. Modify Configure.usbdmProject");
         }
         AdcBase_T::startConversion(channel|adcAction, adcResolution);
      };

      /**
       * Initiates a conversion and waits for it to complete.
       *
       * @return - The result of the conversion as an integer converted from 16-bit ADC value\n
       *           For single-ended conversions this will be zero extended\n
       *           For differential conversions this will be sign-extended
       *
       * @note Result is signed but will always be positive for single-ended conversions.
       */
      static int readAnalogue() {
         return AdcBase_T::readAnalogue(channel);
      };
      /**
       * Initiates a conversion and waits for it to complete.
       *
       * @param[in] adcResolution Resolution for converter e.g. AdcResolution_16bit_se
       *
       * @return - The result of the conversion as an integer converted from 16-bit ADC value\n
       *           For single-ended conversions this will be zero extended\n
       *           For differential conversions this will be sign-extended
       *
       * @note Result is signed but will always be positive for single-ended conversions.
       * @note The resolution used here affects all further conversion on all channels on the ADC
       */
      static int readAnalogue(AdcResolution adcResolution) {
         return AdcBase_T::readAnalogue(channel, adcResolution);
      };

      /**
       * Enables hardware trigger mode of operation and configures a channel.
       *
       * @param[in] adcPretrigger   Hardware pre-trigger to use for this channel.\n
       *                            This corresponds to pre-triggers in the PDB channels and SC1[n]/R[n] register selection
       * @param[in] adcAction    Whether to generate an interrupt when each conversion completes
       */
      static void enableHardwareConversion(AdcAction adcAction=AdcAction_None) {
         AdcBase_T::enableHardwareConversion(channel|adcAction);
      }

#ifdef ADC_SC2_DMAEN
      /**
       * Enables hardware trigger mode of operation and configures a channel.
       *
       * @param[in] adcPretrigger   Hardware pre-trigger to use for this channel\n
       *                            This corresponds to pre-triggers in the PDB channels and SC1[n]/R[n] register selection
       * @param[in] adcAction    Whether to generate an interrupt when each conversion completes
       * @param[in] adcDma          Whether to generate a DMA request when each conversion completes
       */
      static void enableHardwareConversion(AdcAction adcAction, AdcDma adcDma) {
         AdcBase_T::enableHardwareConversion(channel|adcAction, adcDma);
      }
#endif
   };

   template<AdcChannelNum channel>
   class Channel : public ChannelCommon<channel>  {
   private:
#if false // adc_sc1_diff_present
      static_assert(((channel<AdcChannelNum_DiffFirst)||(channel>AdcChannelNum_DiffLast)), "Illegal channel number");
#endif
   public:

      /**
       * Configure the pin associated with this ADC channel.
       * The pin is in analogue mode so no PCR settings are active.
       * This function is of use if mapAllPins and mapAllPinsOnEnable are not selected in USBDM configuration.
       */
      static void setInput() {
         // Map pin to ADC (disable associated digital function)
         adc->APCTL1 = adc->APCTL1| 1<<channel;
      }

      /**
       *  Disable Pin
       *  This sets the pin to MUX 0 which is specified for minimum leakage in low-power modes.
       *
       *  @note The clock is left enabled as shared with other pins.
       *  @note Mux(0) is also the Analogue MUX setting
       */
      static void disablePin() {
         // Unmap pin from ADC (enable associated digital function)
         adc->APCTL1 = adc->APCTL1 &~(1<<channel);
      }
   };

#if defined(ADC_PGA_PGAEN_MASK)
   /**
    * Template class representing an ADC channel with programmable gain amplifier.
    *
    * Example
    * @code
    * // Instantiate the ADC and the channel (for ADC0 channel 6)
    * using Adc0    = AdcBase_T<Adc0Info>;
    * using Adc0Ch6 = Adc0::PgaChannel;
    *
    * // Set ADC resolution
    * Adc0::setMode(AdcResolution_16bit_se);
    *
    * // Read ADC value
    * uint32_t value = Adc0Ch6::readAnalogue();
    * @endcode
    */
   class PgaChannel : public ChannelCommon<AdcChannelNum_Diff2> {
   private:
      /**
       * This class is not intended to be instantiated
       */
      PgaChannel(const PgaChannel&) = delete;
      PgaChannel(PgaChannel&&) = delete;

   public:
      constexpr PgaChannel(){}
   };
#endif

#ifdef ADC_SC1_DIFF_MASK
   /**
    * Template class representing an ADC differential channel
    *
    * Example
    * @code
    * // Instantiate the ADC and the differential channel (for ADC_DM0, ADC_DP0)
    * using Adc0 = AdcBase_T<Adc0Info>;
    * using Adc0Ch6 = Adc0::DiffChannel<AdcChannelNum_Diff1>;
    *
    * // Set ADC resolution
    * Adc0.setMode(AdcResolution_11bit_diff );
    *
    * // Read ADC value
    * uint32_t value = Adc0Ch0.readAnalogue();
    * @endcode
    *
    * @tparam channel ADC channel
    */
   template<AdcChannelNum channel>
   class DiffChannel : public ChannelCommon<channel> {

      static_assert((channel>=AdcChannelNum_DiffFirst)&&(channel<=AdcChannelNum_DiffLast), "Illegal differential channel number");

   private:
      /**
       * This class is not intended to be instantiated
       */
      DiffChannel(const DiffChannel&) = delete;
      DiffChannel(DiffChannel&&) = delete;

      static constexpr AdcBasicInfo::CheckPinExistsAndIsMapped<Info, channel>   checkPos{};
      static constexpr AdcBasicInfo::CheckPinExistsAndIsMapped<Info, channel+8> checkNeg{};

   public:
      constexpr DiffChannel() : ChannelCommon<AdcChannelNum(channel)>() {}

      /** PCR associated with plus channel */
      using PcrP = PcrTable_T<Info, channel>;

      /** PCR associated with minus channel */
      using PcrM = PcrTable_T<Info, channel>;

      /** The ADC that owns this channel */
      using Owner = AdcBase_T;

      /** Information about this ADC */
      using AdcInfo = Info;

      /** Channel number */
      static constexpr int CHANNEL=channel;

      /**
       * Configure the pins associated with this ADC channel.
       * The pins are in analogue mode so no PCR settings are active.
       * This function is of use if mapAllPins and mapAllPinsOnEnable are not selected in USBDM configuration.
       */
      static void setInput() {
         // Map pins to ADC
         PcrP::setPCR(Info::info[channel].pcrValue);
         PcrM::setPCR(Info::info[channel].pcrValue);
      }

      /**
       *  Disable Pin
       *  This sets the pin to MUX 0 which is specified for minimum leakage in low-power modes.
       *
       *  @note The clock is left enabled as shared with other pins.
       *  @note Mux(0) is also the Analogue MUX setting
       */
      static void disablePin() {
         // Map pin to ADC
         if constexpr (AdcInfo::InfoDP::info[0x1f&mapChannelNumToPhysicalChannelNum(channel)].portAddress != 0) {
            PcrP::disablePin();
            PcrM::disablePin();
         }
      }
   };

#if defined(ADC_PGA_PGAEN_MASK)
   /**
    * Template class representing an ADC channel with programmable gain amplifier.
    *
    * Example
    * @code
    * // Instantiate the ADC and the channel (for ADC0 channel 6)
    * using Adc0    = AdcBase_T<Adc0Info>;
    * using Adc0Ch6 = Adc0::PgaChannel;
    *
    * // Set ADC resolution
    * Adc0::setMode(AdcResolution_16bit_se);
    *
    * // Read ADC value
    * uint32_t value = Adc0Ch6::readAnalogue();
    * @endcode
    */
   class PgaDiffChannel : public DiffChannel<AdcChannelNum_Diff2> {

   private:
      /**
       * This class is not intended to be instantiated
       */
      PgaDiffChannel(const PgaDiffChannel&) = delete;
      PgaDiffChannel(PgaDiffChannel&&) = delete;

   public:
      constexpr PgaDiffChannel(){}
   };
#endif

#endif

};

   /**
    * Class representing ADC instance
    */
   typedef AdcBasicInfo Adc;
   /**
    * Class representing ADC0
    */
   typedef AdcBase_T<Adc0Info> Adc0;
   

/**
 * End ADC_Group
 * @}
 */

} // End namespace USBDM

#endif // /ADC/_BasicInfoGuard

#endif /* HEADER_ADC_H */

