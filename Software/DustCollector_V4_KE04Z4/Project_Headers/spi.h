/**
 * @file     spi.h (180.ARM_Peripherals/Project_Headers/spi-MKL.h)
 * @brief    Serial Peripheral Interface
 */

#ifndef INCLUDE_USBDM_SPI_H_
#define INCLUDE_USBDM_SPI_H_

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include <stdint.h>
#include "derivative.h"
#include "pin_mapping.h"
#ifdef __CMSIS_RTOS
#include "cmsis.h"
#endif

#if false // /SPI/_BasicInfoGuard

// No handler defined for SPI0


namespace USBDM {

/**
 * @addtogroup SPI_Group SPI, Serial Peripheral Interface
 * @brief C++ Class allowing access to SPI interface
 * @{
 */
/**
 * Peripheral information for SPI, Serial Peripheral Interface.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * System enable
    * (spi_c1_spe)
    *
    * 
    */
   enum SpiEnable {
      SpiEnable_Disabled   = SPI_C1_SPE(0),  ///< Disabled
      SpiEnable_Enabled    = SPI_C1_SPE(1),  ///< Enabled
   };

   /**
    * Communication Mode
    * (spi_c1_mode)
    *
    * Controls clock polarity and the timing relationship between clock and data
    * Mode 0: Active-high clock (idles low), Data is captured on leading edge of SCK and changes on the following 
    * edge
    * Mode 1: Active-high clock (idles low), Data is changes on leading edge of SCK and captured on the following 
    * edge
    * Mode 2: Active-low clock (idles high), Data is captured on leading edge of SCK and changes on the following 
    * edge
    * Mode 3: Active-low clock (idles high), Data is changes on leading edge of SCK and captured on the following 
    * edge
    */
   enum SpiMode {
      SpiMode_0   = SPI_C1_CPOL(0)|SPI_C1_CPHA(0),  ///< Mode 0
      SpiMode_1   = SPI_C1_CPOL(0)|SPI_C1_CPHA(1),  ///< Mode 1
      SpiMode_2   = SPI_C1_CPOL(1)|SPI_C1_CPHA(0),  ///< Mode 2
      SpiMode_3   = SPI_C1_CPOL(1)|SPI_C1_CPHA(1),  ///< Mode 3
   };

   /**
    * Controller/Peripheral role select
    * (spi_c1_mstr)
    *
    * Peripheral mode not supported
    */
   enum SpiRole {
      SpiRole_Peripheral   = SPI_C1_MSTR(0),  ///< Peripheral role
      SpiRole_Controller   = SPI_C1_MSTR(1),  ///< Controller role
   };

   /**
    * Pin Use
    * (spi_pinuse)
    *
    * Controls use of Peripheral select pin in Controller mode
    */
   enum SpiPinUse {
      SpiPinUse_Gpio                     = SPI_C2_MODFEN(0)|SPI_C1_SSOE(0),  ///< GPIO (non-SPI)
      SpiPinUse_FaultInput               = SPI_C2_MODFEN(1)|SPI_C1_SSOE(0),  ///< Fault input
      SpiPinUse_PeripheralSelectOutput   = SPI_C2_MODFEN(1)|SPI_C1_SSOE(1),  ///< Peripheral select output
   };

   /**
    * Transmission order
    * (spi_c1_lsbfe)
    *
    * Controls whether serial data transfers start with most-significant or least-significant bit
    */
   enum SpiBitOrder {
      SpiBitOrder_MsbFirst   = SPI_C1_LSBFE(0),  ///< MSB first
      SpiBitOrder_LsbFirst   = SPI_C1_LSBFE(1),  ///< LSB first
   };

   /**
    * Interrupt enable: for SPRF and MODF
    * (spi_c1_spie)
    *
    * Controls interrupts for SPI receive buffer full (S.SPRF) and mode fault (S.MODF) events.
    */
   enum SpiReceiveInterrupt {
      SpiReceiveInterrupt_InterruptsDisabled   = SPI_C1_SPIE(0),  ///< Interrupts disabled
      SpiReceiveInterrupt_InterruptsEnabled    = SPI_C1_SPIE(1),  ///< Interrupts enabled
   };

   /**
    * Transmit interrupt enable
    * (spi_c1_sptie)
    *
    * Controls interrupts for SPI transmit buffer empty (S.SPTEF)
    */
   enum SpiTransmitInterrupt {
      SpiTransmitInterrupt_InterruptsDisabled   = SPI_C1_SPTIE(0),  ///< Interrupts disabled
      SpiTransmitInterrupt_InterruptsEnabled    = SPI_C1_SPTIE(1),  ///< Interrupts enabled
   };

   /**
    * Match interrupt
    * (spi_c2_spmie)
    *
    * Controls hardware match interrupt (S.SPMF)
    */
   enum SpiMatchInterrupt {
      SpiMatchInterrupt_Disabled   = SPI_C2_SPMIE(0),  ///< Interrupts disabled
      SpiMatchInterrupt_Enabled    = SPI_C2_SPMIE(1),  ///< Interrupts enabled
   };

   /**
    * Stop in wait mode
    * (spi_c2_spiswai)
    *
    * Controls operation in Wait mode
    */
   enum SpiWaitMode {
      SpiWaitMode_Operate   = SPI_C2_SPISWAI(0),  ///< Operate normally
      SpiWaitMode_Stopped   = SPI_C2_SPISWAI(1),  ///< Clocks stopped
   };

   /**
    * Bidirectional Mode
    * (spi_c2_bidirectional)
    *
    * Selects bidirectional data pin configurations
    */
   enum SpiBidirectional {
      SpiBidirectional_Normal   = SPI_C2_SPC0(0)|SPI_C2_BIDIROE(0),  ///< Normal (non-bidirectional)
      SpiBidirectional_Input    = SPI_C2_SPC0(1)|SPI_C2_BIDIROE(0),  ///< Input
      SpiBidirectional_Output   = SPI_C2_SPC0(1)|SPI_C2_BIDIROE(1),  ///< Output
   };

   /**
    * Baud rate prescale divisor
    * (spi_br_sppr)
    *
    * Selects prescaler for SPI baud clock.
    * The input to the prescaler is the bus clock
    */
   enum SpiBrSppr {
      SpiBrSppr_DivideBy1   = SPI_BR_SPPR(0),  ///< Divide by 1
      SpiBrSppr_DivideBy2   = SPI_BR_SPPR(1),  ///< Divide by 2
      SpiBrSppr_DivideBy3   = SPI_BR_SPPR(2),  ///< Divide by 3
      SpiBrSppr_DivideBy4   = SPI_BR_SPPR(3),  ///< Divide by 4
      SpiBrSppr_DivideBy5   = SPI_BR_SPPR(4),  ///< Divide by 5
      SpiBrSppr_DivideBy6   = SPI_BR_SPPR(5),  ///< Divide by 6
      SpiBrSppr_DivideBy7   = SPI_BR_SPPR(6),  ///< Divide by 7
      SpiBrSppr_DivideBy8   = SPI_BR_SPPR(7),  ///< Divide by 8
   };

   /**
    * Baud rate divisor select
    * (spi_br_spr)
    *
    * Selects one of nine divisors for the SPI baud rate divider.
    * The input to this divider comes from the SPI baud rate prescaler
    */
   enum SpiBrSpr {
      SpiBrSpr_DivideBy2     = SPI_BR_SPR(0),  ///< Divide by 2
      SpiBrSpr_DivideBy4     = SPI_BR_SPR(1),  ///< Divide by 4
      SpiBrSpr_DivideBy8     = SPI_BR_SPR(2),  ///< Divide by 8
      SpiBrSpr_DivideBy16    = SPI_BR_SPR(3),  ///< Divide by 16
      SpiBrSpr_DivideBy32    = SPI_BR_SPR(4),  ///< Divide by 32
      SpiBrSpr_DivideBy64    = SPI_BR_SPR(5),  ///< Divide by 64
      SpiBrSpr_DivideBy128   = SPI_BR_SPR(6),  ///< Divide by 128
      SpiBrSpr_DivideBy256   = SPI_BR_SPR(7),  ///< Divide by 256
      SpiBrSpr_DivideBy512   = SPI_BR_SPR(8),  ///< Divide by 512
   };

class SpiBasicInfo {

public:
}; // class SpiBasicInfo 

class Spi0Info : public SpiBasicInfo {

public:
   /*
    * Template:spi0_mke_8bit
    */
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = SPI0_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(irqNums[0]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[0], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(irqNums[0]);
   }
   
   /**
    *  Enable clock to Spi0
    */
   static void enableClock() {
      SIM->SCGC = SIM->SCGC | SIM_SCGC_SPI0_MASK;
   }
   
   /**
    *  Disable clock to Spi0
    */
   static void disableClock() {
      SIM->SCGC = SIM->SCGC & ~SIM_SCGC_SPI0_MASK;
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = SPI0_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<SPI_Type> spi = baseAddress;
   
   //! Peripheral instance number
   static constexpr unsigned instance = 0;
   
   //! Pin number in Info table for SCK if mapped to a pin
   static constexpr int sckPin  = 0;

   //! Pin number in Info table for SIN if mapped to a pin
   static constexpr int sinPin  = 1;

   //! Pin number in Info table for SOUT if mapped to a pin
   static constexpr int soutPin  = 2;

   static uint32_t getClockFrequency() {
      return SystemBusClock;
   }
   
}; // class Spi0Info



/**
 * Type definition for completion call back
 *
 * @param status E_NOERROR on success else error code
 */
typedef void (*SpiCallbackFunction)(ErrorCode status);

/**
 * Note on MODFEN/SSOE use
 *  SSOE  MODFEN     MASTER      SLAVE
 *   0     0         GPIO        SS-in
 *   0     1         FAULT-in    SS-in
 *   1     0         GPIO        SS-in
 *   1     1         SS-out      SS-in
 */

/**
 * Slave Select pin function in master mode
 */
enum SpiPinSelect {
   SpiPinSelect_Disabled    = SPI_C1_SSOE(0)|SPI_C2_MODFEN(0),  //!< SS pin acts as GPIO when Master
   SpiPinSelect_FaultIn     = SPI_C1_SSOE(0)|SPI_C2_MODFEN(1),  //!< SS pin acts as FAULT in when Master
   SpiPinSelect_SlaveSelect = SPI_C1_SSOE(1)|SPI_C2_MODFEN(1),  //!< SS pin acts as SlaveSelect when Master
};

/**
 * Controls operation in Low Power mode
 */
enum SpiLowPower {
   SpiLowPower_Disabled = SPI_C2_SPISWAI(0), //!< SPI disabled in Low Power mode
   SpiLowPower_Enabled  = SPI_C2_SPISWAI(1), //!< SPI enabled in Low Power mode
};

/**
 * @brief Base class for representing an SPI interface
 */
class Spi : public SpiBasicInfo {

protected:
   // Pointer to hardware
   const HardwarePtr<SPI_Type> spi;  //!< SPI hardware

   // Number of bytes remaining in current transaction
   volatile uint32_t bytesRemaining;

   // Receive buffer pointer
   uint8_t  *rxDataPtr;

   // Transmit buffer pointer
   const    uint8_t  *txDataPtr;

   /**
    * Constructor
    *
    * @param[in]  baseAddress    Base address of SPI
    */
   constexpr Spi(uint32_t baseAddress) :
      spi(baseAddress), bytesRemaining(0), rxDataPtr(nullptr), txDataPtr(nullptr) {
   }

   /**
    * Destructor
    */
   virtual ~Spi() {
   }

   /**
    * Get SPI input clock frequency
    *
    * @return Clock frequency in Hz
    */
   virtual uint32_t getClockFrequency() = 0;

   /**
    * Calculate communication BR value for SPI
    *
    * @param[in]  clockFrequency => Clock frequency of SPI in Hz
    * @param[in]  frequency      => Communication frequency in Hz
    *
    * @return BR register value
    *
    * Note: Chooses the highest speed that is not greater than frequency.
    */
   static uint8_t calculateBr(uint32_t clockFrequency, uint32_t frequency);

   /**
    * Calculates speed from SPI clock frequency and SPI clock factors
    *
    * @param[in] clockFrequency   SPI input clock frequency
    * @param[in] clockFactors     SPI clock factors
    *
    * @return SPI frequency
    */
   static uint32_t calculateSpeed(uint32_t clockFrequency, uint32_t clockFactors);

#if defined(__CMSIS_RTOS)
   /**
    * Obtain SPI mutex
    *
    * @param[in]  milliseconds   How long to wait in milliseconds. Use osWaitForever for indefinite wait
    *
    * @return osOK: The mutex has been obtain.
    * @return osErrorTimeoutResource: The mutex could not be obtained in the given time.
    * @return osErrorResource: The mutex could not be obtained when no timeout was specified.
    * @return osErrorParameter: The parameter mutex_id is incorrect.
    * @return osErrorISR: osMutexWait cannot be called from interrupt service routines.
    */
   virtual osStatus getMutex(int milliseconds=osWaitForever) = 0;

   /**
    * Release SPI mutex
    *
    * @return osOK: the mutex has been correctly released.
    * @return osErrorResource: the mutex was not obtained before.
    * @return osErrorISR: osMutexRelease cannot be called from interrupt service routines.
    */
   virtual osStatus releaseMutex() = 0;
#endif

   /**
    * Send 1st byte in a transmission
    */
   void sendFirstByte() {
      // Dummy status read
      (void)spi->S;
      if (bytesRemaining>0) {
         // Transmit byte
         if (txDataPtr != nullptr) {
            spi->D = *txDataPtr++;
         }
         else {
            // Dummy byte
            spi->D = 0xFF;
         }
      }
   }

   /**
    * Stop transmission
    */
   void stopTransaction() {
      spi->C1 = spi->C1 & ~SPI_C1_SPIE_MASK;
      rxDataPtr = nullptr;
      txDataPtr = nullptr;
   }

   /**
    * Poll device
    */
   ErrorCode poll() {
      if (spi->S&SPI_S_SPMF_MASK) {
         // Match event
         spi->S = spi->S | SPI_S_SPMF_MASK;
         return E_MATCH;
      }
      if (spi->S&SPI_S_MODF_MASK) {
         // Lost arbitration
         stopTransaction();
         return E_LOST_ARBITRATION;
      }
      if (spi->S&SPI_S_SPRF_MASK) {
         // Receive byte
         if (rxDataPtr != nullptr) {
            // Save data
            *rxDataPtr++ = spi->D;
         }
         else {
            // Discard data
            (void)spi->D;
         }
         bytesRemaining = bytesRemaining-1;
         if (bytesRemaining>0) {
            // Transmit byte
            if (txDataPtr != nullptr) {
               // Send data
               spi->D = *txDataPtr++;
            }
            else {
               // Send dummy byte
               spi->D = 0xFF;
            }
         }
         else {
            // Completed OK
            stopTransaction();
            return E_NO_ERROR;
         }
      }
      return E_BUSY;
   }
   

public:


#if defined(__CMSIS_RTOS)
   /**
    * Obtain SPI mutex and set SPI configuration
    *
    * @param[in]  configuration  The configuration to set for the transaction
    * @param[in]  milliseconds   How long to wait in milliseconds. Use osWaitForever for indefinite wait
    *
    * @return osOK: The mutex has been obtain.
    * @return osErrorTimeoutResource: The mutex could not be obtained in the given time.
    * @return osErrorResource: The mutex could not be obtained when no timeout was specified.
    * @return osErrorParameter: The parameter mutex_id is incorrect.
    * @return osErrorISR: osMutexWait cannot be called from interrupt service routines.
    */
   osStatus startTransaction(SpiBasicInfo::Init &configuration, int milliseconds=osWaitForever) {
      // Obtain mutex
      osStatus status = getMutex(milliseconds);
      if (status == osOK) {
         // Change configuration for this transaction
         setConfiguration(configuration);
      }
      return status;
   }

   /**
    * Obtain SPI mutex (SPI configuration unchanged)
    *
    * @param[in]  milliseconds How long to wait in milliseconds. Use osWaitForever for indefinite wait
    *
    * @return osOK: The mutex has been obtain.
    * @return osErrorTimeoutResource: The mutex could not be obtained in the given time.
    * @return osErrorResource: The mutex could not be obtained when no timeout was specified.
    * @return osErrorParameter: The parameter mutex_id is incorrect.
    * @return osErrorISR: osMutexWait cannot be called from interrupt service routines.
    */
   osStatus startTransaction(int milliseconds=osWaitForever) {
      // Obtain mutex
      return getMutex(milliseconds);
   }

   /**
    * Release SPI mutex
    *
    * @return osOK: the mutex has been correctly released.
    * @return osErrorResource: the mutex was not obtained before.
    * @return osErrorISR: osMutexRelease cannot be called from interrupt service routines.
    */
   osStatus endTransaction() {
      // Release mutex
      return releaseMutex();
   }
#else
   /**
    * Obtain SPI and set SPI configuration
    *
    * @param[in] configuration The configuration values to set for the transaction.
    */
   int startTransaction(SpiBasicInfo::Init &configuration, int =0) {
      setConfiguration(configuration);
      return 0;
   }
   /**
    * Obtain SPI
    */
   int startTransaction(int =0) {
      return 0;
   }
   /**
    * Release SPI - dummy routine (non RTOS)
    */
   int endTransaction() {
      return 0;
   }
#endif

   /**
    * Sets Communication speed for SPI
    *
    * @param[in]  frequency      => Communication frequency in Hz
    *
    * Note: Chooses the highest speed that is not greater than frequency.
    */
   void setSpeed(int frequency) {
      spi->BR = calculateBr(getClockFrequency(), frequency);
   }
   
#if false // /PCR/_present   
   /**
    * Enable pins used by SPI
    */
   virtual void enablePins(bool enable=true) = 0;
#endif // /PCR/_present

   /**
    * Sets Communication speed for SPI
    *
    * @param[in]  frequency      => Communication frequency in Hz
    *
    * Note: Chooses the highest speed that is not greater than frequency.
    */
   void setSpeed(Hertz frequency) {
      spi->BR = calculateBr(getClockFrequency(), uint32_t(frequency));
   }

   /**
    * Get communication speed of SPI
    *
    * @return Frequency in Hz
    */
   uint32_t getSpeed() {
      return calculateSpeed(getClockFrequency(), spi->BR);
   }

   /**
    *  Set Configuration\n
    *  This is a lightweight version that only does timing settings, \n
    *  word length and transmit order.\n
    *  It does not enable clock or calculate baud factors from speed.
    *  Assumes the interface is already acquired through startTransaction
    *
    *  @note The SPI is left disabled.
    *
    * @param[in]  configuration Configuration value
    */
   void setConfiguration(const SpiBasicInfo::Init &configuration) {
      spi->C1  = configuration.c1|SPI_C1_SPE_MASK;
      spi->C2  = configuration.c2;
      spi->BR  = configuration.br;
   }

   /**
    *  Get SPI configuration\n
    *  This includes timing settings, word length and transmit order
    *
    * @return Configuration value
    *
    * @note Typically used with startTransaction()
    */
   SpiBasicInfo::Init getConfiguration() {
      return SpiBasicInfo::Init(spi->C1, spi->C2, spi->BR);
   }

   /**
    *  Set SS Pin function
    *
    *  @param spiPinSelect Slave Select pin function in master mode
    */
   void setSlaveSelect(SpiPinSelect spiPinSelect) {
      spi->C1 = (spi->C1&~SPI_C1_SSOE_MASK)  |(spiPinSelect&SPI_C1_SSOE_MASK);
      spi->C2 = (spi->C2&~SPI_C2_MODFEN_MASK)|(spiPinSelect&SPI_C2_MODFEN_MASK);
   }

   /**
    * Controls operation in Low Power mode
    *
    * @param spiLowPower Options for low power mode
    */
   void setLowPowerMode(SpiLowPower spiLowPower) {
      spi->C2 = (spi->C2&~SPI_C2_SPISWAI_MASK)|(spiLowPower&SPI_C2_SPISWAI_MASK);
   }

   /**
    * Gets and clears status flags.
    *
    * @return status valkue (SPI->SR)
    */
   uint32_t getStatus() {
      // Capture interrupt status
      uint32_t status = spi->S;
      // Clear captured flags
      spi->S = status;
      // Return status
      return status;
   }

   /**
    *  Transmit and receive a series of bytes
    *
    *  @param[in]  dataSize  Number of values to transfer
    *  @param[in]  txData    Transmit bytes (may be nullptr for Receive only)
    *  @param[out] rxData    Receive byte buffer (may be nullptr for Transmit only)
    *
    *  @note: rxData may use same buffer as txData
    *  @note: Size of txData and rxData should be appropriate for transmission size.
    *
    *  @return E_NO_ERROR Transaction initiated or completed without error
    */
   ErrorCode txRx(uint32_t dataSize, const uint8_t *txData, uint8_t *rxData=nullptr) {
//      assert((txData != nullptr)||(rxData != nullptr));
      ErrorCode rc = E_NO_ERROR;

      bytesRemaining = dataSize;
      txDataPtr      = txData;
      rxDataPtr      = rxData;
      if constexpr (SpiBasicInfo::irqHandlerInstalled) {
         spi->C1 = spi->C1 | SPI_C1_SPE_MASK | SPI_C1_SPIE_MASK;
      }
      else {
         spi->C1 = spi->C1 | SPI_C1_SPE_MASK;
      }
      sendFirstByte();
      if (!SpiBasicInfo::irqHandlerInstalled) {
         // If not using interrupts then wait for completion
         do {
            rc = poll();
         } while (rc == E_BUSY);
      }
      return rc;
   }

   /**
    *  Transmit and receive a series of bytes
    *
    *  @tparam N   Number of values to transfer
    *  @param[in]  txData    Transmit bytes
    *  @param[out] rxData    Receive byte buffer
    *
    *  @return E_NO_ERROR Transaction initiated or completed without error
    */
   template<unsigned N>
   __attribute__((always_inline))  ErrorCode txRx(uint8_t (&txData)[N], uint8_t (&rxData)[N]) {
      return txRx(N, txData, rxData);
   }

   /**
    *  Transmit a series of bytes
    *
    *  @tparam N   Number of values to transfer
    *  @param[in]  txData    Transmit bytes
    *
    *  @return E_NO_ERROR Transaction initiated or completed without error
    */
   template<unsigned N>
   __attribute__((always_inline))  ErrorCode transmit(uint8_t (&txData)[N]) {
      return txRx(N, txData, nullptr);
   }

   /**
    *  Receive a series of bytes
    *
    *  @tparam N   Number of values to transfer
    *  @param[out] rxData    Receive byte buffer
    *
    *  @return E_NO_ERROR Transaction initiated or completed without error
    */
   template<unsigned N>
   __attribute__((always_inline)) ErrorCode receive(uint8_t (&rxData)[N]) {
      return txRx(N, nullptr, rxData);
   }

   /**
    * Transmit and receive a value over SPI
    *
    * @param[in] data - Data to send (8/16 bits)
    *
    * @return Data received
    */
   uint32_t txRx(uint32_t data) {
      while ((spi->S & SPI_S_SPTEF_MASK)==0) {
         __asm__("nop");
      }
      spi->D  = data;
      while ((spi->S & SPI_S_SPRF_MASK)==0) {
         __asm__("nop");
      }
      return spi->D; // Return read data
   }

};

/**
 * @brief Template class representing a SPI interface
 *
 * @tparam  Info  Class describing SPI hardware
 */
template<class Info>
class SpiBase_T : public Spi, public Info {

private:
   SpiBase_T() = delete;

   static SpiBase_T<Info> *thisPtr;

#ifdef __CMSIS_RTOS
   static CMSIS::Mutex mutex;
#endif

public:

   // Disambiguate Init
   using Init = Spi::Init;

   /**
    * IRQ handler
    */
   static void irqHandler() {
      thisPtr->_irqHandler();
   }

#ifdef __CMSIS_RTOS
protected:
   /**
    * Obtain SPI mutex
    *
    * @param[in]  milliseconds   How long to wait in milliseconds. Use osWaitForever for indefinite wait
    *
    * @return osOK: The mutex has been obtain.
    * @return osErrorTimeoutResource: The mutex could not be obtained in the given time.
    * @return osErrorResource: The mutex could not be obtained when no timeout was specified.
    * @return osErrorParameter: The parameter mutex_id is incorrect.
    * @return osErrorISR: osMutexWait cannot be called from interrupt service routines.
    */
   virtual osStatus getMutex(int milliseconds=osWaitForever) override {
      return mutex.wait(milliseconds);
   }

   /**
    * Release SPI mutex
    *
    * @return osOK: the mutex has been correctly released.
    * @return osErrorResource: the mutex was not obtained before.
    * @return osErrorISR: osMutexRelease cannot be called from interrupt service routines.
    */
   virtual osStatus releaseMutex() override {
      return mutex.release();
   }
#endif

   /**
    * Get SPI input clock frequency
    *
    * @return Clock frequency in Hz
    */
   uint32_t getClockFrequency() override {
      return Info::getClockFrequency();
   }

public:
#if 0
   /** SPI SCK (clock) Pin */
   using sckGpio  = GpioTable_T<Info, 0, ActiveHigh>;

   /** SPI SIN (data in = usually MISO) Pin */
   using sinGpio  = GpioTable_T<Info, 1, ActiveHigh>;

   /** SPI SOUT (data out = usually MOSI) Pin */
   using soutGpio = GpioTable_T<Info, 2, ActiveHigh>;
#endif

   /**
    * Configures all mapped pins associated with this peripheral
    */
   static void __attribute__((always_inline)) configureAllPins() {
      // Configure pins
      Info::initPCRs();
   }


#if false // /PCR/_present   
   /**
    * Map/Unmap pins for peripheral
    *
    * @param enable
    */
   virtual void enablePins(bool enable) override {
      if (enable) {
         // Configure pins
         Info::initPCRs();
      }
      else {
         // Configure SPI pins to mux=0
         Info::clearPCRs();
      }
   }
#endif // /PCR/_present   

   /**
    * Constructor
    */
   SpiBase_T(const SpiBasicInfo::Init &init) : Spi(Info::baseAddress) {

#if false // /PCR/_present   
#ifdef DEBUG_BUILD
      // Check pin assignments
      static_assert(Info::info[0].pinIndex != PinIndex::UNMAPPED_PCR, "SPIx_SCK has not been assigned to a pin - change in Configure.usbdmProject");
      static_assert(Info::info[1].pinIndex != PinIndex::UNMAPPED_PCR, "SPIx_SIN has not been assigned to a pin - change in Configure.usbdmProject");
      static_assert(Info::info[2].pinIndex != PinIndex::UNMAPPED_PCR, "SPIx_SOUT has not been assigned to a pin - change in Configure.usbdmProject");
#endif

      if (Info::mapPinsOnEnable) {
         configureAllPins();
      }
#endif // /PCR/_present   

      // Record this pointer for IRQ handler
      thisPtr = this;

      // Configure from supplied settings
      configure(init);
   }

   /**
    * Destructor
    */
   ~SpiBase_T() override {
   }

};

template<class Info> SpiBase_T<Info> *SpiBase_T<Info>::thisPtr = nullptr;
#ifdef __CMSIS_RTOS
template<class Info> CMSIS::Mutex     SpiBase_T<Info>::mutex;
#endif


/**
 * End SPI_Group
 * @}
 */

} // End namespace USBDM

#endif // /SPI/_BasicInfoGuard

#endif /* INCLUDE_USBDM_SPI_H_ */
