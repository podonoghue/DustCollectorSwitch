/**
 * @file     uart.h (180.ARM_Peripherals/Project_Headers/uart-MKE.h)
 * @brief    Universal Asynchronous Receiver/Transmitter interface
 */

#ifndef INCLUDE_USBDM_UART_H_
#define INCLUDE_USBDM_UART_H_

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "derivative.h"
#include "pin_mapping.h"
#include "formatted_io.h"
#include "uart_queue.h"

// No handler defined for UART0


namespace USBDM {

/**
 * @addtogroup UART_Group UART, Analogue Comparator
 * @brief Pins used for Analogue Comparator
 * @{
 */
/**
 * Peripheral information for UART, Universal Asynchronous Receiver/Transmitter.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Transmitter Enable
    * (uart_c2_te)
    *
    * Enables the UART transmitter.
    */
   enum UartTransmitterEnable : uint8_t {
      UartTransmitterEnable_Disabled   = UART_C2_TE(0),  ///< Transmitter disabled
      UartTransmitterEnable_Enabled    = UART_C2_TE(1),  ///< Transmitter enabled
   };

   /**
    * Receiver Enable
    * (uart_c2_re)
    *
    * Enables the UART receiver.
    */
   enum UartReceiverEnable : uint8_t {
      UartReceiverEnable_Disabled   = UART_C2_RE(0),  ///< Receiver disabled
      UartReceiverEnable_Enabled    = UART_C2_RE(1),  ///< Receiver enabled
   };

   /**
    * Baud Rate Modulo Divisor
    * (uart_bdh_sbr)
    *
    * The 13 bits in SBR[12:0] are referred to collectively as BR. They set the modulo divide rate for the
    * UART baud rate generator. When BR is cleared, the UART baud rate generator is disabled to reduce
    * supply current. When BR is 1 - 8191, the UART baud rate equals BUSCLK/(16xBR)
    */
   enum UartBaudRateModuloDivisor : uint8_t {
   };

   /**
    * Stop Bit Number Select
    * (uart_bdh_sbns)
    *
    * SBNS selects the number of stop bits present in a data frame
    */
   enum UartStopBits : uint8_t {
      UartStopBits_OneBit    = UART_BDH_SBNS(0),  ///< One stop bit
      UartStopBits_TwoBits   = UART_BDH_SBNS(1),  ///< Two stop bits
   };

   /**
    * LIN break detect action
    * (uart_bdh_lbkdie)
    *
    * Enables the LIN break detect flag, LBKDIF, to generate interrupt requests based on the state of LBKDDMAS.
    */
   enum UartLinBreakAction : uint8_t {
      UartLinBreakAction_None        = UART_BDH_LBKDIE(0),  ///< None
      UartLinBreakAction_Interrupt   = UART_BDH_LBKDIE(1),  ///< Interrupt
   };

   /**
    * RxD input active edge action
    * (uart_bdh_rxedgie)
    *
    * Enables the receive input active edge, RXEDGIF, to generate interrupt requests.
    */
   enum UartRxdActiveEdgeAction : uint8_t {
      UartRxdActiveEdgeAction_None        = UART_BDH_RXEDGIE(0),  ///< None
      UartRxdActiveEdgeAction_Interrupt   = UART_BDH_RXEDGIE(1),  ///< Interrupt
   };

   /**
    * Baud Rate Bits
    * (uart_bdl_sbr)
    *
    * The baud rate for the UART is determined by the 13 SBR fields. See Baud rate generation for details.
    */
   enum UartBaudRateBits : uint8_t {
   };

   /**
    * Loop Mode Select
    * (uart_c1_loops)
    *
    * Controls loop mode where transmitter output is internally connected to receiver input. [See also RSRC]
    */
   enum UartLoopModeSelect : uint8_t {
      UartLoopModeSelect_NormalOperation   = UART_C1_LOOPS(0),  ///< Normal operation
      UartLoopModeSelect_LoopMode          = UART_C1_LOOPS(1),  ///< Loop mode
   };

   /**
    * Stops in Wait Mode
    * (uart_c1_uartswai)
    *
    * Controls action in Wait Mode
    */
   enum UartStopsInWaitMode : uint8_t {
      UartStopsInWaitMode_EnableInWaitMode   = UART_C1_UARTSWAI(0),  ///< Enable in Wait mode
      UartStopsInWaitMode_FreezeInWaitMode   = UART_C1_UARTSWAI(1),  ///< Freeze in Wait mode
   };

   /**
    * Receiver Source Select
    * (uart_c1_rsrc)
    *
    * Select between loop-back and single-wire mode
    */
   enum UartReceiverSourceSelect : uint8_t {
      UartReceiverSourceSelect_InternalLoopBackMode   = UART_C1_RSRC(0),  ///< Internal loop back mode
      UartReceiverSourceSelect_SingleWireMode         = UART_C1_RSRC(1),  ///< Single-wire mode
   };

   /**
    * 9-Bit or 8-Bit Mode Select
    * (uart_c1_m)
    *
    * Selects between 8-bit and 9-bit modes
    * This field must be set when C7816[ISO_7816E] is set/enabled.
    */
   enum Uart9BitOr8BitModeSelect : uint8_t {
      Uart9BitOr8BitModeSelect_8Bit   = UART_C1_M(0),  ///< 8-bit
      Uart9BitOr8BitModeSelect_9Bit   = UART_C1_M(1),  ///< 9-bit
   };

   /**
    * Receiver Wakeup Method Select
    * (uart_c1_wake)
    *
    * Determines which condition wakes the UART:
    * - Address mark in the most significant bit position of a received data character, or
    * - An idle condition on the receive pin input signal.
    */
   enum UartReceiverWakeupMethodSelect : uint8_t {
      UartReceiverWakeupMethodSelect_IdleLineWakeup      = UART_C1_WAKE(0),  ///< Idle-line wakeup
      UartReceiverWakeupMethodSelect_AddressMarkWakeup   = UART_C1_WAKE(1),  ///< Address-mark wakeup
   };

   /**
    * Idle Line Type Select
    * (uart_c1_ilt)
    *
    * Determines if idle character bit count starts after start bit or stop bit
    */
   enum UartIdleLineTypeSelect : uint8_t {
      UartIdleLineTypeSelect_AfterStartBit   = UART_C1_ILT(0),  ///< After start bit
      UartIdleLineTypeSelect_AfterStopBit    = UART_C1_ILT(1),  ///< After stop bit
   };

   /**
    * Parity Enable
    * (uart_c1_pe)
    *
    * Enables the parity function. When parity is enabled, parity function inserts a parity bit
    * in the bit position immediately preceding the stop bit.
    * This field must be set when C7816[ISO_7816E] is set/enabled.
    */
   enum UartParityEnable : uint8_t {
      UartParityEnable_Disabled   = UART_C1_PE(0),  ///< Disabled
      UartParityEnable_Enabled    = UART_C1_PE(1),  ///< Enabled
   };

   /**
    * Parity Type
    * (uart_c1_pt)
    *
    * Determines whether the UART generates and checks for even parity or odd parity.
    * With even parity, an even number of 1s clears the parity bit and an odd number of
    * 1s sets the parity bit.
    * With odd parity, an odd number of 1s clears the parity bit and an even number of 1s
    * sets the parity bit. 
    * This field must be cleared when C7816[ISO_7816E] is set/enabled.
    */
   enum UartParityType : uint8_t {
      UartParityType_EvenParity   = UART_C1_PT(0),  ///< Even parity
      UartParityType_OddParity    = UART_C1_PT(1),  ///< Odd parity
   };

   /**
    * Transmit empty DMA/Interrupt action
    * (uart_c2_tie)
    *
    * Enable transmit holding register empty DMA/Interrupt action
    */
   enum UartTxEmptyAction : uint8_t {
      UartTxEmptyAction_None        = UART_C2_TIE(0),  ///< None
      UartTxEmptyAction_Interrupt   = UART_C2_TIE(1),  ///< Interrupt
   };

   /**
    * Transmit complete action
    * (uart_c2_tcie)
    *
    * Enable interrupt on transmission complete
    */
   enum UartTxCompleteAction : uint8_t {
      UartTxCompleteAction_None        = UART_C2_TCIE(0),  ///< None
      UartTxCompleteAction_Interrupt   = UART_C2_TCIE(1),  ///< Interrupt
   };

   /**
    * Receive full action
    * (uart_c2_rie)
    *
    * Enable receive buffer full interrupt action
    */
   enum UartRxFullAction : uint8_t {
      UartRxFullAction_None        = UART_C2_RIE(0),  ///< None
      UartRxFullAction_Interrupt   = UART_C2_RIE(1),  ///< Interrupt
   };

   /**
    * Idle line detect action
    * (uart_c2_ilie)
    *
    * Enable interrupt on tidele line detect
    */
   enum UartIdleLineDetectAction : uint8_t {
      UartIdleLineDetectAction_None        = UART_C2_ILIE(0),  ///< None
      UartIdleLineDetectAction_Interrupt   = UART_C2_ILIE(1),  ///< Interrupt
   };

   /**
    * Receiver Wakeup Control
    * (uart_c2_rwu)
    *
    * Setting RWU enables the wakeup function and inhibits further receiver interrupt requests.
    * Normally, hardware wakes the receiver by automatically clearing RWU
    */
   enum UartReceiverWakeupControl : uint8_t {
      UartReceiverWakeupControl_NormalOperation         = UART_C2_RWU(0),  ///< Normal operation
      UartReceiverWakeupControl_WakeupFunctionEnabled   = UART_C2_RWU(1),  ///< Wakeup function enabled
   };

   /**
    * Send Break
    * (uart_c2_sbk)
    *
    * Toggling SBK sends one break character. Toggling implies clearing the SBK field before
    * the break character has finished transmitting.
    * As long as SBK is set, the transmitter continues to send complete break characters.                Number of 
    * bits used:
    * - 10, 11, or 12 logic 0s if S2[BRK13] is cleared
    * - 13 or 14 logic 0s if S2[BRK13] is set.
    * This field must be cleared when C7816[ISO_7816E] is set.
    */
   enum UartSendBreak : uint8_t {
      UartSendBreak_NormalOperation       = UART_C2_SBK(0),  ///< Normal operation
      UartSendBreak_QueueBreakCharacter   = UART_C2_SBK(1),  ///< Queue break character
   };

   /**
    * Transmit Data Register Empty Flag
    * (uart_s1_tdre)
    *
    * Set when the number of words in the transmit buffer is &amp;lt;= TWFIFO[TXWATER]
    * To clear TDRE, read S1 when TDRE is set and then write to the data register
    */
   enum UartTransmitDataRegisterEmptyFlag : uint8_t {
      UartTransmitDataRegisterEmptyFlag_TxFifoLevelGtTxwater   = UART_S1_TDRE(0),  ///< Tx FIFO level > TXWATER
      UartTransmitDataRegisterEmptyFlag_TxFifoLevelLtTxwater   = UART_S1_TDRE(1),  ///< Tx FIFO level <= TXWATER
   };

   /**
    * Transmit Complete Flag
    * (uart_s1_tc)
    *
    * Set when the transmit buffer is empty and no data, preamble, or break character is being transmitted.
    * Cleared by reading S1 with TC set and then doing one of the following:
    * - Write to the data register to transmit new data
    * - Queue a preamble by changing TE from 0 to 1
    * - Queue a break character by writing 1 to C2.SBK
    */
   enum UartTransmitCompleteFlag : uint8_t {
      UartTransmitCompleteFlag_Active   = UART_S1_TC(0),  ///< Active
      UartTransmitCompleteFlag_Idle     = UART_S1_TC(1),  ///< Idle
   };

   /**
    * Receive Data Register Full Flag
    * (uart_s1_rdrf)
    *
    * RDRF is set when the number of datawords in the receive buffer is equal to or more than the number indicated by
    *  RWFIFO[RXWATER].
    * To clear RDRF, read S1 when RDRF is set and then read D
    */
   enum UartReceiveDataRegisterFullFlag : uint8_t {
      UartReceiveDataRegisterFullFlag_RxFifoLevelLtRxwater   = UART_S1_RDRF(0),  ///< Rx FIFO level < RXWATER
      UartReceiveDataRegisterFullFlag_RxFifoLevelGtRxwater   = UART_S1_RDRF(1),  ///< Rx FIFO level >= RXWATER
   };

   /**
    * Idle Line Flag
    * (uart_s1_idle)
    *
    * After the IDLE flag is cleared, a frame must be received or a LIN break character must set the S2[LBKDIF] flag 
    * before an idle condition can set the IDLE flag.
    * To clear IDLE, read S1 with IDLE set and then read D
    */
   enum UartIdleLineFlag : uint8_t {
      UartIdleLineFlag_NotDetected   = UART_S1_IDLE(0),  ///< Not detected
      UartIdleLineFlag_Detected      = UART_S1_IDLE(1),  ///< Detected
   };

   /**
    * Receiver Overrun Flag
    * (uart_s1_or)
    *
    * OR is set when software fails to prevent the receive data register from overflowing with data.
    * To clear OR, read S1 when OR is set and then read D
    */
   enum UartReceiverOverrunFlag : uint8_t {
      UartReceiverOverrunFlag_NoError   = UART_S1_OR(0),  ///< No error
      UartReceiverOverrunFlag_Error     = UART_S1_OR(1),  ///< Error
   };

   /**
    * Noise Flag
    * (uart_s1_nf)
    *
    * NF is set when the UART detects noise on the receiver input.
    * To clear NF, read S1 and then read D
    */
   enum UartNoiseFlag : uint8_t {
      UartNoiseFlag_NoError   = UART_S1_NF(0),  ///< No error
      UartNoiseFlag_Error     = UART_S1_NF(1),  ///< Error
   };

   /**
    * Framing Error Flag
    * (uart_s1_fe)
    *
    * FE is set when a logic 0 is accepted as the stop bit.
    * To clear FE, read S1 with FE set and then read D
    */
   enum UartFramingErrorFlag : uint8_t {
      UartFramingErrorFlag_NoError   = UART_S1_FE(0),  ///< No error
      UartFramingErrorFlag_Error     = UART_S1_FE(1),  ///< Error
   };

   /**
    * Parity Error Flag
    * (uart_s1_pf)
    *
    * PF is set when PE is set and the parity of the received data does not match its parity bit.
    * To clear PF, read S1 with PF set and then read D
    */
   enum UartParityErrorFlag : uint8_t {
      UartParityErrorFlag_NoError   = UART_S1_PF(0),  ///< No error
      UartParityErrorFlag_Error     = UART_S1_PF(1),  ///< Error
   };

   /**
    * Status Flags
    * (uart_s1_stat)
    *
    * These masks may be used to test or modify the status flags
    */
   enum class UartStatusFlag : uint32_t {
      ParityErrorFlag                 = (UART_S1_PF_MASK),    ///< Parity Error Flag
      FramingErrorFlag                = (UART_S1_FE_MASK),    ///< Framing Error Flag
      NoiseFlag                       = (UART_S1_NF_MASK),    ///< Noise Flag
      ReceiverOverrunFlag             = (UART_S1_OR_MASK),    ///< Receiver Overrun Flag
      IdleLineFlag                    = (UART_S1_IDLE_MASK),  ///< Idle Line Flag
      ReceiveDataRegisterFullFlag     = (UART_S1_RDRF_MASK),  ///< Receive Data Register Full Flag
      TransmitCompleteFlag            = (UART_S1_TC_MASK),    ///< Transmit Complete Flag
      TransmitDataRegisterEmptyFlag   = (UART_S1_TDRE_MASK),  ///< Transmit Data Register Empty Flag
      NoFlags                         = (0x0U),               ///< No flags
      AllFlags                        = (0xffU),              ///< All flags
   };


   /**
    * Combines two UartStatusFlag values (by ORing)
    * Used to create new UartStatusFlag mask
    * 
    * @param left    Left operand
    * @param right   Right operand
    * 
    * @return  Combined value
    */
   constexpr UartStatusFlag operator|(UartStatusFlag left, UartStatusFlag right) {
      return UartStatusFlag(long(left)|long(right));
   }
   
   /**
    * Combines two UartStatusFlag values (by ANDing) to produce a bool result
    * Used to check a value against a UartStatusFlag mask
    * 
    * @param left    Left operand
    * @param right   Right operand
    * 
    * @return boolean value indicating if the result is non-zero
    */
   constexpr bool operator&(UartStatusFlag left, UartStatusFlag right) {
      return bool(long(left)&long(right));
   }
   
   /**
    * LIN Break Detect Interrupt Flag
    * (uart_s2_lbkdif)
    *
    * LBKDIF is set when LBKDE is set and a LIN break character is detected on the receiver input.
    * LBKDIF is cleared by writing a 1 to it
    */
   enum UartLinBreakDetectInterruptFlag : uint8_t {
      UartLinBreakDetectInterruptFlag_NoInterrupt        = UART_S2_LBKDIF(0),  ///< No Interrupt
      UartLinBreakDetectInterruptFlag_InterruptPending   = UART_S2_LBKDIF(1),  ///< Interrupt pending
   };

   /**
    * RxD Pin Active Edge Interrupt Flag
    * (uart_s2_rxedgif)
    *
    * RXEDGIF is set when an active edge occurs on the RxD pin.
    * The active edge is falling if RXINV = 0, and rising if RXINV=1.
    * RXEDGIF is cleared by writing a 1 to it
    */
   enum UartRxdPinActiveEdgeInterruptFlag : uint8_t {
      UartRxdPinActiveEdgeInterruptFlag_NoInterrupt        = UART_S2_RXEDGIF(0),  ///< No interrupt
      UartRxdPinActiveEdgeInterruptFlag_InterruptPending   = UART_S2_RXEDGIF(1),  ///< Interrupt pending
   };

   /**
    * Receive Data Inversion
    * (uart_s2_rxinv)
    *
    * Setting this field reverses the polarity of the received data input
    */
   enum UartReceiveDataInversion : uint8_t {
      UartReceiveDataInversion_RxdNotInverted   = UART_S2_RXINV(0),  ///< RxD not inverted
      UartReceiveDataInversion_RxdInverted      = UART_S2_RXINV(1),  ///< RxD inverted
   };

   /**
    * Receive Wakeup Idle Detect
    * (uart_s2_rwuid)
    *
    * When RWU is set and WAKE is cleared, this field controls whether the idle character that wakes the             
    *  receiver sets S1[IDLE]
    */
   enum UartReceiveWakeupIdleDetect : uint8_t {
      UartReceiveWakeupIdleDetect_IdleCharsIgnored       = UART_S2_RWUID(0),  ///< Idle chars ignored
      UartReceiveWakeupIdleDetect_IdleDetectSetsS1Idle   = UART_S2_RWUID(1),  ///< Idle detect sets S1.IDLE
   };

   /**
    * Break Transmit Character Length
    * (uart_s2_brk13)
    *
    * Determines whether the transmit break character is 10, 11, or 12 bits long, or 13 or 14 bits long
    */
   enum UartBreakTransmitCharacterLength : uint8_t {
      UartBreakTransmitCharacterLength_Short   = UART_S2_BRK13(0),  ///< Short
      UartBreakTransmitCharacterLength_Long    = UART_S2_BRK13(1),  ///< Long
   };

   /**
    * LIN Break Detection Enable
    * (uart_s2_lbkde)
    *
    * Enables LIN break character detection.
    * While LBKDE is set, S1[RDRF], S1[NF], S1[FE], and S1[PF] are prevented from setting
    */
   enum UartLinBreakDetectionEnable : uint8_t {
      UartLinBreakDetectionEnable_Disabled   = UART_S2_LBKDE(0),  ///< Disabled
      UartLinBreakDetectionEnable_Enabled    = UART_S2_LBKDE(1),  ///< Enabled
   };

   /**
    * Receiver Active Flag
    * (uart_s2_raf)
    *
    * RAF is set when the UART receiver detects a logic 0 during the RT1 time period of the start bit search.
    * RAF is cleared when the receiver detects an idle character
    */
   enum UartReceiverActiveFlag : uint8_t {
      UartReceiverActiveFlag_ReceiverIdle     = UART_S2_RAF(0),  ///< Receiver idle
      UartReceiverActiveFlag_ReceiverActive   = UART_S2_RAF(1),  ///< Receiver active
   };

   /**
    * Received Bit 8
    * (uart_c3_r8)
    *
    * R8 is the ninth data bit received when the UART is configured for 9-bit data format,
    * that is, if C1[M] = 1 or C4[M10] = 1.
    */
   enum UartReceivedBit8 : uint8_t {
      UartReceivedBit8_0   = UART_C3_R8(0),  ///< Data 0
      UartReceivedBit8_1   = UART_C3_R8(1),  ///< Data 1
   };

   /**
    * Transmit Bit 8
    * (uart_c3_t8)
    *
    * T8 is the ninth data bit transmitted when the UART is configured for 9-bit data format,
    * that is, if C1[M] = 1 or C4[M10] = 1.
    * NOTE: If the value of T8 is the same as in the previous transmission, T8 does not
    * have to be rewritten. The same value is transmitted until T8 is rewritten.
    */
   enum UartTransmitBit8 : uint8_t {
      UartTransmitBit8_0   = UART_C3_T8(0),  ///< Data 0
      UartTransmitBit8_1   = UART_C3_T8(1),  ///< Data 1
   };

   /**
    * Transmitter Pin Direction in Single-Wire mode
    * (uart_c3_txdir)
    *
    * Determines whether the TXD pin is used as an input or output in the single-wire mode of operation.
    * This field is relevant only to the single wire mode. When C7816[ISO7816E] is set/enabled and
    * C7816[TTYPE] = 1, this field is automatically cleared after the requested block is transmitted.
    * This condition is detected when TL7816[TLEN] = 0 and 4 additional characters are transmitted.
    * Additionally, if C7816[ISO7816E] is set/enabled and C7816[TTYPE] = 0 and a NACK is being transmitted,
    * the hardware automatically overrides this field as needed. In this situation, TXDIR does not reflect
    * the temporary state associated with the NACK.
    */
   enum UartTransmitterPinDirectionInSingleWire : uint8_t {
      UartTransmitterPinDirectionInSingleWire_TxdPinIsInput    = UART_C3_TXDIR(0),  ///< TxD pin is input
      UartTransmitterPinDirectionInSingleWire_TxdPinIsOutput   = UART_C3_TXDIR(1),  ///< TxD pin is output
   };

   /**
    * Transmit Data Inversion
    * (uart_c3_txinv)
    *
    * Setting this field reverses the polarity of the transmitted data output.
    * In NRZ format, a one is represented by a mark and a zero is represented by a
    * space for normal polarity, and the opposite for inverted polarity.
    * In IrDA format, a zero is represented by short high pulse in the middle of a 
    * bit time remaining idle low for a one for normal polarity, and a zero is represented
    * by short low pulse in the middle of a bit time remaining idle high for a one for
    * inverted polarity.This field is automatically set when C7816[INIT] and C7816[ISO7816E]
    * are enabled and an initial character is detected in T = 0 protocol mode.
    * NOTE: Setting TXINV inverts all transmitted values, including idle, break, start, and stop bits.
    * In loop mode, if TXINV is set, the receiver gets the transmit inversion bit when RXINV is disabled.
    * When C7816[ISO7816E] is set/enabled then only the transmitted data bits and parity bit are inverted.
    */
   enum UartTransmitDataInversion : uint8_t {
      UartTransmitDataInversion_TxdNotInverted   = UART_C3_TXINV(0),  ///< TxD not inverted
      UartTransmitDataInversion_TxdInverted      = UART_C3_TXINV(1),  ///< TxD inverted
   };

   /**
    * Overrun Error Interrupt Enable
    * (uart_c3_orie)
    *
    * Enables the overrun error flag, S1[OR], to generate interrupt requests.
    */
   enum UartOverrunErrorInterruptEnable : uint8_t {
      UartOverrunErrorInterruptEnable_Disabled   = UART_C3_ORIE(0),  ///< Disabled
      UartOverrunErrorInterruptEnable_Enabled    = UART_C3_ORIE(1),  ///< Enabled
   };

   /**
    * Noise Error Interrupt Enable
    * (uart_c3_neie)
    *
    * Enables the noise flag, S1[NF], to generate interrupt requests.
    */
   enum UartNoiseErrorInterruptEnable : uint8_t {
      UartNoiseErrorInterruptEnable_Disabled   = UART_C3_NEIE(0),  ///< Disabled
      UartNoiseErrorInterruptEnable_Enabled    = UART_C3_NEIE(1),  ///< Enabled
   };

   /**
    * Framing Error Interrupt Enable
    * (uart_c3_feie)
    *
    * Enables the framing error flag, S1[FE], to generate interrupt requests.
    */
   enum UartFramingErrorInterruptEnable : uint8_t {
      UartFramingErrorInterruptEnable_Disabled   = UART_C3_FEIE(0),  ///< Disabled
      UartFramingErrorInterruptEnable_Enabled    = UART_C3_FEIE(1),  ///< Enabled
   };

   /**
    * Parity Error Interrupt Enable
    * (uart_c3_peie)
    *
    * Enables the parity error flag, S1[PF], to generate interrupt requests.
    */
   enum UartParityErrorInterruptEnable : uint8_t {
      UartParityErrorInterruptEnable_Disabled   = UART_C3_PEIE(0),  ///< Disabled
      UartParityErrorInterruptEnable_Enabled    = UART_C3_PEIE(1),  ///< Enabled
   };

class UartBasicInfo : public FormattedIO {

public:
   //! Common class based callback code has been generated for this class of peripheral
   // (_BasicInfoIrqGuard)
   static constexpr bool irqHandlerInstalled = false;
   
   // Pointer to UART hardware instance
   volatile UART_Type * const uart;
   
   /**
    * Constructor
    *
    * @param uart UART hardware instance
    */
   UartBasicInfo(volatile UART_Type * uart) : uart(uart) {
   }
   
   /**
    * Get input clock frequency
    * (Individual to each peripheral)
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   virtual uint32_t getInputClockFrequency() const = 0;
   
   
   /**
    * Flush output i.e. wait while UART busy with Tx
    */
   virtual USBDM::FormattedIO& flushOutput() override {
   
      // Wait for Tx idle
      while ((uart->S1 & UART_S1_TC_MASK) == 0) {
         __asm__("nop");
      }
   
      return *this;
   }
   
   /**
    * Check if character is available
    *
    * @return true  Character available i.e. _readChar() will not block
    * @return false No character available
    */
   virtual bool _isCharAvailable() override {
      return (uart->S1 & UART_S1_RDRF_MASK);
   }
   
   /**
    * Receives a single character (blocking)
    *
    * @return Character received
    */
   virtual int _readChar() override {
   
      // Get status from UART
      uint32_t status;
      constexpr uint32_t ErrorFlags = UART_S1_FE_MASK|UART_S1_OR_MASK|UART_S1_PF_MASK|UART_S1_NF_MASK;
      do {
         // Get status from UART
         status = uart->S1;
         // Clear & ignore pending errors
         if ((status & (ErrorFlags)) != 0) {
            uart->S1 = uart->S1|ErrorFlags;
         }
         // Check for Rx buffer full
      } while ((status & UART_S1_RDRF_MASK) == 0);
      return uint8_t(uart->D);
   }
   
   /**
    * Writes a character (blocking)
    *
    * @param[in]  ch - character to send
    */
   virtual void _writeChar(char ch) override {
      while ((uart->S1 & UART_S1_TDRE_MASK) == 0) {
         // Wait for Tx buffer empty
         __asm__("nop");
      }
      uart->D = ch;
      if (ch=='\n') {
         _writeChar('\r');
      }
   }
   
   /**
    * Set Transmit complete action
    *
    * @param uartTxCompleteAction Enable interrupt on transmission complete
    */
   void setTransmitCompleteAction(UartTxCompleteAction uartTxCompleteAction) const {
      uart->C2 = (uart->C2 & ~UART_C2_TCIE_MASK) | uartTxCompleteAction;
   }

   /**
    * Set Idle line detect action
    *
    * @param uartIdleLineDetectAction Enable interrupt on tidele line detect
    */
   void setIdleLineDetectAction(UartIdleLineDetectAction uartIdleLineDetectAction) const {
      uart->C2 = (uart->C2 & ~UART_C2_ILIE_MASK) | uartIdleLineDetectAction;
   }

   /**
    * Set Transmit empty DMA/Interrupt action
    *
    * @param uartTxEmptyAction Enable transmit holding register empty DMA/Interrupt action
    */
   void setTransmitEmptyAction(UartTxEmptyAction uartTxEmptyAction) const {
      uart->C2 = (uart->C2 & ~UART_C2_TIE_MASK)   | uartTxEmptyAction; 
   }

   /**
    * Set Receive full action
    *
    * @param uartRxFullAction Enable receive buffer full interrupt action
    */
   void setReceiveFullAction(UartRxFullAction uartRxFullAction) const {
      uart->C2 = (uart->C2 & ~UART_C2_RIE_MASK)   | uartRxFullAction;
   }

   /**
    * Clear UART status 

    * This includes:
    * - Idle detect flag
    * - Overrun flag
    * - Noise flag
    * - Framing error flag
    * - Parity error flag
    */
    void clearError() const {
   
      // Flags are cleared by reading status and then data
      (void)uart->S1;
      (void)uart->D;
   }
   
   /**
    * Set baud rate
    * (uart_baudrate, !uart_c4_osr_present, !uart_c4_brfa_present)
    * (for UART with fixed /16 prescaler)
    *
    * @param uart           Hardware instance pointer
    * @param clockFrequency Clock frequency
    * @param uartBaudRate Baud rate for UART
    *        Values available will depend on peripheral clock frequency
    */
   static void setBaudRate(
         volatile UART_Type *uart,
         uint32_t      clockFrequency,
         UartBaudRate uartBaudRate) {
   
      // Disable UART before changing registers
      uint8_t c2Value = uart->C2;
      uart->C2 = 0;
   
      // Fixed over-sample ratio
      constexpr unsigned overSample=16;
   
      /*
       * Baudrate = ClockFrequency / (OverSample x Divider)
       * Divider  = ClockFrequency / (OverSample x Baudrate)
       */
      // Calculate UART divisor with rounding
      uint32_t divisor = (clockFrequency<<1)/(overSample * uartBaudRate);
      divisor = (divisor>>1)|(divisor&0b1);
   
      // Set Baud rate register
      uart->BDH = (uart->BDH&~UART_BDH_SBR_MASK) | UART_BDH_SBR((divisor>>8));
      uart->BDL = UART_BDL_SBR(divisor);
   
      // Restore UART settings
      uart->C2 = c2Value;
   }
   
   /**
    * Set baud rate
    *
    * @param uartBaudRate Baud rate for UART
    *        Values available will depend on peripheral clock frequency
    */
   void setBaudRate(UartBaudRate uartBaudRate) {
   
      setBaudRate(uart, getInputClockFrequency(), uartBaudRate);
   }
   
   /**
    * Clear Status Flags
    * This includes all flags
    * (uart_s1_stat)
    */
   void clearStatusFlags() const {
   
      // Flags are w1c
      uart->S1 = uart->S1|uint32_t(UartStatusFlag::AllFlags);
   }
   
   /**
    * Clear selected Status Flags
    * (uart_s1_stat)
    *
    * @param uartStatusFlag These masks may be used to test or modify the status flags
    */
   void clearStatusFlags(UartStatusFlag uartStatusFlag) const {
      // Flags are w1c
      uart->S1 = uart->S1|uint32_t(uartStatusFlag);
   }
   
   /**
    * Get Status Flags
    * (uart_s1_stat)
    *
    * @return These masks may be used to test or modify the status flags
    */
   UartStatusFlag getStatusFlags() const {
      return UartStatusFlag(uart->S1&uint32_t(UartStatusFlag::AllFlags));
   }
   
   /**
    * Class used to do initialisation of the Uart
    *
    * This class has a templated constructor that accepts various values.
    * Parameters available may vary with device - see Uart0::DefaultInitValue for relevant example.
    * Omitted parameters default to zero (disabled) or unchanged if initialiser is provided as last parameter.
    *
    * @note This constructor may be used to create a const instance in Flash
    *
    * Example:
    * @code
    * static const Uart0::Init uart0Init {
    *
    *   // Setup values
XXXXXXXXXXXXXXXXXXXXXX
    *
    *   // Optional base value to start with (must be last parameter)
    *   Uart0::DefaultInitValue   // Used as base value modified by above
    * };
    *
    * // Initialise Uart0 from values specified above
    * Uart0::configure(uart0Init)
    * @endcode
    */
   class Init {
   
   private:
      /**
       * Prevent implicit parameter conversions
       */
      template <typename... Types>
      constexpr Init(Types...) = delete;
   
   public:
      /**
       * Copy Constructor
       */
      constexpr Init(const Init &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr Init() = default;
   
      // UART baud rate (uart_baudrate)
      UartBaudRate baudrate = UartBaudRate(0);

      // LIN break detect action (uart_bdh_lbkdie)
      // RxD input active edge action (uart_bdh_rxedgie)
      // Stop Bit Number Select (uart_bdh_sbns)
      uint8_t bdh = 0;

      // Loop Mode Select (uart_c1_loops)
      // Stops in Wait Mode (uart_c1_uartswai)
      // Receiver Source Select (uart_c1_rsrc)
      // 9-Bit or 8-Bit Mode Select (uart_c1_m)
      // Receiver Wakeup Method Select (uart_c1_wake)
      // Idle Line Type Select (uart_c1_ilt)
      // Parity Enable (uart_c1_pe)
      // Parity Type (uart_c1_pt)
      uint8_t c1 = 0;

      // Transmit empty DMA/Interrupt action (uart_c2_tie)
      // Transmit complete action (uart_c2_tcie)
      // Receive full action (uart_c2_rie)
      // Idle line detect action (uart_c2_ilie)
      // Transmitter Enable (uart_c2_te)
      // Receiver Enable (uart_c2_re)
      // Receiver Wakeup Control (uart_c2_rwu)
      // Send Break (uart_c2_sbk)
      uint8_t c2 = 0;

      // LIN Break Detect Interrupt Flag (uart_s2_lbkdif)
      // RxD Pin Active Edge Interrupt Flag (uart_s2_rxedgif)
      // Receive Data Inversion (uart_s2_rxinv)
      // Receive Wakeup Idle Detect (uart_s2_rwuid)
      // Break Transmit Character Length (uart_s2_brk13)
      // LIN Break Detection Enable (uart_s2_lbkde)
      uint8_t s2 = 0;

      // Transmit Bit 8 (uart_c3_t8)
      // Transmitter Pin Direction in Single-Wire mode (uart_c3_txdir)
      // Transmit Data Inversion (uart_c3_txinv)
      // Overrun Error Interrupt Enable (uart_c3_orie)
      // Noise Error Interrupt Enable (uart_c3_neie)
      // Framing Error Interrupt Enable (uart_c3_feie)
      // Parity Error Interrupt Enable (uart_c3_peie)
      uint8_t c3 = 0;

      /**
       * Constructor for UART baud rate
       * (uart_baudrate)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartBaudRate Baud rate for UART
       *        Values available will depend on peripheral clock frequency
       */
      template <typename... Types>
      constexpr Init(UartBaudRate uartBaudRate, Types... rest) : Init(rest...) {
   
         baudrate = uartBaudRate;
      }
   
      /**
       * Constructor for LIN break detect action
       * (uart_bdh_lbkdie)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartLinBreakAction Enables the LIN break detect flag, LBKDIF, to generate interrupt requests based on the state of LBKDDMAS.
       */
      template <typename... Types>
      constexpr Init(UartLinBreakAction uartLinBreakAction, Types... rest) : Init(rest...) {
   
         bdh = (bdh&~UART_BDH_LBKDIE_MASK) | uartLinBreakAction;
      }
   
      /**
       * Constructor for RxD input active edge action
       * (uart_bdh_rxedgie)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartRxdActiveEdgeAction Enables the receive input active edge, RXEDGIF, to generate interrupt requests.
       */
      template <typename... Types>
      constexpr Init(UartRxdActiveEdgeAction uartRxdActiveEdgeAction, Types... rest) : Init(rest...) {
   
         bdh = (bdh&~UART_BDH_RXEDGIE_MASK) | uartRxdActiveEdgeAction;
      }
   
      /**
       * Constructor for Stop Bit Number Select
       * (uart_bdh_sbns)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartStopBits SBNS selects the number of stop bits present in a data frame
       */
      template <typename... Types>
      constexpr Init(UartStopBits uartStopBits, Types... rest) : Init(rest...) {
   
         bdh = (bdh&~UART_BDH_SBNS_MASK) | uartStopBits;
      }
   
      /**
       * Constructor for Loop Mode Select
       * (uart_c1_loops)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartLoopModeSelect Controls loop mode where transmitter output is internally connected to receiver input. [See also RSRC]
       */
      template <typename... Types>
      constexpr Init(UartLoopModeSelect uartLoopModeSelect, Types... rest) : Init(rest...) {
   
         c1 = (c1&~UART_C1_LOOPS_MASK) | uartLoopModeSelect;
      }
   
      /**
       * Constructor for Stops in Wait Mode
       * (uart_c1_uartswai)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartStopsInWaitMode Controls action in Wait Mode
       */
      template <typename... Types>
      constexpr Init(UartStopsInWaitMode uartStopsInWaitMode, Types... rest) : Init(rest...) {
   
         c1 = (c1&~UART_C1_UARTSWAI_MASK) | uartStopsInWaitMode;
      }
   
      /**
       * Constructor for Receiver Source Select
       * (uart_c1_rsrc)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartReceiverSourceSelect Select between loop-back and single-wire mode
       */
      template <typename... Types>
      constexpr Init(UartReceiverSourceSelect uartReceiverSourceSelect, Types... rest) : Init(rest...) {
   
         c1 = (c1&~UART_C1_RSRC_MASK) | uartReceiverSourceSelect;
      }
   
      /**
       * Constructor for 9-Bit or 8-Bit Mode Select
       * (uart_c1_m)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uart9BitOr8BitModeSelect Selects between 8-bit and 9-bit modes
       *        This field must be set when C7816[ISO_7816E] is set/enabled.
       */
      template <typename... Types>
      constexpr Init(Uart9BitOr8BitModeSelect uart9BitOr8BitModeSelect, Types... rest) : Init(rest...) {
   
         c1 = (c1&~UART_C1_M_MASK) | uart9BitOr8BitModeSelect;
      }
   
      /**
       * Constructor for Receiver Wakeup Method Select
       * (uart_c1_wake)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartReceiverWakeupMethodSelect Determines which condition wakes the UART:
       *        - Address mark in the most significant bit position of a received data character, or
       *        - An idle condition on the receive pin input signal.
       */
      template <typename... Types>
      constexpr Init(UartReceiverWakeupMethodSelect uartReceiverWakeupMethodSelect, Types... rest) : Init(rest...) {
   
         c1 = (c1&~UART_C1_WAKE_MASK) | uartReceiverWakeupMethodSelect;
      }
   
      /**
       * Constructor for Idle Line Type Select
       * (uart_c1_ilt)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartIdleLineTypeSelect Determines if idle character bit count starts after start bit or stop bit
       */
      template <typename... Types>
      constexpr Init(UartIdleLineTypeSelect uartIdleLineTypeSelect, Types... rest) : Init(rest...) {
   
         c1 = (c1&~UART_C1_ILT_MASK) | uartIdleLineTypeSelect;
      }
   
      /**
       * Constructor for Parity Enable
       * (uart_c1_pe)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartParityEnable Enables the parity function. When parity is enabled, parity function inserts a parity bit
       *        in the bit position immediately preceding the stop bit.
       *        This field must be set when C7816[ISO_7816E] is set/enabled.
       */
      template <typename... Types>
      constexpr Init(UartParityEnable uartParityEnable, Types... rest) : Init(rest...) {
   
         c1 = (c1&~UART_C1_PE_MASK) | uartParityEnable;
      }
   
      /**
       * Constructor for Parity Type
       * (uart_c1_pt)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartParityType Determines whether the UART generates and checks for even parity or odd parity.
       *        With even parity, an even number of 1s clears the parity bit and an odd number of
       *        1s sets the parity bit.
       *        With odd parity, an odd number of 1s clears the parity bit and an even number of 1s
       *        sets the parity bit. 
       *        This field must be cleared when C7816[ISO_7816E] is set/enabled.
       */
      template <typename... Types>
      constexpr Init(UartParityType uartParityType, Types... rest) : Init(rest...) {
   
         c1 = (c1&~UART_C1_PT_MASK) | uartParityType;
      }
   
      /**
       * Constructor for Transmit empty DMA/Interrupt action
       * (uart_c2_tie)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTxEmptyAction Enable transmit holding register empty DMA/Interrupt action
       */
      template <typename... Types>
      constexpr Init(UartTxEmptyAction uartTxEmptyAction, Types... rest) : Init(rest...) {
   
         c2 = (c2&~UART_C2_TIE_MASK) | uartTxEmptyAction;
      }
   
      /**
       * Constructor for Transmit complete action
       * (uart_c2_tcie)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTxCompleteAction Enable interrupt on transmission complete
       */
      template <typename... Types>
      constexpr Init(UartTxCompleteAction uartTxCompleteAction, Types... rest) : Init(rest...) {
   
         c2 = (c2&~UART_C2_TCIE_MASK) | uartTxCompleteAction;
      }
   
      /**
       * Constructor for Receive full action
       * (uart_c2_rie)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartRxFullAction Enable receive buffer full interrupt action
       */
      template <typename... Types>
      constexpr Init(UartRxFullAction uartRxFullAction, Types... rest) : Init(rest...) {
   
         c2 = (c2&~UART_C2_RIE_MASK) | uartRxFullAction;
      }
   
      /**
       * Constructor for Idle line detect action
       * (uart_c2_ilie)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartIdleLineDetectAction Enable interrupt on tidele line detect
       */
      template <typename... Types>
      constexpr Init(UartIdleLineDetectAction uartIdleLineDetectAction, Types... rest) : Init(rest...) {
   
         c2 = (c2&~UART_C2_ILIE_MASK) | uartIdleLineDetectAction;
      }
   
      /**
       * Constructor for Transmitter Enable
       * (uart_c2_te)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTransmitterEnable Enables the UART transmitter.
       */
      template <typename... Types>
      constexpr Init(UartTransmitterEnable uartTransmitterEnable, Types... rest) : Init(rest...) {
   
         c2 = (c2&~UART_C2_TE_MASK) | uartTransmitterEnable;
      }
   
      /**
       * Constructor for Receiver Enable
       * (uart_c2_re)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartReceiverEnable Enables the UART receiver.
       */
      template <typename... Types>
      constexpr Init(UartReceiverEnable uartReceiverEnable, Types... rest) : Init(rest...) {
   
         c2 = (c2&~UART_C2_RE_MASK) | uartReceiverEnable;
      }
   
      /**
       * Constructor for Receiver Wakeup Control
       * (uart_c2_rwu)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartReceiverWakeupControl Setting RWU enables the wakeup function and inhibits further receiver interrupt requests.
       *        Normally, hardware wakes the receiver by automatically clearing RWU
       */
      template <typename... Types>
      constexpr Init(UartReceiverWakeupControl uartReceiverWakeupControl, Types... rest) : Init(rest...) {
   
         c2 = (c2&~UART_C2_RWU_MASK) | uartReceiverWakeupControl;
      }
   
      /**
       * Constructor for Send Break
       * (uart_c2_sbk)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartSendBreak Toggling SBK sends one break character. Toggling implies clearing the SBK field before
       *        the break character has finished transmitting.
       *        As long as SBK is set, the transmitter continues to send complete break characters.                Number of 
       *        bits used:
       *        - 10, 11, or 12 logic 0s if S2[BRK13] is cleared
       *        - 13 or 14 logic 0s if S2[BRK13] is set.
       *        This field must be cleared when C7816[ISO_7816E] is set.
       */
      template <typename... Types>
      constexpr Init(UartSendBreak uartSendBreak, Types... rest) : Init(rest...) {
   
         c2 = (c2&~UART_C2_SBK_MASK) | uartSendBreak;
      }
   
      /**
       * Constructor for LIN Break Detect Interrupt Flag
       * (uart_s2_lbkdif)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartLinBreakDetectInterruptFlag LBKDIF is set when LBKDE is set and a LIN break character is detected on the receiver input.
       *        LBKDIF is cleared by writing a 1 to it
       */
      template <typename... Types>
      constexpr Init(UartLinBreakDetectInterruptFlag uartLinBreakDetectInterruptFlag, Types... rest) : Init(rest...) {
   
         s2 = (s2&~UART_S2_LBKDIF_MASK) | uartLinBreakDetectInterruptFlag;
      }
   
      /**
       * Constructor for RxD Pin Active Edge Interrupt Flag
       * (uart_s2_rxedgif)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartRxdPinActiveEdgeInterruptFlag RXEDGIF is set when an active edge occurs on the RxD pin.
       *        The active edge is falling if RXINV = 0, and rising if RXINV=1.
       *        RXEDGIF is cleared by writing a 1 to it
       */
      template <typename... Types>
      constexpr Init(UartRxdPinActiveEdgeInterruptFlag uartRxdPinActiveEdgeInterruptFlag, Types... rest) : Init(rest...) {
   
         s2 = (s2&~UART_S2_RXEDGIF_MASK) | uartRxdPinActiveEdgeInterruptFlag;
      }
   
      /**
       * Constructor for Receive Data Inversion
       * (uart_s2_rxinv)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartReceiveDataInversion Setting this field reverses the polarity of the received data input
       */
      template <typename... Types>
      constexpr Init(UartReceiveDataInversion uartReceiveDataInversion, Types... rest) : Init(rest...) {
   
         s2 = (s2&~UART_S2_RXINV_MASK) | uartReceiveDataInversion;
      }
   
      /**
       * Constructor for Receive Wakeup Idle Detect
       * (uart_s2_rwuid)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartReceiveWakeupIdleDetect When RWU is set and WAKE is cleared, this field controls whether the idle character that wakes the             
       *         receiver sets S1[IDLE]
       */
      template <typename... Types>
      constexpr Init(UartReceiveWakeupIdleDetect uartReceiveWakeupIdleDetect, Types... rest) : Init(rest...) {
   
         s2 = (s2&~UART_S2_RWUID_MASK) | uartReceiveWakeupIdleDetect;
      }
   
      /**
       * Constructor for Break Transmit Character Length
       * (uart_s2_brk13)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartBreakTransmitCharacterLength Determines whether the transmit break character is 10, 11, or 12 bits long, or 13 or 14 bits long
       */
      template <typename... Types>
      constexpr Init(UartBreakTransmitCharacterLength uartBreakTransmitCharacterLength, Types... rest) : Init(rest...) {
   
         s2 = (s2&~UART_S2_BRK13_MASK) | uartBreakTransmitCharacterLength;
      }
   
      /**
       * Constructor for LIN Break Detection Enable
       * (uart_s2_lbkde)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartLinBreakDetectionEnable Enables LIN break character detection.
       *        While LBKDE is set, S1[RDRF], S1[NF], S1[FE], and S1[PF] are prevented from setting
       */
      template <typename... Types>
      constexpr Init(UartLinBreakDetectionEnable uartLinBreakDetectionEnable, Types... rest) : Init(rest...) {
   
         s2 = (s2&~UART_S2_LBKDE_MASK) | uartLinBreakDetectionEnable;
      }
   
      /**
       * Constructor for Transmit Bit 8
       * (uart_c3_t8)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTransmitBit8 T8 is the ninth data bit transmitted when the UART is configured for 9-bit data format,
       *        that is, if C1[M] = 1 or C4[M10] = 1.
       *        NOTE: If the value of T8 is the same as in the previous transmission, T8 does not
       *        have to be rewritten. The same value is transmitted until T8 is rewritten.
       */
      template <typename... Types>
      constexpr Init(UartTransmitBit8 uartTransmitBit8, Types... rest) : Init(rest...) {
   
         c3 = (c3&~UART_C3_T8_MASK) | uartTransmitBit8;
      }
   
      /**
       * Constructor for Transmitter Pin Direction in Single-Wire mode
       * (uart_c3_txdir)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTransmitterPinDirectionInSingleWire Determines whether the TXD pin is used as an input or output in the single-wire mode of operation.
       *        This field is relevant only to the single wire mode. When C7816[ISO7816E] is set/enabled and
       *        C7816[TTYPE] = 1, this field is automatically cleared after the requested block is transmitted.
       *        This condition is detected when TL7816[TLEN] = 0 and 4 additional characters are transmitted.
       *        Additionally, if C7816[ISO7816E] is set/enabled and C7816[TTYPE] = 0 and a NACK is being transmitted,
       *        the hardware automatically overrides this field as needed. In this situation, TXDIR does not reflect
       *        the temporary state associated with the NACK.
       */
      template <typename... Types>
      constexpr Init(UartTransmitterPinDirectionInSingleWire uartTransmitterPinDirectionInSingleWire, Types... rest) : Init(rest...) {
   
         c3 = (c3&~UART_C3_TXDIR_MASK) | uartTransmitterPinDirectionInSingleWire;
      }
   
      /**
       * Constructor for Transmit Data Inversion
       * (uart_c3_txinv)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartTransmitDataInversion Setting this field reverses the polarity of the transmitted data output.
       *        In NRZ format, a one is represented by a mark and a zero is represented by a
       *        space for normal polarity, and the opposite for inverted polarity.
       *        In IrDA format, a zero is represented by short high pulse in the middle of a 
       *        bit time remaining idle low for a one for normal polarity, and a zero is represented
       *        by short low pulse in the middle of a bit time remaining idle high for a one for
       *        inverted polarity.This field is automatically set when C7816[INIT] and C7816[ISO7816E]
       *        are enabled and an initial character is detected in T = 0 protocol mode.
       *        NOTE: Setting TXINV inverts all transmitted values, including idle, break, start, and stop bits.
       *        In loop mode, if TXINV is set, the receiver gets the transmit inversion bit when RXINV is disabled.
       *        When C7816[ISO7816E] is set/enabled then only the transmitted data bits and parity bit are inverted.
       */
      template <typename... Types>
      constexpr Init(UartTransmitDataInversion uartTransmitDataInversion, Types... rest) : Init(rest...) {
   
         c3 = (c3&~UART_C3_TXINV_MASK) | uartTransmitDataInversion;
      }
   
      /**
       * Constructor for Overrun Error Interrupt Enable
       * (uart_c3_orie)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartOverrunErrorInterruptEnable Enables the overrun error flag, S1[OR], to generate interrupt requests.
       */
      template <typename... Types>
      constexpr Init(UartOverrunErrorInterruptEnable uartOverrunErrorInterruptEnable, Types... rest) : Init(rest...) {
   
         c3 = (c3&~UART_C3_ORIE_MASK) | uartOverrunErrorInterruptEnable;
      }
   
      /**
       * Constructor for Noise Error Interrupt Enable
       * (uart_c3_neie)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartNoiseErrorInterruptEnable Enables the noise flag, S1[NF], to generate interrupt requests.
       */
      template <typename... Types>
      constexpr Init(UartNoiseErrorInterruptEnable uartNoiseErrorInterruptEnable, Types... rest) : Init(rest...) {
   
         c3 = (c3&~UART_C3_NEIE_MASK) | uartNoiseErrorInterruptEnable;
      }
   
      /**
       * Constructor for Framing Error Interrupt Enable
       * (uart_c3_feie)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartFramingErrorInterruptEnable Enables the framing error flag, S1[FE], to generate interrupt requests.
       */
      template <typename... Types>
      constexpr Init(UartFramingErrorInterruptEnable uartFramingErrorInterruptEnable, Types... rest) : Init(rest...) {
   
         c3 = (c3&~UART_C3_FEIE_MASK) | uartFramingErrorInterruptEnable;
      }
   
      /**
       * Constructor for Parity Error Interrupt Enable
       * (uart_c3_peie)
       *
       * @tparam   Types
       * @param    rest
       *
       * @param uartParityErrorInterruptEnable Enables the parity error flag, S1[PF], to generate interrupt requests.
       */
      template <typename... Types>
      constexpr Init(UartParityErrorInterruptEnable uartParityErrorInterruptEnable, Types... rest) : Init(rest...) {
   
         c3 = (c3&~UART_C3_PEIE_MASK) | uartParityErrorInterruptEnable;
      }
   
   }; // class UartBasicInfo::Init
   
   /**
    * Configure UART from values specified in init
    * This routine does not configure pins or interrupt handlers
    *
    * @param uart            Hardware instance pointer
    * @param clockFrequency  Clock frequency
    * @param init            Class containing initialisation values
    */
   static void configure(
                  volatile UART_Type *uart,
                  uint32_t            clockFrequency,
                  const Init         &init) {
   
   
      // Transmitter Enable (uart_c2_te)
      // Receiver Enable (uart_c2_re)
      uart->C2 = 0;
   
      // LIN break detect action (uart_bdh_lbkdie)
      // RxD input active edge action (uart_bdh_rxedgie)
      // Stop Bit Number Select (uart_bdh_sbns)
      uart->BDH = init.bdh;
   
      // UART baud rate (uart_baudrate)
      setBaudRate(uart, clockFrequency, init.baudrate);
   
      // Loop Mode Select (uart_c1_loops)
      // Stops in Wait Mode (uart_c1_uartswai)
      // Receiver Source Select (uart_c1_rsrc)
      // 9-Bit or 8-Bit Mode Select (uart_c1_m)
      // Receiver Wakeup Method Select (uart_c1_wake)
      // Idle Line Type Select (uart_c1_ilt)
      // Parity Enable (uart_c1_pe)
      // Parity Type (uart_c1_pt)
      uart->C1 = init.c1;
   
      // LIN Break Detect Interrupt Flag (uart_s2_lbkdif)
      // RxD Pin Active Edge Interrupt Flag (uart_s2_rxedgif)
      // Receive Data Inversion (uart_s2_rxinv)
      // Receive Wakeup Idle Detect (uart_s2_rwuid)
      // Break Transmit Character Length (uart_s2_brk13)
      // LIN Break Detection Enable (uart_s2_lbkde)
      uart->S2 = init.s2;
   
      // Transmit Bit 8 (uart_c3_t8)
      // Transmitter Pin Direction in Single-Wire mode (uart_c3_txdir)
      // Transmit Data Inversion (uart_c3_txinv)
      // Overrun Error Interrupt Enable (uart_c3_orie)
      // Noise Error Interrupt Enable (uart_c3_neie)
      // Framing Error Interrupt Enable (uart_c3_feie)
      // Parity Error Interrupt Enable (uart_c3_peie)
      uart->C3 = init.c3;
   
      // Transmit empty DMA/Interrupt action (uart_c2_tie)
      // Transmit complete action (uart_c2_tcie)
      // Receive full action (uart_c2_rie)
      // Idle line detect action (uart_c2_ilie)
      // Transmitter Enable (uart_c2_te)
      // Receiver Enable (uart_c2_re)
      // Receiver Wakeup Control (uart_c2_rwu)
      // Send Break (uart_c2_sbk)
      uart->C2 = init.c2;
   }
   
   /**
    * Configure UART from values specified in init
    * This routine does not configure pins or interrupt handlers
    *
    * @param init Class containing initialisation values
    */
   void configure(const Init &init) const {
   
      configure(uart, getInputClockFrequency(), init);
   }
   
}; // class UartBasicInfo 

class Uart0Info : public UartBasicInfo {

public:
   /*
    * Template:uart0_mke
    */
   //! Class based interrupt code has been generated for this class of peripheral
   // (_BasicInfoIrqGuard)
   static constexpr bool irqHandlerInstalled = false;
   
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = UART0_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(irqNums[0]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[0], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(irqNums[0]);
   }
   
   /**
    *  Enable clock to Uart0
    */
   static void enableClock() {
      SIM->SCGC = SIM->SCGC | SIM_SCGC_UART0_MASK;
   }
   
   /**
    *  Disable clock to Uart0
    */
   static void disableClock() {
      SIM->SCGC = SIM->SCGC & ~SIM_SCGC_UART0_MASK;
   }
   
   /**
    * Basic enable of Uart0
    * Includes enabling clock and configuring all mapped pins if mapPinsOnEnable is selected in configuration
    */
   static void enable() {
      enableClock();
   }
   
   /**
    * Disables Uart0
    */
   static void disable() {
   
      
      disableNvicInterrupts();
      disableClock();
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = UART0_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<UART_Type> uart = baseAddress;
   
   //! Peripheral instance number
   static constexpr unsigned instance = 0;
   
   /**
    * Get input clock frequency
    * (Individual to each peripheral)
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   virtual uint32_t getInputClockFrequency() const override {
      return SimInfo::getUart0Clock();
   }
   
   /*
    *   Default Constructor
    */
   Uart0Info() : UartBasicInfo(uart) {
      defaultConfigure();
   }
   
   /*
    *   Constructor
    */
   Uart0Info(const Init &init) : UartBasicInfo(uart) {
      configure(init);
   }
   
   /**
    * Set baud rate
    *
    * @param uartBaudRate Baud rate for UART
    *        Values available will depend on peripheral clock frequency
    */
   void setBaudRate(UartBaudRate uartBaudRate) {
   
      UartBasicInfo::setBaudRate(uart, getInputClockFrequency(), uartBaudRate);
   }
   
   /**
    * Configure with default settings.
    * Configuration determined from Configure.usbdmProject
    */
   void initialise() const {
   
      defaultConfigure();
   }
   
   /**
    * Configure with default settings.
    * Configuration determined from Configure.usbdmProject
    */
   static void defaultConfigure() {
   
      configure(DefaultInitValue);
   }
   
   /**
    * Configure UART from values specified in init
    *
    * @param init Class containing initialisation values
    */
   static void configure(const Init &init) {
   
      // Enable peripheral
      enable();
   
      UartBasicInfo::configure(uart, SimInfo::getUart0Clock(), init);
   }
   
   /**
    * Default initialisation value for Uart0
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr UartBasicInfo::Init DefaultInitValue = {
   
      UartBaudRate_115200 ,             // (uart_baudrate)            UART baud rate - 115200
      UartTransmitterEnable_Enabled ,   // (uart_c2_te)               Transmitter Enable - Transmitter enabled
      UartReceiverEnable_Enabled ,      // (uart_c2_re)               Receiver Enable - Receiver enabled
   };
   
}; // class Uart0Info


/**
 * @brief Template class representing an UART interface with buffered reception
 *
 * <b>Example</b>
 * @code
 *  // Instantiate interface
 *  UartBuffered_T<100, 100> bufferedUart{console};
 *
 *  for(int i=0; i++;) {
 *     bufferedUart.writeln("Tick... ", i);
 *  }
 *  @endcode
 *
 * @tparam Info   Class describing UART hardware
 */
template<typename T, int rxSize=100, int txSize=100>
class UartBuffered_T : public T {

private:
   UartBuffered_T(const UartBuffered_T&) = delete;
   UartBuffered_T(UartBuffered_T&&) = delete;

   static constexpr typename T::Init initValue = {
         UartBaudRate_115200,
         UartTxEmptyAction_Interrupt ,    // (uart_txempty_action)      Transmit empty DMA/Interrupt action - Interrupt
         UartRxFullAction_Interrupt ,     // (uart_rxfull_action)       Receive full DMA/interrupt action - Interrupt
#if false // /UART/uart_pfifo_txfe_present
         UartTransmitFifoEnable_Enabled ,  // (uart_pfifo_txfe)          Transmit FIFO Enable - Enabled
         UartReceiveFifoEnable_Enabled ,   // (uart_pfifo_rxfe)          Receive FIFO Enable - Enabled
#endif
   };

public:

   UartBuffered_T(const T &uart) : T(uart) {
      T::setCallback(T::IrqNum_RxTx,  T::wrapCallback(this, &USBDM::UartBuffered_T<T, rxSize, txSize>::callback));
      T::configure(initValue);
   }

   UartBuffered_T(const T &uart, typename T::Init init) : UartBasicInfo(uart) {
      T::setCallback(T::IrqNum_RxTx,  T::wrapCallback(this, &USBDM::UartBuffered_T<T, rxSize, txSize>::callback));
      T::configure(init);
   }

   virtual ~UartBuffered_T() {
      T::setTransmitCompleteAction(UartTxCompleteAction_None);
      T::setReceiveFullAction(UartRxFullAction_None);
   }

protected:
   /**
    * Queue for Buffered reception (if used)
    */
   static inline UartQueue<char, rxSize> rxQueue;
   /**
    * Queue for Buffered transmission (if used)
    */
   static inline UartQueue<char, txSize> txQueue;

   /**
    * Writes a character (blocking on transmit queue full)
    *
    * @param[in]  ch - character to send
    */
   virtual void _writeChar(char ch) override {
      T::lock();
      // Add character to buffer
      while (!txQueue.enQueueDiscardOnFull(ch)) {
         __asm__("nop");
      }
      T::setTransmitCompleteAction(UartTxCompleteAction_Interrupt);
      T::unlock();
      if (ch=='\n') {
        _writeChar('\r');
      }
   }

   /**
    * Receives a single character (blocking on receive queue empty)
    *
    * @return Character received
    */
   virtual int _readChar() override {
      T::lock();
      while (rxQueue.isEmpty()) {
         __asm__("nop");
      }
      char t = rxQueue.deQueue();
      T::unlock();
      return t;
   }

   /**
    * Check if character is available
    *
    * @return true  Character available i.e. _readChar() will not block
    * @return false No character available
    */
   virtual bool _isCharAvailable() override {
      return (!rxQueue.isEmpty());
   }

public:
   /**
    * Receive/Transmit/Error IRQ handler call-back
    */
   void callback()  {
      UartStatusFlag status = T::getStatusFlags();

      // Empty UART Rx FIFO
      while(status&UartStatusFlag::ReceiveDataRegisterFullFlag) {
         // Receive data register full - save data
         rxQueue.enQueueDiscardOnFull(T::getReceiveData());
         status = T::getStatusFlags();
      }
      // Fill UART Tx FIFO
      while(status&UartStatusFlag::TransmitDataRegisterEmptyFlag) {
         // Transmitter ready
         if (txQueue.isEmpty()) {
            // No data available - disable further transmit interrupts
            T::setTransmitCompleteAction(UartTxCompleteAction_None);
            break;
         }
         else {
            // Transmit next byte
            T::setTransmitData(txQueue.deQueue());
         }
         status = T::getStatusFlags();
      }
   }

   /**
    *  Flush output data.
    *  This blocks until all pending data has been sent
    */
   virtual UartBuffered_T &flushOutput() override {
      while (!txQueue.isEmpty()) {
         // Wait until queue empty
      }
      while ((T::uart->S1 & UART_S1_TC_MASK) == 0) {
         // Wait until transmission of last character is complete
      }
      return *this;
   }

   /**
    *  Flush input data
    */
   virtual UartBuffered_T &flushInput() override {
      rxQueue.clear();
      UartBasicInfo::flushInput();
      return *this;
   }

};
   /**
    * Class representing UART instance
    */
   typedef UartBasicInfo UartInstance;
   /**
    * Class representing UART0
    */
   typedef Uart0Info Uart0;
   

/**
 * End UART_Group
 * @}
 */
} // End namespace USBDM

#endif /* INCLUDE_USBDM_UART_H_ */
