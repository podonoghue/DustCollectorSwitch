/**
 * @file     mcm.h (180.ARM_Peripherals/Project_Headers/mcm.h)
 * @brief    Miscellaneous Control Module
 */

#ifndef HEADER_MCM_H
#define HEADER_MCM_H

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "pin_mapping.h"

// $/MCM/prototypes not found

namespace USBDM {

#if false // /MCM/_BasicInfoGuard

/**
 * @addtogroup MCM_Group MCM, Miscellaneous Control Module
 * @brief Abstraction for Miscellaneous Control Module
 * @{
 */
/**
 * Peripheral information for MCM, Miscellaneous Control Module.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Each bit in the ASC field indicates whether there is a corresponding connection to the crossbar switch&amp;apos;s slave input port
    * (mcm_plasc_asc)
    *
    * 
    */
   enum McmPlascAsc : uint16_t {
      McmPlascAsc_ABusSlaveConnectionToAxbsInputPortNIsAbsent    = MCM_PLASC_ASC(0),  ///< A bus slave connection to AXBS input port n is absent
      McmPlascAsc_ABusSlaveConnectionToAxbsInputPortNIsPresent   = MCM_PLASC_ASC(1),  ///< A bus slave connection to AXBS input port n is present
   };

   /**
    * Each bit in the AMC field indicates whether there is a corresponding connection to the AXBS master input port
    * (mcm_plamc_amc)
    *
    * 
    */
   enum McmPlamcAmc : uint16_t {
      McmPlamcAmc_ABusMasterConnectionToAxbsInputPortNIsAbsent    = MCM_PLAMC_AMC(0),  ///< A bus master connection to AXBS input port n is absent
      McmPlamcAmc_ABusMasterConnectionToAxbsInputPortNIsPresent   = MCM_PLAMC_AMC(1),  ///< A bus master connection to AXBS input port n is present
   };

   /**
    * Enable Stalling Flash Controller
    * (mcm_placr_esfc)
    *
    * Enables stalling flash controller when flash is busy 
    * When software needs to access the flash memory while a flash memory resource is being manipulated 
    * by a flash command, software can enable a stall mechanism to avoid a read collision.  
    * The stall mechanism allows software to execute code from the same block on which flash operations 
    * are being performed. 
    * However, software must ensure the sector the flash operations are being performed on is not 
    * the same sector from which the code is executing. 
    * This must be set only just before the flash operation is executed and cleared when the operation completes
    */
   enum McmStallFlashController : uint32_t {
      McmStallFlashController_Disabled   = MCM_PLACR_ESFC(0),  ///< Disabled
      McmStallFlashController_Enabled    = MCM_PLACR_ESFC(1),  ///< Enabled
   };

   /**
    * Flash Controller Speculation Buffer
    * (mcm_placr_flash_speculation)
    *
    * Controls the operation of the Flash Controller Speculation Buffer
    */
   enum McmFlashSpeculation {
      McmFlashSpeculation_InstructionsOnly      = MCM_PLACR_DFCS(0)|MCM_PLACR_EFDS(0),  ///< Instructions Only
      McmFlashSpeculation_InstructionsAndData   = MCM_PLACR_DFCS(0)|MCM_PLACR_EFDS(1),  ///< Instructions and Data
      McmFlashSpeculation_Disabled              = MCM_PLACR_DFCS(1)|MCM_PLACR_EFDS(0),  ///< Disabled
   };

   /**
    * Flash Controller Cache
    * (mcm_placr_flash_cache)
    *
    * Controls the operation of the Flash Controller Cache
    */
   enum McmFlashCache {
      McmFlashCache_InstructionsAndData   = MCM_PLACR_DFCC(0)|MCM_PLACR_DFCIC(0)|MCM_PLACR_DFCDA(0),  ///< Instructions and Data
      McmFlashCache_InstructionsOnly      = MCM_PLACR_DFCC(0)|MCM_PLACR_DFCIC(0)|MCM_PLACR_DFCDA(1),  ///< Instructions Only
      McmFlashCache_DataOnly              = MCM_PLACR_DFCC(0)|MCM_PLACR_DFCIC(1)|MCM_PLACR_DFCDA(0),  ///< Data Only
      McmFlashCache_Disabled              = MCM_PLACR_DFCC(1)|MCM_PLACR_DFCIC(0)|MCM_PLACR_DFCDA(0),  ///< Disabled
   };

   /**
    * Clear Flash Controller Cache
    * (mcm_placr_cfcc)
    *
    * Write to clear flash controller cache
    */
   enum McmFlashControllerCache {
      McmFlashControllerCache_Clear   = MCM_PLACR_CFCC(1),  ///< Clear
   };

class McmBasicInfo {

public:
   // May be empty
}; // class McmBasicInfo 

class McmInfo : public McmBasicInfo {

public:
   /*
    * Template:mcm_mke02z2
    */
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = MCM_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<MCM_Type> mcm = baseAddress;
   
   /**
    * Set Enable Stalling Flash Controller
    *
    * @param mcmStallFlashController Enables stalling flash controller when flash is busy 
    *        When software needs to access the flash memory while a flash memory resource is being manipulated 
    *        by a flash command, software can enable a stall mechanism to avoid a read collision.  
    *        The stall mechanism allows software to execute code from the same block on which flash operations 
    *        are being performed. 
    *        However, software must ensure the sector the flash operations are being performed on is not 
    *        the same sector from which the code is executing. 
    *        This must be set only just before the flash operation is executed and cleared when the operation completes
    */
   static void setStallFlashController(McmStallFlashController mcmStallFlashController) {

      mcm->PLACR = (mcm->PLACR&~(MCM_PLACR_ESFC_MASK)) | mcmStallFlashController;
   }

   /**
    * Configure Flash Controller
    *
    * @param mcmFlashSpeculation Controls the operation of the Flash Controller Speculation Buffer
    */
   static void setFlashControllerSpeculation(McmFlashSpeculation mcmFlashSpeculation) {

      mcm->PLACR = (mcm->PLACR&~(MCM_PLACR_DFCS_MASK|MCM_PLACR_EFDS_MASK))|mcmFlashSpeculation;
   }

   /**
    * Set Flash Controller Cache
    *
    * @param mcmFlashCache Controls the operation of the Flash Controller Cache
    */
   static void setFlashControllerCache(McmFlashCache mcmFlashCache) {

      mcm->PLACR = (mcm->PLACR&~(MCM_PLACR_DFCC_MASK|MCM_PLACR_DFCIC_MASK|MCM_PLACR_DFCDA_MASK)) | mcmFlashCache;
   }

   /**
    * Clear Flash Controller Cache
    * Write to clear flash controller cache
    */
   static void clearFlashControllerCache() {
   
      mcm->PLACR = mcm->PLACR | MCM_PLACR_CFCC_MASK;
   }

   /**
    * Configure Flash Controller
    *
    * @param mcmFlashSpeculation Controls the operation of the Flash Controller Speculation Buffer
    * @param mcmFlashCache       Controls the operation of the Flash Controller Cache
    */
   static void configureFlashController(

         McmFlashSpeculation mcmFlashSpeculation,
         McmFlashCache       mcmFlashCache) {

      mcm->PLACR = (mcm->PLACR&~(MCM_PLACR_DFCS_MASK|MCM_PLACR_EFDS_MASK|MCM_PLACR_DFCC_MASK|MCM_PLACR_DFCIC_MASK|MCM_PLACR_DFCDA_MASK))|
                   mcmFlashSpeculation|mcmFlashCache;
   }

   /**
    **
    * Class used to do initialisation of MCM flash control.
    * Options not explicitly mentioned are cleared to 0.
    *
    * This class has a templated constructor that accepts a range of options
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example1:
    * @code
    * const Mcm::FlashInit flashInit {
    *    // List of options
    *    McmFlashCache_Disabled,
    *    McmFlashSpeculation_InstructionsAndData,
    * };
    *
    * flashInit.configure();  // Configure selected options
    * @endcode
    */
   class FlashInit {
   
   private:
      /**
       * Prevent implicit parameter conversions
       */
      template <typename... Types>
      constexpr FlashInit(Types...) = delete;
   
      /// Value for placr register
      uint32_t placr = 0;
   
   public:
      /**
       * Configure Flash options as specified in the constructor
       */
      inline void configure() const {
         mcm->PLACR = (mcm->PLACR & ~(MCM_PLACR_DFCC_MASK|MCM_PLACR_DFCIC_MASK|MCM_PLACR_DFCDA_MASK|MCM_PLACR_DFCS_MASK|MCM_PLACR_EFDS_MASK))|
                      placr;
      }
   
      /**
       * Read the current Flash settings from hardware registers
       */
      void readConfig() {
         placr = mcm->PLACR & (MCM_PLACR_DFCC_MASK|MCM_PLACR_DFCIC_MASK|MCM_PLACR_DFCDA_MASK|MCM_PLACR_DFCS_MASK|MCM_PLACR_EFDS_MASK);
      }
   
      /**
       * Copy Constructor
       */
      constexpr FlashInit(const FlashInit &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr FlashInit() = default;
   
      /**
       * Constructor
       *
       * @tparam   Types
       * @param    rest
       * @param mcmStallFlashController Enable Stalling Flash Controller
       */
      template <typename... Types>
      constexpr FlashInit(McmStallFlashController mcmStallFlashController, Types... rest) : FlashInit(rest...)  {
   
         placr = (placr&~MCM_PLACR_ESFC_MASK) | mcmStallFlashController;
      }

      /**
       * Constructor
       *
       * @tparam   Types
       * @param    rest
       * @param mcmFlashCache Flash Controller Cache
       */
      template <typename... Types>
      constexpr FlashInit(McmFlashCache mcmFlashCache, Types... rest) : FlashInit(rest...)  {
   
         placr = (placr&~(MCM_PLACR_DFCC_MASK|MCM_PLACR_DFCIC_MASK|MCM_PLACR_DFCDA_MASK)) | mcmFlashCache;
      }

      /**
       * Constructor
       *
       * @tparam   Types
       * @param    rest
       * @param mcmFlashSpeculation Flash Controller Speculation Buffer
       */
      template <typename... Types>
      constexpr FlashInit(McmFlashSpeculation mcmFlashSpeculation, Types... rest) : FlashInit(rest...)  {
   
         placr = (placr&~(MCM_PLACR_DFCS_MASK|MCM_PLACR_EFDS_MASK)) | mcmFlashSpeculation;
      }

   };

}; // class McmInfo



/**
 * Template class providing a base for Miscellaneous Control Module
 */
class McmBase : public McmInfo {

public:
   /**
    * Default value for MCM::FlashInit
    * This value is created from Configure.usbdmProject settings (Peripheral Parameters->MCM)
    */
   static constexpr McmInfo::FlashInit DefaultFlashInitValue {
      McmFlashSpeculation_InstructionsOnly , // (mcm_placr_flash_speculation) Flash Controller Speculation Buffer - Instructions Only
      McmFlashCache_InstructionsAndData,  // (mcm_placr_flash_cache)    Flash Controller Cache - Instructions and Data
   };
   
   using McmInfo::configureFlashController;
   
   /**
    * Configure Flash Controller
    *
    * @param flashInit Initialisation value
    */
   static void configureFlashController(const McmInfo::FlashInit &flashInit) {
      flashInit.configure();
   }

// /MCM/DefaultSramAccessInitValue not found
// /MCM/DefaultFloatingPointIrqInitValue not found

};

   /**
    * Class representing MCM
    */
   using Mcm = McmBase;

/**
 * End MCM_Group
 * @}
 */
#endif // /MCM/_BasicInfoGuard
} // End namespace USBDM

#endif /* HEADER_MCM_H */
