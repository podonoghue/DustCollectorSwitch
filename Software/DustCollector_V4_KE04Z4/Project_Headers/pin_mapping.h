/**
 * @file      pin_mapping.h (generated from MKE04Z4.usbdmHardware)
 * @version   1.3.0
 * @brief     Peripheral declarations for MKE04Z8VTG4
 *
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#ifndef PROJECT_HEADERS_PIN_MAPPING_H
#define PROJECT_HEADERS_PIN_MAPPING_H

#include <stdint.h>
#include <stddef.h>
#include <array>

#include "derivative.h"
#include "pcr.h"
#include "error.h"

/**
 * Namespace enclosing USBDM classes
 */
namespace USBDM {

/**
 * @addtogroup USBDM_Group USBDM Peripheral Interface
 * @brief Hardware Peripheral Interface and library
 * @{
 */
/* Template:_common_settings.xml */

   /**
    * Enables mapping of all allocated pins during startup using mapAllPins()
    * Not available on this MCU
    */
   static constexpr bool MapAllPinsOnStartup = false;

   /**
    * Controls forcing all pins to be locked in mapAllPins()
    * Not available on this MCU
    */
   static constexpr uint32_t ForceLockedPins = 0;
   static constexpr uint32_t PinLock_Locked  = 0;

   /**
    * Enables forcing unbonded pins to analogue function in mapAllPins()
    * Not available on this MCU
    */
   static constexpr bool ForceLockoutUnbondedPins = false;
   
   /** ICSFFCLK - Fixed frequency clock (input to FLL) */
   extern volatile uint32_t SystemIcsFFClock;
   
   /** ICSOUTCLK - Primary output from ICS, various sources */
   extern volatile uint32_t SystemIcsOutClock;
   
   /** ICSFLLCLK - Output of FLL */
   extern volatile uint32_t SystemIcsFllClock;
   
// Use when in-lining makes the release build smaller
#ifdef DEBUG_BUILD
#define INLINE_RELEASE __attribute__((noinline))
#else
#define INLINE_RELEASE __attribute__((always_inline))
#endif

#ifdef DEBUG_BUILD
#define NOINLINE_DEBUG __attribute__((noinline))
#else
#define NOINLINE_DEBUG
#endif

   /**
    * Calculate a Vector number using an offset from an existing number.
    * This is only useful if related vectors are consecutive e.g. DMA0_IRQn, DMA1_IRQn ...
    *
    * @param vector  Base vector to use
    * @param offset  Offset from base vector
    *
    * @return  Vector number calculated from vector+offset
    */
   constexpr IRQn_Type inline operator+(IRQn_Type vector, unsigned offset) {
      return static_cast<IRQn_Type>(static_cast<unsigned>(vector) + offset);
   }

   /**
    * Calculate a Vector number using an offset from an existing number.
    * This is only useful if related vectors are consecutive e.g. DMA0_IRQn, DMA1_IRQn ...
    *
    * @param vector  Base vector to use
    * @param offset  Offset from base vector
    *
    * @return  Vector number calculated from vector+offset
    */
   constexpr IRQn_Type inline operator+(IRQn_Type vector, int offset) {
      return vector + static_cast<unsigned>(offset);
   }

   /**
    * @tparam  T  Type of comparison object (inferred)
    * @param   a  Left-hand object for comparison
    * @param   b  Right-hand object for comparison
    *
    * @return Smaller of a or b
    */
   template<class T>
   constexpr T min(const T a, const T b) {
      return (b < a) ? b : a;
   }

   /**
    * @tparam  T  Type of comparison object (inferred)
    * @param   a  Left-hand object for comparison
    * @param   b  Right-hand object for comparison
    *
    * @return Larger of a or b
    */
   template<class T>
   constexpr T max(const T a, const T b) {
      return (b > a) ? b : a;
   }

   constexpr IRQn_Type IRQn_None = static_cast<IRQn_Type>(-20);

   /**
    * Determine the number of elements in an array
    *
    * @tparam T      Deduced array type
    * @tparam N      Deduced array size
    *
    * @return  Size of array in elements
    */
   template<typename T, size_t N>
      consteval size_t sizeofArray(T (&)[N]) {
         return N;
      }

   /**
    * Enter critical section
    *
    * Disables interrupts for a critical section
    *
    * @param cpuSR Variable to hold interrupt state so it can be restored
    *
    * @code
    * uint8_t cpuSR;
    * ...
    * enterCriticalSection(cpuSR);
    *  // Critical section
    * exitCriticalSection(cpuSR);
    * @endcode
    */
   static inline void enterCriticalSection(uint8_t &cpuSR) {
      __asm__ volatile (
            "  MRS   r0, PRIMASK       \n"   // Copy flags
            // It may be possible for a ISR to run here but it
            // would save/restore PRIMASK so this code is OK
            "  CPSID I                 \n"   // Disable interrupts
            "  STRB  r0, %[output]     \n"   // Save flags
            : [output] "=m" (cpuSR) : : "r0");
   }

   /**
    * Exit critical section
    *
    * Restores interrupt state saved by enterCriticalSection()
    *
    * @param cpuSR Variable to holding interrupt state to be restored
    */
   static inline void exitCriticalSection(uint8_t &cpuSR) {
      __asm__ volatile (
            "  LDRB r0, %[input]    \n"  // Retrieve original flags
            "  MSR  PRIMASK,r0;     \n"  // Restore
            : :[input] "m" (cpuSR) : "r0");
   }

   /**
    * Class to implement simple critical sections by disabling interrupts.
    *
    * Disables interrupts for a critical section.
    * This would be from the declaration of the object until the end of
    * enclosing block. An object of this class should be declared at the
    * start of a block. e.g.
    * @code
    *    {
    *       CriticalSection cs;
    *       ...
    *       Protected code
    *       ...
    *    }
    * @endcode
    *
    * @note uses PRIMASK
    */
   class CriticalSection {
   
   private:
      /** Used to record interrupt state on entry */
      volatile uint32_t cpuSR;
   
   public:
      /**
       * Constructor - Enter critical section
       *
       * Disables interrupts for a critical section
       * This would be from the declaration of the object until end of enclosing block.
       */
      CriticalSection() __attribute__((always_inline)) {
         __asm__ volatile (
               "  MRS   r0, PRIMASK       \n"   // Copy flags
               // It may be possible for a ISR to run here but it
               // would save/restore PRIMASK so this code is OK
               "  CPSID I                 \n"   // Disable interrupts
               "  STR  r0, %[output]      \n"   // Save flags
               : [output] "=m" (cpuSR) : : "r0");
      }
   
      /**
       * Destructor - Exit critical section
       *
       * Enables interrupts IFF previously disabled by this object
       * This would be done implicitly by exiting the enclosing block.
       */
      inline ~CriticalSection() __attribute__((always_inline)) {
         __asm__ volatile (
               "  LDR r0, %[input]     \n"  // Retrieve original flags
               "  MSR  PRIMASK,r0;     \n"  // Restore
               : :[input] "m" (cpuSR) : "r0");
      }
   };
/* END Template:_common_settings.xml */

/*
 * Peripheral Information Classes
 */
/**
 * @addtogroup GPIO_Group GPIO, Digital Input/Output
 * @brief Abstraction for Digital Input/Output
 * @{
 */
/**
 * Peripheral information for GPIO, Digital Input/Output.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class GpioAInfo {
public:
   /*
    * Template:fgpioa_mke
    */
   /* Template _enablePeripheral  */
   
   //! Configure peripheral in start-up
   static constexpr bool configurePeripheralInStartUp = false;

   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = GPIOA_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<GPIO_Type> gpio = baseAddress;
   
};

/** 
 * End group GPIO_Group
 * @}
 */
/**
 * @addtogroup PMC_Group PMC, Power Management Controller
 * @brief Abstraction for Power Management Controller
 * @{
 */
/**
 * Peripheral information for PMC, Power Management Controller.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Low-Voltage Detect Enable
    *
    * This write-once bit enables low-voltage detect logic
    */
   enum PmcLowVoltageDetect {
      PmcLowVoltageDetect_Disabled = PMC_SPMSC1_LVDE(0), ///< LVD logic disabled
      PmcLowVoltageDetect_Enabled  = PMC_SPMSC1_LVDE(1), ///< LVD logic enabled

   };

   /**
    * Low-Voltage Warning Interrupt Enable
    *
    * Enables hardware interrupt requests for LVWF
    */
   enum PmcLowVoltageWarningInterrupt {
      PmcLowVoltageWarningInterrupt_Disabled = PMC_SPMSC1_LVWIE(0), ///< Interrupt disabled
      PmcLowVoltageWarningInterrupt_Enabled  = PMC_SPMSC1_LVWIE(1), ///< Interrupt enabled

   };

   /**
    * Low-Voltage Detect Reset Enable
    *
    * 
    */
   enum PmcLowVoltageReset {
      PmcLowVoltageReset_Disabled = PMC_SPMSC1_LVDRE(0), ///< LVD events do not generate hardware resets
      PmcLowVoltageReset_Enabled  = PMC_SPMSC1_LVDRE(1), ///< Force an MCU reset when an enabled low-voltage detect event occurs

   };

   /**
    * Low-Voltage Detect Stop Enable
    *
    * 
    */
   enum PmcLowVoltageDetectInStop {
      PmcLowVoltageDetectInStop_Disabled = PMC_SPMSC1_LVDSE(0), ///< LVD events disabled during stop mode
      PmcLowVoltageDetectInStop_Enabled  = PMC_SPMSC1_LVDSE(1), ///< LVD events enabled during stop mode

   };

   /**
    * Bandgap Buffer Enable
    *
    * Enables an internal buffer for the bandgap voltage reference for use
    * as a ADC internal channel or ACMP reference
    */
   enum PmcBandgapBuffer {
      PmcBandgapBuffer_Disabled = PMC_SPMSC1_BGBE(0), ///< Bandgap buffer is disabled
      PmcBandgapBuffer_Enabled  = PMC_SPMSC1_BGBE(1), ///< Bandgap buffer is enabled

   };

   /**
    * Low-Voltage Detect Level Select
    *
    * Write-once bit
    */
   enum PmcLowVoltageDetectLevel {
      PmcLowVoltageDetectLevel_LowTripPoint  = PMC_SPMSC2_LVDV(0), ///< Low trip point (VLVD = VLVDL)
      PmcLowVoltageDetectLevel_HighTripPoint = PMC_SPMSC2_LVDV(1), ///< High trip point (VLVD = VLVDH)

   };

   /**
    * Low-Voltage Warning Level Select
    *
    * 
    */
   enum PmcLowVoltageWarningLevel {
      PmcLowVoltageWarningLevel_LowTripPoint  = PMC_SPMSC2_LVWV(0), ///< Low trip point (VLVW = VLVW1)
      PmcLowVoltageWarningLevel_Mid1TripPoint = PMC_SPMSC2_LVWV(1), ///< Mid 1 trip point (VLVW = VLVW2)
      PmcLowVoltageWarningLevel_Mid2TripPoint = PMC_SPMSC2_LVWV(2), ///< Mid 2 trip point (VLVW = VLVW3)
      PmcLowVoltageWarningLevel_HighTripPoint = PMC_SPMSC2_LVWV(3), ///< High trip point (VLVW = VLVW4)

   };

   /**
    * Indicates reason for execution of call-back
   */
   enum PmcInterruptReason {
      PmcInterruptReason_LowVoltageDetect,//!< Low Voltage Detect
      PmcInterruptReason_LowVoltageWarning//!< Low Voltage Warning
   };
   
class PmcInfo {
public:
   /*
    * Template:pmc_mke
    */
   /* Template _enablePeripheral  */
   
   //! Configure peripheral in start-up
   static constexpr bool configurePeripheralInStartUp = false;

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = PMC_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_Normal;

   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = PMC_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<PMC_Type> pmc = baseAddress;
   
   //! Frequency of Low Power Oscillator (LPO) Clock [~1kHz]
   static constexpr uint32_t system_low_power_clock = 1000UL;

   /**
    * Get LPO clock
    *
    * @return frequency in Hz as uint32_t
    */
   static constexpr uint32_t getLpoClock() {
      return system_low_power_clock;
   }

};

/** 
 * End group PMC_Group
 * @}
 */
/**
 * @addtogroup OSC_Group OSC, Crystal Oscillator
 * @brief Abstraction for Crystal Oscillator
 * @{
 */
/**
 * Peripheral information for OSC, Crystal Oscillator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * OSC0 mode
    *
    * Determines oscillator power mode and
    * whether an external clock or crystal is used.
    */
   enum OscMode {
      OscMode_ExternalClock       = OSC_CR_OSCOS(0)|OSC_CR_HGO(0), ///< External clock
      OscMode_LowPowerOscillator  = OSC_CR_OSCOS(1)|OSC_CR_HGO(0), ///< Low Power Oscillator
      OscMode_HighPowerOscillator = OSC_CR_OSCOS(1)|OSC_CR_HGO(1), ///< High Gain Oscillator

   };

   /**
    * OSC Enable
    *
    * Enables the OSC module. The OSC module can also be enabled by the ICS module
    */
   enum OscEnable {
      OscEnable_Disabled = OSC_CR_OSCEN(0), ///< OSC disabled
      OscEnable_Enabled  = OSC_CR_OSCEN(1), ///< OSC enabled

   };

   /**
    * OSC Enable in Stop mode
    *
    * Controls whether or not the OSC clock remains enabled when MCU enters Stop mode when OSCEN is set.
    * OSCSTEN has no effect if ICS requests OSC enable
    */
   enum OscInStopMode {
      OscInStopMode_Disabled = OSC_CR_OSCSTEN(0), ///< Disabled in Stop mode
      OscInStopMode_Enabled  = OSC_CR_OSCSTEN(1), ///< Enabled in Stop mode

   };

   /**
    * OSC Output Select
    *
    * Selects the output clock of the OSC module
    */
   enum OscOutputSelect {
      OscOutputSelect_ExternalClock = OSC_CR_OSCOS(0), ///< External clock source
      OscOutputSelect_Oscillator    = OSC_CR_OSCOS(1), ///< Oscillator clock source

   };

   /**
    * Frequency Range Select
    *
    * Selects the frequency range for the OSC module
    */
   enum OscFrequencyRange {
      OscFrequencyRange_LowRange  = OSC_CR_RANGE(0), ///< Low range of 32 kHz
      OscFrequencyRange_HighRange = OSC_CR_RANGE(1), ///< High range of 4-20 MHz

   };

   /**
    * High Gain Oscillator Select
    *
    * Controls the OSC mode of operation
    */
   enum OscCrHgo {
      OscCrHgo_LowPowerMode = OSC_CR_HGO(0), ///< Low-power mode
      OscCrHgo_HighGainMode = OSC_CR_HGO(1), ///< High-gain mode

   };

class Osc0Info {
public:
   /*
    * Template:osc0_mke
    */
   /* Template _enablePeripheral  */
   
   //! Configure peripheral in start-up
   static constexpr bool configurePeripheralInStartUp = false;

   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = OSC0_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<OSC_Type> osc = baseAddress;
   
   //! Peripheral instance number
   static constexpr unsigned instance = 0;
   
   //! Frequency of OSC Clock or Crystal
   static constexpr uint32_t osc_clock = 
      0;  // Frequency of OSC Clock or Crystal [OSCCLK]
   
   /**
    * Get OSC clock
    *
    * @return Clock frequency as uint32_t in Hz
    */
   static uint32_t getOscClock() {
      switch(osc->CR&(OSC_CR_OSCINIT_MASK|OSC_CR_OSCOS_MASK)) {
         case OSC_CR_OSCINIT(0)|OSC_CR_OSCOS(0):
         case OSC_CR_OSCINIT(1)|OSC_CR_OSCOS(0):
            // External clock - assume valid
            return osc_clock;
            break;
         case OSC_CR_OSCINIT(1)|OSC_CR_OSCOS(1):
            // Oscillator selected and valid
            return (osc->CR&OSC_CR_OSCINIT_MASK)?osc_clock:0;
         default :
            return 0;
         break;
      }
   }

};

/** 
 * End group OSC_Group
 * @}
 */
/**
 * @addtogroup RTC_Group RTC, Real Time Clock
 * @brief Abstraction for Real Time Clock
 * @{
 */
/**
 * Peripheral information for RTC, Real Time Clock.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class RtcInfo {
public:
   /*
    * Template:rtcntr_mke
    */
};

/** 
 * End group RTC_Group
 * @}
 */
/**
 * @addtogroup SIM_Group SIM, System Integration Module
 * @brief Abstraction for System Integration Module
 * @{
 */
/**
 * Peripheral information for SIM, System Integration Module.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Core/System Clock Divider value
    *
    * This field sets the divide value for the core/system clock
    */
   enum SimCoreClkDivider {
      SimCoreClkDivider_Direct = SIM_CLKDIV_OUTDIV1(0), ///< ICSOUTCLK direct
      SimCoreClkDivider_DivBy2 = SIM_CLKDIV_OUTDIV1(1), ///< ICSOUTCLK/2
      SimCoreClkDivider_DivBy3 = SIM_CLKDIV_OUTDIV1(2), ///< ICSOUTCLK/3
      SimCoreClkDivider_DivBy4 = SIM_CLKDIV_OUTDIV1(3), ///< ICSOUTCLK/4

   };

   /**
    * Bus/Flash Clock Divider value
    *
    * This field sets the divide value for the bus/FLASH, follows OUTDIV1
    */
   enum SimBusClkDivider {
      SimBusClkDivider_Direct = SIM_CLKDIV_OUTDIV2(0), ///< Core clock direct
      SimBusClkDivider_DivBy2 = SIM_CLKDIV_OUTDIV2(1), ///< Core clock/2

   };

   /**
    * Timer Clock Divider value
    *
    * This field sets the divide value for the timers(FTM0, FTM2,PWT)
    */
   enum SimTimerClkDivider {
      SimTimerClkDivider_Direct = SIM_CLKDIV_OUTDIV3(0), ///< ICSOUTCLK direct
      SimTimerClkDivider_DivBy2 = SIM_CLKDIV_OUTDIV3(1), ///< ICSOUTCLK/2

   };

   /**
    * BUS Clock Output select
    *
    * Enable bus reference clock output on PTC5 with prescaler
    */
   enum SimSoptRefClock {
      SimSoptRefClock_Disabled             = SIM_SOPT_CLKOE(0)|SIM_SOPT_BUSREF(0), ///< Disabled (PTC5 available)
      SimSoptRefClock_BusClock             = SIM_SOPT_CLKOE(1)|SIM_SOPT_BUSREF(0), ///< Bus clock
      SimSoptRefClock_BusClockDividedBy2   = SIM_SOPT_CLKOE(1)|SIM_SOPT_BUSREF(1), ///< Bus clock divided by 2
      SimSoptRefClock_BusClockDividedBy4   = SIM_SOPT_CLKOE(1)|SIM_SOPT_BUSREF(2), ///< Bus clock divided by 4
      SimSoptRefClock_BusClockDividedBy8   = SIM_SOPT_CLKOE(1)|SIM_SOPT_BUSREF(3), ///< Bus clock divided by 8
      SimSoptRefClock_BusClockDividedBy16  = SIM_SOPT_CLKOE(1)|SIM_SOPT_BUSREF(4), ///< Bus clock divided by 16
      SimSoptRefClock_BusClockDividedBy32  = SIM_SOPT_CLKOE(1)|SIM_SOPT_BUSREF(5), ///< Bus clock divided by 32
      SimSoptRefClock_BusClockDividedBy64  = SIM_SOPT_CLKOE(1)|SIM_SOPT_BUSREF(6), ///< Bus clock divided by 64
      SimSoptRefClock_BusClockDividedBy128 = SIM_SOPT_CLKOE(1)|SIM_SOPT_BUSREF(7), ///< Bus clock divided by 128

   };

   /**
    * SWD Clock Gate Control
    *
    * 
    */
   enum SimScgcSwd {
      SimScgcSwd_ClockDisabled = SIM_SCGC_SWD(0), ///< Clock disabled
      SimScgcSwd_ClockEnabled  = SIM_SCGC_SWD(1), ///< Clock enabled

   };

   /**
    * Single Wire Debug Port Pin Enable
    *
    * Controls: 
    * PTA4 as PTA4/ACMP0_OUT or SWD_DIO, 
    * PTA0 as PTA0/KBI0_P0/FTM0_CH0/RTC_CLKOUT/ACMP0_IN2/ADC0_SE0 or SWD_CLK functions
    */
   enum SimSWDEnable {
      SimSWDEnable_Pta4Pta0AsPeripheralPins = SIM_SOPT_SWDE(0), ///< PTA4, PTA0 available for peripherals
      SimSWDEnable_Pta4Pta0AsSwdPins        = SIM_SOPT_SWDE(1), ///< PTA4, PTA0 mapped as SWD pins

   };

   /**
    * RESET Pin Enable
    *
    * This field can only be written once after any reset
    */
   enum SimResetEnable {
      SimResetEnable_Pta5AsPeripheralPin = SIM_SOPT_RSTPE(0), ///< PTA5 available for peripherals
      SimResetEnable_Pta5AsReset         = SIM_SOPT_RSTPE(1), ///< PTA5 mapped as RESET

   };

   /**
    * NMI Pin Enable
    *
    * This field can only be written once after any reset
    */
   enum SimNmiEnable {
      SimNmiEnable_Ptb4AsPeripheralPins = SIM_SOPT_NMIE(0), ///< PTB4 available for peripherals
      SimNmiEnable_Ptb4AsNmi            = SIM_SOPT_NMIE(1), ///< PTB4 mapped as NMI

   };

   /**
    * ADC Hardware Trigger Source
    *
    * Selects the ADC hardware trigger source. All trigger sources start ADC conversion on rising-edge
    */
   enum SimSoptAdhwt {
      SimSoptAdhwt_RtcOverflow                   = SIM_SOPT_ADHWT(0), ///< RTC overflow
      SimSoptAdhwt_Ftm0                          = SIM_SOPT_ADHWT(1), ///< FTM0
      SimSoptAdhwt_Ftm2InitTriggerWith8BitDelay  = SIM_SOPT_ADHWT(2), ///< FTM2 init trigger with 8-bit delay
      SimSoptAdhwt_Ftm2MatchTriggerWith8BitDelay = SIM_SOPT_ADHWT(3), ///< FTM2 match trigger with 8-bit delay
      SimSoptAdhwt_PitChannel0Overflow           = SIM_SOPT_ADHWT(4), ///< PIT channel 0 overflow
      SimSoptAdhwt_PitChannel1Overflow           = SIM_SOPT_ADHWT(5), ///< PIT channel 1 overflow
      SimSoptAdhwt_Acmp0Out                      = SIM_SOPT_ADHWT(6), ///< ACMP0 OUT
      SimSoptAdhwt_Acmp1Out                      = SIM_SOPT_ADHWT(7), ///< ACMP1 OUT

   };

   /**
    * ACMP0 Clock Gate Control
    *
    * 
    */
   enum SimScgcAcmp0 {
      SimScgcAcmp0_ClockDisabled = SIM_SCGC_ACMP0(0), ///< Clock disabled
      SimScgcAcmp0_ClockEnabled  = SIM_SCGC_ACMP0(1), ///< Clock enabled

   };

   /**
    * ACMP Trigger FTM2 selection
    *
    * Selects ACMP output used as the trigger0 input of FTM2
    */
   enum SimSoptActrg {
      SimSoptActrg_Acmp0_out = SIM_SOPT_ACTRG(0), ///< ACMP0_OUT
      SimSoptActrg_Acmp1_out = SIM_SOPT_ACTRG(1), ///< ACMP1_OUT

   };

   /**
    * ACMP1 Clock Gate Control
    *
    * 
    */
   enum SimScgcAcmp1 {
      SimScgcAcmp1_ClockDisabled = SIM_SCGC_ACMP1(0), ///< Clock disabled
      SimScgcAcmp1_ClockEnabled  = SIM_SCGC_ACMP1(1), ///< Clock enabled

   };

   /**
    * CRC Clock Gate Control
    *
    * 
    */
   enum SimScgcCrc {
      SimScgcCrc_ClockDisabled = SIM_SCGC_CRC(0), ///< Clock disabled
      SimScgcCrc_ClockEnabled  = SIM_SCGC_CRC(1), ///< Clock enabled

   };

   /**
    * FLASH Clock Gate Control
    *
    * 
    */
   enum SimScgcFlash {
      SimScgcFlash_ClockDisabled = SIM_SCGC_FLASH(0), ///< Clock disabled
      SimScgcFlash_ClockEnabled  = SIM_SCGC_FLASH(1), ///< Clock enabled

   };

   /**
    * FTM2 Synchronisation Select
    *
    * Writing this field generates a PWM synchronisation trigger to the FTM2 module
    */
   enum SimSoptFtmsync {
      SimSoptFtmsync_GenerateFtmTrigger = SIM_SOPT_FTMSYNC(1), ///< Generates trigger

   };

   /**
    * FTM0 Clock Gate Control
    *
    * 
    */
   enum SimScgcFtm0 {
      SimScgcFtm0_ClockDisabled = SIM_SCGC_FTM0(0), ///< Clock disabled
      SimScgcFtm0_ClockEnabled  = SIM_SCGC_FTM0(1), ///< Clock enabled

   };

   /**
    * FTM0 TCLK Pin Select
    *
    * 
    */
   enum SimPinselFtm0clkps {
      SimPinselFtm0clkps_SelectsTclk1ForFtm0Module = SIM_PINSEL_FTM0CLKPS(0), ///< Selects TCLK1 for FTM0 module
      SimPinselFtm0clkps_SelectsTclk2ForFtm0Module = SIM_PINSEL_FTM0CLKPS(1), ///< Selects TCLK2 for FTM0 module

   };

   /**
    * FTM0 channel 0 Pin Select
    *
    * 
    */
   enum SimPinselFtm0ps0 {
      SimPinselFtm0ps0_Pta0 = SIM_PINSEL_FTM0PS0(0), ///< PTA0
      SimPinselFtm0ps0_Ptb2 = SIM_PINSEL_FTM0PS0(1), ///< PTB2

   };

   /**
    * FTM0 channel 1 Pin Select
    *
    * 
    */
   enum SimPinselFtm0ps1 {
      SimPinselFtm0ps1_Pta1 = SIM_PINSEL_FTM0PS1(0), ///< PTA1
      SimPinselFtm0ps1_Ptb3 = SIM_PINSEL_FTM0PS1(1), ///< PTB3

   };

   /**
    * FTM0 channel 0 Input Capture Source
    *
    * Selects the sources for FTM0CH0 as capture input
    */
   enum SimSoptFtmic {
      SimSoptFtmic_Ftm0_ch0Pin = SIM_SOPT_FTMIC(0), ///< FTM0_CH0 pin
      SimSoptFtmic_Acmp0_out   = SIM_SOPT_FTMIC(1), ///< ACMP0_OUT
      SimSoptFtmic_Acmp1_out   = SIM_SOPT_FTMIC(2), ///< ACMP1_OUT
      SimSoptFtmic_RtcOverflow = SIM_SOPT_FTMIC(3), ///< RTC overflow

   };

   /**
    * UART0_RX Capture on FTM0 channel 1
    *
    * Enables the UART0_RX to be captured by FTM0 channel 1
    */
   enum SimSoptRxdce {
      SimSoptRxdce_NotConnected                    = SIM_SOPT_RXDCE(0), ///< Not connected
      SimSoptRxdce_Uart0_rxConnectedAsFtm0Channel1 = SIM_SOPT_RXDCE(1), ///< UART0_RX connected as FTM0 channel 1

   };

   /**
    * FTM2 Clock Gate Control
    *
    * 
    */
   enum SimScgcFtm2 {
      SimScgcFtm2_ClockDisabled = SIM_SCGC_FTM2(0), ///< Clock disabled
      SimScgcFtm2_ClockEnabled  = SIM_SCGC_FTM2(1), ///< Clock enabled

   };

   /**
    * FTM2 TCLK Pin Select
    *
    * 
    */
   enum SimPinselFtm2clkps {
      SimPinselFtm2clkps_SelectsTclk1ForFtm2Module = SIM_PINSEL_FTM2CLKPS(0), ///< Selects TCLK1 for FTM2 module
      SimPinselFtm2clkps_SelectsTclk2ForFtm2Module = SIM_PINSEL_FTM2CLKPS(1), ///< Selects TCLK2 for FTM2 module

   };

   /**
    * FTM2 Channel 2 Pin Select
    *
    * 
    */
   enum SimPinselFtm2ps2 {
      SimPinselFtm2ps2_Ptc2 = SIM_PINSEL_FTM2PS2(0), ///< PTC2
      SimPinselFtm2ps2_Ptc4 = SIM_PINSEL_FTM2PS2(1), ///< PTC4

   };

   /**
    * FTM2 Channel 3 Pin Select
    *
    * 
    */
   enum SimPinselFtm2ps3 {
      SimPinselFtm2ps3_Ptc3 = SIM_PINSEL_FTM2PS3(0), ///< PTC3
      SimPinselFtm2ps3_Ptc5 = SIM_PINSEL_FTM2PS3(1), ///< PTC5

   };

   /**
    * I2C0 Clock Gate Control
    *
    * 
    */
   enum SimScgcI2c0 {
      SimScgcI2c0_ClockDisabled = SIM_SCGC_I2C(0), ///< Clock disabled
      SimScgcI2c0_ClockEnabled  = SIM_SCGC_I2C(1), ///< Clock enabled

   };

   /**
    * I2C0 Pin Select
    *
    * 
    */
   enum SimPinselI2c0ps {
      SimPinselI2c0ps_Pta3Pta2MappedToI2c0 = SIM_PINSEL_I2C0PS(0), ///< PTA3,PTA2 mapped to SCL,SDA
      SimPinselI2c0ps_Ptb7Ptb6MappedToI2c0 = SIM_PINSEL_I2C0PS(1), ///< PTB7,PTB6 mapped to SCL,SDA

   };

   /**
    * IRQ Clock Gate Control
    *
    * 
    */
   enum SimScgcIrq {
      SimScgcIrq_ClockDisabled = SIM_SCGC_IRQ(0), ///< Clock disabled
      SimScgcIrq_ClockEnabled  = SIM_SCGC_IRQ(1), ///< Clock enabled

   };

   /**
    * KBI0 Clock Gate Control
    *
    * 
    */
   enum SimScgcKbi0 {
      SimScgcKbi0_ClockDisabled = SIM_SCGC_KBI0(0), ///< Clock disabled
      SimScgcKbi0_ClockEnabled  = SIM_SCGC_KBI0(1), ///< Clock enabled

   };

   /**
    * KBI1 Clock Gate Control
    *
    * 
    */
   enum SimScgcKbi1 {
      SimScgcKbi1_ClockDisabled = SIM_SCGC_KBI1(0), ///< Clock disabled
      SimScgcKbi1_ClockEnabled  = SIM_SCGC_KBI1(1), ///< Clock enabled

   };

   /**
    * PIT Clock Gate Control
    *
    * 
    */
   enum SimScgcPit {
      SimScgcPit_ClockDisabled = SIM_SCGC_PIT(0), ///< Clock disabled
      SimScgcPit_ClockEnabled  = SIM_SCGC_PIT(1), ///< Clock enabled

   };

   /**
    * PWT Clock Gate Control
    *
    * 
    */
   enum SimScgcPwt {
      SimScgcPwt_ClockDisabled = SIM_SCGC_PWT(0), ///< Clock disabled
      SimScgcPwt_ClockEnabled  = SIM_SCGC_PWT(1), ///< Clock enabled

   };

   /**
    * PWT TCLK Pin Select
    *
    * 
    */
   enum SimPinselPwtclkps {
      SimPinselPwtclkps_SelectsTclk1ForPwtModule = SIM_PINSEL_PWTCLKPS(0), ///< Selects TCLK1 for PWT module
      SimPinselPwtclkps_SelectsTclk2ForPwtModule = SIM_PINSEL_PWTCLKPS(1), ///< Selects TCLK2 for PWT module

   };

   /**
    * RTC Clock Gate Control
    *
    * 
    */
   enum SimScgcRtc {
      SimScgcRtc_ClockDisabled = SIM_SCGC_RTC(0), ///< Clock disabled
      SimScgcRtc_ClockEnabled  = SIM_SCGC_RTC(1), ///< Clock enabled

   };

   /**
    * SPI0 Clock Gate Control
    *
    * 
    */
   enum SimScgcSpi0 {
      SimScgcSpi0_ClockDisabled = SIM_SCGC_SPI0(0), ///< Clock disabled
      SimScgcSpi0_ClockEnabled  = SIM_SCGC_SPI0(1), ///< Clock enabled

   };

   /**
    * SPI0 Pin Select
    *
    * Selects the SPI0 Pinouts
    */
   enum SimPinselSpi0ps {
      SimPinselSpi0ps_Ptb2Ptb3Ptb4Ptb5MappedToSpi0 = SIM_PINSEL_SPI0PS(0), ///< PTB2,PTB3,PTB4,PTB5 mapped to SPI0 pins
      SimPinselSpi0ps_Pta6Pta7Ptb1Ptb0MappedToSpi0 = SIM_PINSEL_SPI0PS(1), ///< PTA6,PTA7,PTB1,PTB0 mapped to SPI0 pins

   };

   /**
    * UART0 Clock Gate Control
    *
    * 
    */
   enum SimScgcUart0 {
      SimScgcUart0_ClockDisabled = SIM_SCGC_UART0(0), ///< Clock disabled
      SimScgcUart0_ClockEnabled  = SIM_SCGC_UART0(1), ///< Clock enabled

   };

   /**
    * UART0 Pin Select
    *
    * 
    */
   enum SimPinselUart0ps {
      SimPinselUart0ps_MappedToPtb1Ptb0 = SIM_PINSEL_UART0PS(0), ///< PTB1,PTB0 mapped to Tx,Rx
      SimPinselUart0ps_MappedToPta3Pta2 = SIM_PINSEL_UART0PS(1), ///< PTA3,PTA2 mapped to Tx,Rx

   };

   /**
    * UART0_TX Modulation Select
    *
    * Enables the UART0_TX output modulated by FTM0 channel 0
    */
   enum SimSoptTxdme {
      SimSoptTxdme_Uart0_txDirectlyConnectedToPin = SIM_SOPT_TXDME(0), ///< UART0_TX directly connected to pin
      SimSoptTxdme_Uart0_txModulatedByFtm0Channel = SIM_SOPT_TXDME(1), ///< UART0_TX modulated by FTM0 channel

   };

   /**
    * UART0_RX Filter Select
    *
    * Enables the UART0_RX input to be filtered by ACMP.
    * When this function is enabled, any signal tagged with ACMP inputs can be regarded as UART0
    */
   enum SimSoptRxdfe {
      SimSoptRxdfe_Uart0ModuleDirectly = SIM_SOPT_RXDFE(0), ///< UART0 module directly
      SimSoptRxdfe_FilteredByAcmp0     = SIM_SOPT_RXDFE(1), ///< Filtered by ACMP0
      SimSoptRxdfe_FilteredByAcmp1     = SIM_SOPT_RXDFE(2), ///< Filtered by ACMP1
      SimSoptRxdfe_Reserved            = SIM_SOPT_RXDFE(3), ///< Reserved

   };

class SimInfo {
public:
   /*
    * Template:sim_mke04z4
    */
   /* Template _enablePeripheral  */
   
   //! Configure peripheral in start-up
   static constexpr bool configurePeripheralInStartUp = false;

   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = SIM_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<SIM_Type> sim = baseAddress;
   
   /**
    * Update system clock values
    *
    * @param systemClock Frequency of clock provided to system clock dividers
    */
   static void updateSystemClocks(unsigned systemClock) {
   
      SystemCoreClock    = systemClock/(((SIM->CLKDIV&SIM_CLKDIV_OUTDIV1_MASK)>>SIM_CLKDIV_OUTDIV1_SHIFT)+1);
      SystemBusClock     = SystemCoreClock/(((SIM->CLKDIV&SIM_CLKDIV_OUTDIV2_MASK)>>SIM_CLKDIV_OUTDIV2_SHIFT)+1);
      SystemTimerClock   = systemClock/(((SIM->CLKDIV&SIM_CLKDIV_OUTDIV3_MASK)>>SIM_CLKDIV_OUTDIV3_SHIFT)+1);
   }

   /**
    * Get UART0 input clock frequency
    *
    * @return Clock frequency in Hz
    */
   static inline uint32_t getUart0Clock() {
      return SystemBusClock;
   }

};

/** 
 * End group SIM_Group
 * @}
 */
/**
 * @addtogroup ACMP_Group ACMP, Analogue Comparator
 * @brief Abstraction for Analogue Comparator
 * @{
 */
/**
 * Peripheral information for ACMP, Analogue Comparator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Acmp0Info {
public:
   /*
    * Template:acmp0_mke
    */
};

/**
 * Peripheral information for ACMP, Analogue Comparator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Acmp1Info {
public:
   /*
    * Template:acmp0_mke
    */
};

/** 
 * End group ACMP_Group
 * @}
 */
/**
 * @addtogroup ADC_Group ADC, Analogue Input
 * @brief Abstraction for Analogue Input
 * @{
 */
/**
 * Peripheral information for ADC, Analogue Input.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Conversion Complete Interrupt
    *
    * 
    */
   enum AdcInterrupt {
      AdcInterrupt_Disabled = ADC_SC1_AIEN(0), ///< Disabled
      AdcInterrupt_Enabled  = ADC_SC1_AIEN(1), ///< Enabled

   };

   /**
    * Continuous Conversion Enable
    *
    * Selects between single and multiple conversions.
    * Conversions are triggered by a write to the ADC_SC1 when software triggered operation is selected,
    * or following assertion of ADHWT when hardware triggered operation is selected.
    * When the FIFO function is enabled (AFDEP &amp;gt; 0), a set of conversions are triggered
    */
   enum AdcContinuous {
      AdcContinuous_Disabled = ADC_SC1_ADCO(0), ///< Single
      AdcContinuous_Enabled  = ADC_SC1_ADCO(1), ///< Continuous

   };

   /**
    * Input Channel Select
    *
    * 
    */
   enum AdcSc1Adch {
      AdcSc1Adch_Ad0               = ADC_SC1_ADCH(0),  ///< AD0
      AdcSc1Adch_Ad1               = ADC_SC1_ADCH(1),  ///< AD1
      AdcSc1Adch_Ad2               = ADC_SC1_ADCH(2),  ///< AD2
      AdcSc1Adch_Ad3               = ADC_SC1_ADCH(3),  ///< AD3
      AdcSc1Adch_Ad4               = ADC_SC1_ADCH(4),  ///< AD4
      AdcSc1Adch_Ad5               = ADC_SC1_ADCH(5),  ///< AD5
      AdcSc1Adch_Ad6               = ADC_SC1_ADCH(6),  ///< AD6
      AdcSc1Adch_Ad7               = ADC_SC1_ADCH(7),  ///< AD7
      AdcSc1Adch_Ad8               = ADC_SC1_ADCH(8),  ///< AD8
      AdcSc1Adch_Ad9               = ADC_SC1_ADCH(9),  ///< AD9
      AdcSc1Adch_Ad10              = ADC_SC1_ADCH(10), ///< AD10
      AdcSc1Adch_Ad11              = ADC_SC1_ADCH(11), ///< AD11
      AdcSc1Adch_Ad12              = ADC_SC1_ADCH(12), ///< AD12
      AdcSc1Adch_Ad13              = ADC_SC1_ADCH(13), ///< AD13
      AdcSc1Adch_Ad14              = ADC_SC1_ADCH(14), ///< AD14
      AdcSc1Adch_Ad15              = ADC_SC1_ADCH(15), ///< AD15
      AdcSc1Adch_Vss               = ADC_SC1_ADCH(16), ///< Vss
      AdcSc1Adch_TemperatureSensor = ADC_SC1_ADCH(22), ///< Temperature Sensor
      AdcSc1Adch_Bandgap           = ADC_SC1_ADCH(23), ///< Bandgap
      AdcSc1Adch_Vrefh             = ADC_SC1_ADCH(29), ///< VRefH
      AdcSc1Adch_Vrefl             = ADC_SC1_ADCH(30), ///< VRefL
      AdcSc1Adch_ModuleDisabled    = ADC_SC1_ADCH(31), ///< Module disabled

   };

   /**
    * Conversion Trigger Select
    *
    * Controls whether conversions are triggered by writes to ADC_SC1 (software) or assertion of ADHWT input (hardware)
    */
   enum AdcPretrigger {
      AdcPretrigger_SoftwareTrigger = ADC_SC2_ADTRG(0), ///< Software trigger
      AdcPretrigger_HardwareTrigger = ADC_SC2_ADTRG(1), ///< Hardware trigger

   };

   /**
    * Compare Function Enable
    *
    * 
    */
   enum AdcCompare {
      AdcCompare_Disabled           = ADC_SC2_ACFE(0)|ADC_SC2_ACFGT(0), ///< No comparison done
      AdcCompare_LessThan           = ADC_SC2_ACFE(1)|ADC_SC2_ACFGT(0), ///< ADC value < compare value
      AdcCompare_GreaterThanOrEqual = ADC_SC2_ACFE(1)|ADC_SC2_ACFGT(1), ///< ADC value >= compare value

   };

   /**
    * Voltage Reference Selection
    *
    * 
    */
   enum AdcRefSel {
      AdcRefSel_VrefhAndVrefl = ADC_SC2_REFSEL(0), ///< VREFH and VREFL
      AdcRefSel_VddaAndVssa   = ADC_SC2_REFSEL(1), ///< VDDA and VSSA
      AdcRefSel_Reserved      = ADC_SC2_REFSEL(2), ///< Reserved

   };

   /**
    * Low-Power Configuration
    *
    * Controls trade-off between speed and power consumption
    */
   enum AdcPower {
      AdcPower_Normal = ADC_SC3_ADLPC(0), ///< Normal
      AdcPower_Low    = ADC_SC3_ADLPC(1), ///< Low power

   };

   /**
    * Clock Divide Select
    *
    * 
    */
   enum AdcClockDivider {
      AdcClockDivider_DivBy1 = ADC_SC3_ADIV(0), ///< Divide by 1
      AdcClockDivider_DivBy2 = ADC_SC3_ADIV(1), ///< Divide by 2
      AdcClockDivider_DivBy4 = ADC_SC3_ADIV(2), ///< Divide by 4
      AdcClockDivider_DivBy8 = ADC_SC3_ADIV(3), ///< Divide by 8

   };

   /**
    * Sample Time Configuration
    *
    * 
    */
   enum AdcSample {
      AdcSample_Short = ADC_SC3_ADLSMP(0), ///< Short sample
      AdcSample_Long  = ADC_SC3_ADLSMP(1), ///< Long sample

   };

   /**
    * ADC resolution
    *
    * 
    */
   enum AdcResolution {
      AdcResolution_8bit_se  = ADC_SC3_MODE(0), ///< 8-bit
      AdcResolution_10bit_se = ADC_SC3_MODE(1), ///< 10-bit
      AdcResolution_12bit_se = ADC_SC3_MODE(2), ///< 12-bit

   };

   /**
    * Input Clock Select
    *
    * 
    */
   enum AdcClockSource {
      AdcClockSource_BusClock     = ADC_SC3_ADICLK(0), ///< Bus clock
      AdcClockSource_BusClockDiv2 = ADC_SC3_ADICLK(1), ///< (Bus clock)/2
      AdcClockSource_Altclk       = ADC_SC3_ADICLK(2), ///< Alternate clock (ALTCLK)
      AdcClockSource_Asynch       = ADC_SC3_ADICLK(3), ///< Asynchronous clock (ADICK)

   };

   /**
    * Hardware Trigger Multiple Conversion Enable
    *
    * This field enables hardware trigger multiple conversions in fifo mode
    */
   enum AdcSc4Htrgme {
      AdcSc4Htrgme_Single   = ADC_SC4_HTRGME(0), ///< Single
      AdcSc4Htrgme_Multiple = ADC_SC4_HTRGME(1), ///< Multiple

   };

   /**
    * FIFO Scan Mode Enable
    *
    * 
    */
   enum AdcSc4Ascane {
      AdcSc4Ascane_Disabled = ADC_SC4_ASCANE(0), ///< Disabled
      AdcSc4Ascane_Enabled  = ADC_SC4_ASCANE(1), ///< Enabled

   };

   /**
    * Compare function select OR/AND when the FIFO function is enabled (AFDEP &amp;gt; 0).
    *
    * When this field is cleared, ADC will OR all of compare triggers and set COCO after at least one of compare trigger occurs. 
    * When this field is set, ADC will AND all of compare triggers and set COCO after all of compare triggers occur
    */
   enum AdcSc4Acfsel {
      AdcSc4Acfsel_OredTriggers  = ADC_SC4_ACFSEL(0), ///< ORed triggers
      AdcSc4Acfsel_AndedTriggers = ADC_SC4_ACFSEL(1), ///< ANDed triggers

   };

   /**
    * FIFO Depth
    *
    * 
    */
   enum AdcSc4Afdep {
      AdcSc4Afdep_FifoDisabled = ADC_SC4_AFDEP(0), ///< FIFO disabled
      AdcSc4Afdep_2LevelFifo   = ADC_SC4_AFDEP(1), ///< 2-level FIFO
      AdcSc4Afdep_3LevelFifo   = ADC_SC4_AFDEP(2), ///< 3-level FIFO
      AdcSc4Afdep_4LevelFifo   = ADC_SC4_AFDEP(3), ///< 4-level FIFO
      AdcSc4Afdep_5LevelFifo   = ADC_SC4_AFDEP(4), ///< 5-level FIFO
      AdcSc4Afdep_6LevelFifo   = ADC_SC4_AFDEP(5), ///< 6-level FIFO
      AdcSc4Afdep_7LevelFifo   = ADC_SC4_AFDEP(6), ///< 7-level FIFO
      AdcSc4Afdep_8LevelFifo   = ADC_SC4_AFDEP(7), ///< 8-level FIFO

   };

   /**
    * Pin Control
    *
    * 
    */
   enum AdcApctl1Adpc {
      AdcApctl1Adpc_GpioControl = ADC_APCTL1_ADPC(0), ///< GPIO control
      AdcApctl1Adpc_AdxControl  = ADC_APCTL1_ADPC(1), ///< ADx control

   };

   /**
    * Hardware Trigger Mask Enable
    *
    * This field enables hardware trigger mask when HTRGMASKSEL is low
    */
   enum AdcSc5Htrgmaske {
      AdcSc5Htrgmaske_HardwareTriggerMaskDisable                                            = ADC_SC5_HTRGMASKE(0), ///< Hardware trigger mask disable
      AdcSc5Htrgmaske_HardwareTriggerMaskEnableAndHardwareTriggerCannotTriggerAdcConversion = ADC_SC5_HTRGMASKE(1), ///< Hardware trigger mask enable and hardware trigger cannot trigger ADC conversion

   };

   /**
    * Hardware Trigger Mask Mode Enable
    *
    * This field selects hardware trigger mask mode
    */
   enum AdcSc5Htrgmasksel {
      AdcSc5Htrgmasksel_HardwareTriggerMaskWithHtrgmaske                       = ADC_SC5_HTRGMASKSEL(0), ///< Hardware trigger mask with HTRGMASKE
      AdcSc5Htrgmasksel_HardwareTriggerMaskAutomaticallyWhenDataFifoIsNotEmpty = ADC_SC5_HTRGMASKSEL(1), ///< Hardware trigger mask automatically when data fifo is not empty

   };

   /**
    * Hardware Trigger Mode Select
    *
    * This field selects hardware trigger mode
    */
   enum AdcSc5Htrigger {
      AdcSc5Htrigger_Enabled      = ADC_SC5_HTRIGGER(0), ///< Enabled
      AdcSc5Htrigger_MaskedByFifo = ADC_SC5_HTRIGGER(1), ///< Masked by FIFO
      AdcSc5Htrigger_Disabled     = ADC_SC5_HTRIGGER(2), ///< Disabled
      AdcSc5Htrigger_Reserved     = ADC_SC5_HTRIGGER(3), ///< Reserved

   };

class Adc0BasicInfo {
   
public:
   /**
    * Type definition for Adc0 interrupt call back.
    */
   typedef void (*CallbackFunction)(uint32_t value, int channel);
   
   /**
    * Class used to do initialisation of the Adc0
    *
    * This class has a templated constructor that accepts various values.
    *
    * @note This constructor may be used to create a const instance in Flash
    *
    * Example:
    * @code
    * static const Adc0::Init init {
    *
    *   // Setup values
    *   AdcSc1Aien_Disabled                       // Conversion Complete Interrupt,
    *   AdcSc1Adco_Single                         // Continuous Conversion Enable,
    *   AdcSc1Adch_Ad0                            // Input Channel Select,
    *   AdcSc2Adtrg_SoftwareTrigger               // Conversion Trigger Select,
    *   AdcSc2Acfe_Disabled                       // Compare Function Enable,
    *   AdcSc2Acfgt_TriggerWhenInputLtLevel       // Compare Function Greater Than Enable,
    *   AdcSc2Refsel_VrefhAndVrefl                // Voltage Reference Selection,
    *   AdcSc3Adlpc_Normal                        // Low-Power Configuration,
    *   AdcSc3Adiv_DivideBy1                      // Clock Divide Select,
    *   AdcSc3Adlsmp_ShortSample                  // Sample Time Configuration,
    *   AdcSc3Mode_8Bit                           // ADC resolution,
    *   AdcSc3Adiclk_BusClock                     // Input Clock Select,
    *   AdcSc4Htrgme_Single                       // Hardware Trigger Multiple Conversion Enable,
    *   AdcSc4Ascane_Disabled                     // FIFO Scan Mode Enable,
    *   AdcSc4Acfsel_OredTriggers                 // Compare function select OR/AND when the FIFO function is enabled (AFDEP &gt; 0).,
    *   AdcSc4Afdep_FifoDisabled                  // FIFO Depth,
    *   0,                                        // Compare Value,
    *   AdcApctl1Adpc_GpioControl                 // Pin Control,
    *   AdcSc5Htrgmaske_HardwareTriggerMaskDisable    // Hardware Trigger Mask Enable,
    *   AdcSc5Htrgmasksel_HardwareTriggerMaskWithHtrgmaske    // Hardware Trigger Mask Mode Enable,
    *   AdcSc5Htrigger_Enabled                    // Hardware Trigger Mode Select,
    * };
    *
    * // Initialise Adc0 from values specified above
    * Adc0::configure(init)
    * @endcode
    */
   class Init {
   
   public:
      /**
       * Copy Constructor
       */
      constexpr Init(const Init &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr Init() = default;
   
      /// Peripheral interrupt handling
      CallbackFunction callbackFunction = nullptr;

      /// Status and Control Register 2
      uint32_t sc2 = 0;

      /// Status and Control Register 3
      uint32_t sc3 = 0;

      /// Status and Control Register 4
      uint32_t sc4 = 0;

      /// Compare Value Register
      uint32_t cv = 0;

      /// Pin Control 1 Register
      uint32_t apctl1 = 0;

      /// Status and Control Register 5
      uint32_t sc5 = 0;

      /// IRQ priority levels
      NvicPriority irqlevel = NvicPriority_Normal;
   
      /**
       * Constructor for Peripheral interrupt handling
       *
       * @tparam   Types
       * @param    rest
       * @param callbackFunction If enabled, the handler may be set using the setCallback() function or
       *        by overriding the interrupt handler method in the peripheral class
       *        If not enabled, then interrupt handlers may be installed by naming them 
       *        (see weak names used in vector table).
       */
      template <typename... Types>
      constexpr Init(CallbackFunction callbackFunction, Types... rest) : Init(rest...) {
   
         this->callbackFunction = callbackFunction;
      }

      /**
       * Constructor for IRQ priority levels
       *
       * @tparam   Types
       * @param    rest
       * @param nvicPriority Priority level used to configure the NVIC
       *        Subset of available levels
       */
      template <typename... Types>
      constexpr Init(NvicPriority nvicPriority, Types... rest) : Init(rest...) {
   
      irqlevel = nvicPriority;
      }

      /**
       * Constructor for Conversion Trigger Select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcPretrigger Controls whether conversions are triggered by writes to ADC_SC1 (software) or assertion of ADHWT input (hardware)
       */
      template <typename... Types>
      constexpr Init(AdcPretrigger adcPretrigger, Types... rest) : Init(rest...) {
   
         sc2 = (sc2&~ADC_SC2_ADTRG_MASK) | adcPretrigger;
      }
   
      /**
       * Constructor for Compare Function Enable
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcCompare 
       */
      template <typename... Types>
      constexpr Init(AdcCompare adcCompare, Types... rest) : Init(rest...) {
   
         sc2 = (sc2&~(ADC_SC2_ACFE_MASK|ADC_SC2_ACFGT_MASK)) | adcCompare;
      }
   
      /**
       * Constructor for Voltage Reference Selection
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcRefSel 
       */
      template <typename... Types>
      constexpr Init(AdcRefSel adcRefSel, Types... rest) : Init(rest...) {
   
         sc2 = (sc2&~ADC_SC2_REFSEL_MASK) | adcRefSel;
      }
   
      /**
       * Constructor for Low-Power Configuration
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcPower Controls trade-off between speed and power consumption
       */
      template <typename... Types>
      constexpr Init(AdcPower adcPower, Types... rest) : Init(rest...) {
   
         sc3 = (sc3&~ADC_SC3_ADLPC_MASK) | adcPower;
      }
   
      /**
       * Constructor for Clock Divide Select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcClockDivider 
       */
      template <typename... Types>
      constexpr Init(AdcClockDivider adcClockDivider, Types... rest) : Init(rest...) {
   
         sc3 = (sc3&~ADC_SC3_ADIV_MASK) | adcClockDivider;
      }
   
      /**
       * Constructor for Sample Time Configuration
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcSample 
       */
      template <typename... Types>
      constexpr Init(AdcSample adcSample, Types... rest) : Init(rest...) {
   
         sc3 = (sc3&~ADC_SC3_ADLSMP_MASK) | adcSample;
      }
   
      /**
       * Constructor for ADC resolution
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcResolution 
       */
      template <typename... Types>
      constexpr Init(AdcResolution adcResolution, Types... rest) : Init(rest...) {
   
         sc3 = (sc3&~ADC_SC3_MODE_MASK) | adcResolution;
      }
   
      /**
       * Constructor for Input Clock Select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcClockSource 
       */
      template <typename... Types>
      constexpr Init(AdcClockSource adcClockSource, Types... rest) : Init(rest...) {
   
         sc3 = (sc3&~ADC_SC3_ADICLK_MASK) | adcClockSource;
      }
   
      /**
       * Constructor for Hardware Trigger Multiple Conversion Enable
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcSc4Htrgme This field enables hardware trigger multiple conversions in fifo mode
       */
      template <typename... Types>
      constexpr Init(AdcSc4Htrgme adcSc4Htrgme, Types... rest) : Init(rest...) {
   
         sc4 = (sc4&~ADC_SC4_HTRGME_MASK) | adcSc4Htrgme;
      }
   
      /**
       * Constructor for FIFO Scan Mode Enable
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcSc4Ascane 
       */
      template <typename... Types>
      constexpr Init(AdcSc4Ascane adcSc4Ascane, Types... rest) : Init(rest...) {
   
         sc4 = (sc4&~ADC_SC4_ASCANE_MASK) | adcSc4Ascane;
      }
   
      /**
       * Constructor for Compare function select OR/AND when the FIFO function is enabled (AFDEP > 0).
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcSc4Acfsel When this field is cleared, ADC will OR all of compare triggers and set COCO after at least one of compare trigger occurs. 
       *        When this field is set, ADC will AND all of compare triggers and set COCO after all of compare triggers occur
       */
      template <typename... Types>
      constexpr Init(AdcSc4Acfsel adcSc4Acfsel, Types... rest) : Init(rest...) {
   
         sc4 = (sc4&~ADC_SC4_ACFSEL_MASK) | adcSc4Acfsel;
      }
   
      /**
       * Constructor for FIFO Depth
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcSc4Afdep 
       */
      template <typename... Types>
      constexpr Init(AdcSc4Afdep adcSc4Afdep, Types... rest) : Init(rest...) {
   
         sc4 = (sc4&~ADC_SC4_AFDEP_MASK) | adcSc4Afdep;
      }
   
      /**
       * Constructor for Pin Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcApctl1Adpc 
       */
      template <typename... Types>
      constexpr Init(AdcApctl1Adpc adcApctl1Adpc, Types... rest) : Init(rest...) {
   
         apctl1 = (apctl1&~ADC_APCTL1_ADPC_MASK) | adcApctl1Adpc;
      }
   
      /**
       * Constructor for Hardware Trigger Mask Enable
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcSc5Htrgmaske This field enables hardware trigger mask when HTRGMASKSEL is low
       */
      template <typename... Types>
      constexpr Init(AdcSc5Htrgmaske adcSc5Htrgmaske, Types... rest) : Init(rest...) {
   
         sc5 = (sc5&~ADC_SC5_HTRGMASKE_MASK) | adcSc5Htrgmaske;
      }
   
      /**
       * Constructor for Hardware Trigger Mask Mode Enable
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcSc5Htrgmasksel This field selects hardware trigger mask mode
       */
      template <typename... Types>
      constexpr Init(AdcSc5Htrgmasksel adcSc5Htrgmasksel, Types... rest) : Init(rest...) {
   
         sc5 = (sc5&~ADC_SC5_HTRGMASKSEL_MASK) | adcSc5Htrgmasksel;
      }
   
      /**
       * Constructor for Hardware Trigger Mode Select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param adcSc5Htrigger This field selects hardware trigger mode
       */
      template <typename... Types>
      constexpr Init(AdcSc5Htrigger adcSc5Htrigger, Types... rest) : Init(rest...) {
   
         sc5 = (sc5&~ADC_SC5_HTRIGGER_MASK) | adcSc5Htrigger;
      }
   
      /**
       * Constructor for Compare Value
       *
       * @tparam   Types
       * @param    rest
       *
       * @param value Compare Value
       */
      template <typename... Types>
      constexpr Init(uint32_t value, Types... rest) : Init(rest...) {
   
         cv = (cv&~ADC_CV_CV_MASK) | ADC_CV_CV(value);
      }
   
   }; // Adc0BasicInfo::Init

}; // Adc0BasicInfo

class Adc0Info {
public:
   /*
    * Template:adc0_mke04
    */
   /* Template _enablePeripheral  */
   
   //! Configure peripheral in start-up
   static constexpr bool configurePeripheralInStartUp = false;

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = ADC0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = true;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_Normal;

   /* Template _enablePeripheral  */
   
   /**
    *  Enable clock to Adc0
    */
   static void enableClock() {
      SIM->SCGC = SIM->SCGC | SIM_SCGC_ADC0_MASK;
   }

   /**
    *  Disable clock to Adc0
    */
   static void disableClock() {
      SIM->SCGC = SIM->SCGC & ~SIM_SCGC_ADC0_MASK;
   }

   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = ADC0_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<ADC_Type> adc = baseAddress;
   
   /**
    * Set Conversion Trigger Select
    *
    * @param adcPretrigger Controls whether conversions are triggered by writes to ADC_SC1 (software) or assertion of ADHWT input (hardware)
    */
   static void configurePretrigger(AdcPretrigger adcPretrigger) {
      adc->SC2 = (adc->SC2&~ADC_SC2_ADTRG_MASK) | adcPretrigger;
   }

   /**
    * Set Compare Function Enable
    *
    * @param adcCompare 
    */
   static void configureCompare(AdcCompare adcCompare) {
      adc->SC2 = (adc->SC2&~(ADC_SC2_ACFE_MASK|ADC_SC2_ACFGT_MASK)) | adcCompare;
   }

   /**
    * Set Voltage Reference Selection
    *
    * @param adcRefSel 
    */
   static void configureRefSel(AdcRefSel adcRefSel) {
      adc->SC2 = (adc->SC2&~ADC_SC2_REFSEL_MASK) | adcRefSel;
   }

   /**
    * Set Low-Power Configuration
    *
    * @param adcPower Controls trade-off between speed and power consumption
    */
   static void configurePower(AdcPower adcPower) {
      adc->SC3 = (adc->SC3&~ADC_SC3_ADLPC_MASK) | adcPower;
   }

   /**
    * Set Clock Divide Select
    *
    * @param adcClockDivider 
    */
   static void configureClockDivider(AdcClockDivider adcClockDivider) {
      adc->SC3 = (adc->SC3&~ADC_SC3_ADIV_MASK) | adcClockDivider;
   }

   /**
    * Set Sample Time Configuration
    *
    * @param adcSample 
    */
   static void configureSample(AdcSample adcSample) {
      adc->SC3 = (adc->SC3&~ADC_SC3_ADLSMP_MASK) | adcSample;
   }

   /**
    * Set ADC resolution
    *
    * @param adcResolution 
    */
   static void configureResolution(AdcResolution adcResolution) {
      adc->SC3 = (adc->SC3&~ADC_SC3_MODE_MASK) | adcResolution;
   }

   /**
    * Set Input Clock Select
    *
    * @param adcClockSource 
    */
   static void configureClockSource(AdcClockSource adcClockSource) {
      adc->SC3 = (adc->SC3&~ADC_SC3_ADICLK_MASK) | adcClockSource;
   }

   /**
    * Set Hardware Trigger Multiple Conversion Enable
    *
    * @param adcSc4Htrgme This field enables hardware trigger multiple conversions in fifo mode
    */
   static void configureSc4Htrgme(AdcSc4Htrgme adcSc4Htrgme) {
      adc->SC4 = (adc->SC4&~ADC_SC4_HTRGME_MASK) | adcSc4Htrgme;
   }

   /**
    * Set FIFO Scan Mode Enable
    *
    * @param adcSc4Ascane 
    */
   static void configureSc4Ascane(AdcSc4Ascane adcSc4Ascane) {
      adc->SC4 = (adc->SC4&~ADC_SC4_ASCANE_MASK) | adcSc4Ascane;
   }

   /**
    * Set Compare function select OR/AND when the FIFO function is enabled (AFDEP > 0).
    *
    * @param adcSc4Acfsel When this field is cleared, ADC will OR all of compare triggers and set COCO after at least one of compare trigger occurs. 
    *        When this field is set, ADC will AND all of compare triggers and set COCO after all of compare triggers occur
    */
   static void configureSc4Acfsel(AdcSc4Acfsel adcSc4Acfsel) {
      adc->SC4 = (adc->SC4&~ADC_SC4_ACFSEL_MASK) | adcSc4Acfsel;
   }

   /**
    * Set FIFO Depth
    *
    * @param adcSc4Afdep 
    */
   static void configureSc4Afdep(AdcSc4Afdep adcSc4Afdep) {
      adc->SC4 = (adc->SC4&~ADC_SC4_AFDEP_MASK) | adcSc4Afdep;
   }

   /**
    * Set Pin Control
    *
    * @param adcApctl1Adpc 
    */
   static void configureApctl1Adpc(AdcApctl1Adpc adcApctl1Adpc) {
      adc->APCTL1 = (adc->APCTL1&~ADC_APCTL1_ADPC_MASK) | adcApctl1Adpc;
   }

   /**
    * Set Hardware Trigger Mask Enable
    *
    * @param adcSc5Htrgmaske This field enables hardware trigger mask when HTRGMASKSEL is low
    */
   static void configureSc5Htrgmaske(AdcSc5Htrgmaske adcSc5Htrgmaske) {
      adc->SC5 = (adc->SC5&~ADC_SC5_HTRGMASKE_MASK) | adcSc5Htrgmaske;
   }

   /**
    * Set Hardware Trigger Mask Mode Enable
    *
    * @param adcSc5Htrgmasksel This field selects hardware trigger mask mode
    */
   static void configureSc5Htrgmasksel(AdcSc5Htrgmasksel adcSc5Htrgmasksel) {
      adc->SC5 = (adc->SC5&~ADC_SC5_HTRGMASKSEL_MASK) | adcSc5Htrgmasksel;
   }

   /**
    * Set Hardware Trigger Mode Select
    *
    * @param adcSc5Htrigger This field selects hardware trigger mode
    */
   static void configureSc5Htrigger(AdcSc5Htrigger adcSc5Htrigger) {
      adc->SC5 = (adc->SC5&~ADC_SC5_HTRIGGER_MASK) | adcSc5Htrigger;
   }

   /**
    * Class used to do initialisation of the Adc0
    *
    * This class has a templated constructor that accepts various values.
    *
    * @note This constructor may be used to create a const instance in Flash
    *
    * Example:
    * @code
    * static const Adc0::Init init {
    *
    *   // Setup values
    *   AdcSc1Aien_Disabled                       // Conversion Complete Interrupt,
    *   AdcSc1Adco_Single                         // Continuous Conversion Enable,
    *   AdcSc1Adch_Ad0                            // Input Channel Select,
    *   AdcSc2Adtrg_SoftwareTrigger               // Conversion Trigger Select,
    *   AdcSc2Acfe_Disabled                       // Compare Function Enable,
    *   AdcSc2Acfgt_TriggerWhenInputLtLevel       // Compare Function Greater Than Enable,
    *   AdcSc2Refsel_VrefhAndVrefl                // Voltage Reference Selection,
    *   AdcSc3Adlpc_Normal                        // Low-Power Configuration,
    *   AdcSc3Adiv_DivideBy1                      // Clock Divide Select,
    *   AdcSc3Adlsmp_ShortSample                  // Sample Time Configuration,
    *   AdcSc3Mode_8Bit                           // ADC resolution,
    *   AdcSc3Adiclk_BusClock                     // Input Clock Select,
    *   AdcSc4Htrgme_Single                       // Hardware Trigger Multiple Conversion Enable,
    *   AdcSc4Ascane_Disabled                     // FIFO Scan Mode Enable,
    *   AdcSc4Acfsel_OredTriggers                 // Compare function select OR/AND when the FIFO function is enabled (AFDEP &gt; 0).,
    *   AdcSc4Afdep_FifoDisabled                  // FIFO Depth,
    *   0,                                        // Compare Value,
    *   AdcApctl1Adpc_GpioControl                 // Pin Control,
    *   AdcSc5Htrgmaske_HardwareTriggerMaskDisable    // Hardware Trigger Mask Enable,
    *   AdcSc5Htrgmasksel_HardwareTriggerMaskWithHtrgmaske    // Hardware Trigger Mask Mode Enable,
    *   AdcSc5Htrigger_Enabled                    // Hardware Trigger Mode Select,
    * };
    *
    * // Initialise Adc0 from values specified above
    * Adc0::configure(init)
    * @endcode
    */
   typedef Adc0BasicInfo::Init Init;
   
   /**
    * Default initialisation value for Adc0
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr Init DefaultInitValue = {
      AdcPretrigger_SoftwareTrigger , // Conversion Trigger Select - Software trigger
      AdcCompare_Disabled , // Compare Function Enable - No comparison done
      AdcRefSel_VrefhAndVrefl , // Voltage Reference Selection - VREFH and VREFL
      AdcPower_Normal , // Low-Power Configuration - Normal
      AdcClockDivider_DivBy1 , // Clock Divide Select - Divide by 1
      AdcSample_Short , // Sample Time Configuration - Short sample
      AdcResolution_8bit_se , // ADC resolution - 8-bit
      AdcClockSource_BusClock , // Input Clock Select - Bus clock
      AdcSc4Htrgme_Single , // Hardware Trigger Multiple Conversion Enable - Single
      AdcSc4Ascane_Disabled , // FIFO Scan Mode Enable - Disabled
      AdcSc4Acfsel_OredTriggers , // Compare function select OR/AND when the FIFO function is enabled (AFDEP &gt; 0). - ORed triggers
      AdcSc4Afdep_FifoDisabled , // FIFO Depth - FIFO disabled
      AdcApctl1Adpc_GpioControl , // Pin Control - GPIO control
      AdcSc5Htrgmaske_HardwareTriggerMaskDisable , // Hardware Trigger Mask Enable - Hardware trigger mask disable
      AdcSc5Htrgmasksel_HardwareTriggerMaskWithHtrgmaske , // Hardware Trigger Mask Mode Enable - Hardware trigger mask with HTRGMASKE
      AdcSc5Htrigger_Enabled,  // Hardware Trigger Mode Select - Enabled
   };

   /** Internal ADC clock */
   static constexpr unsigned adiclk = 8000000;
   
   /**
    * Set Input Clock Select
    *
    * @param adcClockSource 
    */
   static void setClockout(AdcClockSource adcClockSource) {
      adc->SC3 = (adc->SC3&~ADC_SC3_ADICLK_MASK) | adcClockSource;
   }
   
   /**
    * Get Input Clock Select
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getClockFrequency(AdcClockSource adcClockSource) {
   
      switch(adcClockSource) {
         default: return 0;
         case AdcClockSource_BusClock     : return SystemBusClock;          ///< Bus clock
         case AdcClockSource_BusClockDiv2 : return SystemBusClock/2;        ///< (Bus clock)/2
         case AdcClockSource_Altclk       : return Osc0Info::getOscClock(); ///< Alternate clock (ALTCLK)
         case AdcClockSource_Asynch       : return adiclk;                  ///< Asynchronous clock (ADICK)

      }
   }
   
   /**
    * Get clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static uint32_t getClockFrequency() {
      return getClockFrequency((AdcClockSource)(adc->SC3&ADC_SC3_ADICLK_MASK));
   }; 

};

/** 
 * End group ADC_Group
 * @}
 */
/**
 * @addtogroup Control_Group CONTROL, Control
 * @brief Abstraction for Control
 * @{
 */
/**
 * Peripheral information for CONTROL, Control.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class ControlInfo {
public:
   /*
    * Template:control
    */

};

/** 
 * End group Control_Group
 * @}
 */
/**
 * @addtogroup CRC_Group CRC, Cyclic Redundancy Check
 * @brief Abstraction for Cyclic Redundancy Check
 * @{
 */
/**
 * Peripheral information for CRC, Cyclic Redundancy Check.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Crc0Info {
public:
   /*
    * Template:crc0_0x40032000
    */
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = CRC0_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<CRC_Type> crc = baseAddress;
   
   //! Peripheral instance number
   static constexpr unsigned instance = 0;
   
   static constexpr uint32_t gpoly =  0;

   /**
    *  Enable clock to Crc0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableCrc0Clock();
#else
      SIM->SCGC = SIM->SCGC | SIM_SCGC_CRC_MASK;
#endif
   }

   /**
    *  Disable clock to Crc0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableCrc0Clock();
#else
      SIM->SCGC = SIM->SCGC & ~SIM_SCGC_CRC_MASK;
#endif
   }

};

/** 
 * End group CRC_Group
 * @}
 */
/**
 * @addtogroup CONSOLE_Group Console, Console Interface
 * @brief Abstraction for Console Interface
 * @{
 */
/** 
 * End group CONSOLE_Group
 * @}
 */
/**
 * @addtogroup FTM_Group FTM, PWM, Input capture and Output compare
 * @brief Abstraction for PWM, Input capture and Output compare
 * @{
 */
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class FtmInfo {
public:
   /*
    * Template:ftm
    */

};

/**
 * Peripheral information for FTM, PWM, Input capture and Output compare.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Ftm0Info {
public:
   /*
    * Template:ftm0_2ch_mke
    */
};

/**
 * Peripheral information for FTM, PWM, Input capture and Output compare.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Ftm2Info {
public:
   /*
    * Template:ftm2_6ch_mke
    */
};

/** 
 * End group FTM_Group
 * @}
 */
/**
 * @addtogroup I2C_Group I2C, Inter-Integrated-Circuit Interface
 * @brief Abstraction for Inter-Integrated-Circuit Interface
 * @{
 */
/**
 * Peripheral information for I2C, Inter-Integrated-Circuit Interface.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class I2c0Info {
public:
   /*
    * Template:i2c0_mke
    */
};

/** 
 * End group I2C_Group
 * @}
 */
/**
 * @addtogroup ICS_Group ICS, Multipurpose Clock Generator
 * @brief Abstraction for Multipurpose Clock Generator
 * @{
 */
/**
 * Peripheral information for ICS, Multipurpose Clock Generator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * ICS Clock Mode
    *
    * FLL Engaged Internal(FEI)
    * In FEI mode, ICSOUT is derived from the FLL clock (DCOCLK) that is controlled by the Internal Reference Clock (IRC).
    * The FLL loop will lock the DCO frequency to the FLL factor (1280) times the internal reference frequency.
    * 
    * FLL Engaged External(FEE)
    * In FEE mode, ICSOUT is derived from the FLL clock (DCOCLK) that is controlled by the external reference clock. The FLL loop
    * will lock the DCO frequency to the FLL factor (1280) times the external reference frequency, as specified by the C1[RDIV] and                      OSC.C2[RANGE].
    * 
    * FLL Bypassed Internal(FBI)
    * In FBI mode, the ICSOUT clock is derived either from the internal reference clock,
    * as selected by the C2[IRCS] bit. The FLL is operational but its output is not used. This mode is useful to allow the FLL
    * to acquire its target frequency while the ICSOUT clock is driven from the C2[IRCS] selected internal reference clock. The
    * FLL clock (DCOCLK) is controlled by the internal reference clock, and the DCO clock frequency locks to a multiplication
    * factor (1280) times the internal reference frequency.
    * 
    * FLL Bypassed External(FBE)
    * In FBE mode, the ICSOUT clock is derived from the external reference clock. The FLL is operational but its output is not
    * used. This mode is useful to allow the FLL to acquire its target frequency while the ICSOUT clock is driven from the
    * external reference clock. The FLL clock (DCOCLK) is controlled by the external reference clock, and the DCO clock frequency
    * locks to a multiplication factor (1280) times the divided external reference
    * frequency.
    * 
    * FLL bypassed internal low power (FBILP)
    * In FBILP mode, ICSOUT is derived from the internal reference clock. The FLL is disabled
    * 
    * FLL bypassed external low power (FBELP)
    * In FBELP mode, ICSOUT is derived from the external reference clock. The FLL is disabled

    */
   enum IcsClockMode : uint8_t {
      IcsClockMode_FEI   = 0, ///< FLL Engaged Internal (FEI)
      IcsClockMode_FEE   = 1, ///< FLL Engaged External (FEE)
      IcsClockMode_FBI   = 2, ///< FLL bypassed internal (FBI)
      IcsClockMode_FBE   = 4, ///< FLL bypassed external (FBE)
      IcsClockMode_FBILP = 3, ///< FLL bypassed low power internal (FBILP)
      IcsClockMode_FBELP = 5, ///< FLL bypassed low power external (FBELP)

   };

   /**
    * Clock Monitor Enable
    *
    * Determines if a reset request is made following a loss of external clock indication.
    * The CME0 bit must only be when using an external clock mode (FEE, FBE, or FBELP)
    */
   enum IcsClockMonitor {
      IcsClockMonitor_Disabled = ICS_C4_CME(0), ///< Clock monitor disabled
      IcsClockMonitor_Enabled  = ICS_C4_CME(1), ///< Clock monitor enabled

   };

   /**
    * Loss of Lock Interrupt Enable
    *
    * Determines if an interrupt request is made following a loss of lock.
    * This is indicated by ICS_S[LOLS] being set.
    */
   enum IcsLossOfLockInterrupt {
      IcsLossOfLockInterrupt_Disabled = ICS_C4_LOLIE0(0), ///< Interrupt disabled
      IcsLossOfLockInterrupt_Enabled  = ICS_C4_LOLIE0(1), ///< Interrupt enabled

   };

   /**
    * Internal Reference Clock [ICSIRCLK]
    *
    * Enables the internal reference clock for use by peripherals
    */
   enum IcsIrClkEn {
      IcsIrClkEn_Disabled = ICS_C1_IRCLKEN(0), ///< Disabled
      IcsIrClkEn_Enabled  = ICS_C1_IRCLKEN(1), ///< Enabled

   };

   /**
    * Internal Reference [ICSIRCLK] Stop Enable
    *
    * Controls whether or not the internal reference clock remains enabled when the ICS enters Stop mode.
    * (only if IRCLKEN is set or if ICS is in FEI, FBI, or FBILP modes before entering Stop mode)
    */
   enum IcsIrefs {
      IcsIrefs_DisabledInStop = ICS_C1_IREFSTEN(0), ///< IR disabled in STOP
      IcsIrefs_EnabledInStop  = ICS_C1_IREFSTEN(1), ///< IR enabled in STOP

   };

   /**
    * FLL External Reference Divider
    *
    * Selects the amount to divide down the external reference clock for the FLL.
    * The resulting frequency must be in [31.25 kHz to 39.0625 kHz] to be suitable for the FLL
    * Division factors choices depends on clock Range [OSC_C2_RANGE]
    */
   enum IcsFllPrescale {
      IcsFllPrescale_Disabled      = ICS_C1_RDIV(0), ///< Disabled
      IcsFllPrescale_LowDivBy1     = ICS_C1_RDIV(0), ///< /1 (low)
      IcsFllPrescale_LowDivBy2     = ICS_C1_RDIV(1), ///< /2 (low)
      IcsFllPrescale_LowDivBy3     = ICS_C1_RDIV(2), ///< /4 (low)
      IcsFllPrescale_LowDivBy8     = ICS_C1_RDIV(3), ///< /8 (low)
      IcsFllPrescale_LowDivBy16    = ICS_C1_RDIV(4), ///< /16 (low)
      IcsFllPrescale_LowDivBy32    = ICS_C1_RDIV(5), ///< /32 (low)
      IcsFllPrescale_LowDivBy64    = ICS_C1_RDIV(6), ///< /64 (low)
      IcsFllPrescale_LowDivBy128   = ICS_C1_RDIV(7), ///< /128 (low)
      IcsFllPrescale_HighDivBy32   = ICS_C1_RDIV(0), ///< /32 (high)
      IcsFllPrescale_HighDivBy64   = ICS_C1_RDIV(1), ///< /64 (high)
      IcsFllPrescale_HighDivBy128  = ICS_C1_RDIV(2), ///< /128 (high)
      IcsFllPrescale_HighDivBy256  = ICS_C1_RDIV(3), ///< /256 (high)
      IcsFllPrescale_HighDivBy512  = ICS_C1_RDIV(4), ///< /512 (high)
      IcsFllPrescale_HighDivBy1024 = ICS_C1_RDIV(5), ///< /1024 (high)
      IcsFllPrescale_Reserved6     = ICS_C1_RDIV(6), ///< Reserved
      IcsFllPrescale_Reserved7     = ICS_C1_RDIV(7), ///< Reserved

   };

   /**
    * Internal Reference Select
    *
    * Selects the reference clock source for the FLL
    * This option is determined by the Clock Mode selection
    */
   enum IcsIref {
      IcsIref_External = ICS_C1_IREFS(0), ///< External Reference Clock
      IcsIref_Internal = ICS_C1_IREFS(1), ///< Internal Reference Clock

   };

   /**
    * ICSOUTCLK Clock Source Select
    *
    * Selects the clock source for ICSOUTCLK
    * This option is determined by the Clock Mode selection
    */
   enum IcsClkSrc {
      IcsClkSrc_Fll  = ICS_C1_CLKS(0), ///< Output of FLL
      IcsClkSrc_Iref = ICS_C1_CLKS(1), ///< Internal reference clock
      IcsClkSrc_Eref = ICS_C1_CLKS(2), ///< External reference clock

   };

   /**
    * Bus Frequency Divider
    *
    * This value can not be written or read back in some devices
    */
   enum IcsBusDivider {
      IcsBusDivider_DivideBy1   = ICS_C2_BDIV(0), ///< Divide by 1
      IcsBusDivider_DivideBy2   = ICS_C2_BDIV(1), ///< Divide by 2
      IcsBusDivider_DivideBy4   = ICS_C2_BDIV(2), ///< Divide by 4
      IcsBusDivider_DivideBy8   = ICS_C2_BDIV(3), ///< Divide by 8
      IcsBusDivider_DivideBy16  = ICS_C2_BDIV(4), ///< Divide by 16
      IcsBusDivider_DivideBy32  = ICS_C2_BDIV(5), ///< Divide by 32
      IcsBusDivider_DivideBy64  = ICS_C2_BDIV(6), ///< Divide by 64
      IcsBusDivider_DivideBy128 = ICS_C2_BDIV(7), ///< Divide by 128

   };

   /**
    * Low Power Select
    *
    * Whether FLL continues operation when bypassed
    * This option is determined by the Clock Mode selection
    */
   enum IcsFllInLowpower {
      IcsFllInLowpower_Enabled  = ICS_C2_LP(0), ///< FLL is enabled in bypass modes
      IcsFllInLowpower_Disabled = ICS_C2_LP(1), ///< FLL is disabled in bypass modes

   };

class IcsBasicInfo {
   
public:
}; // Ics::BasicInfo

class IcsInfo {
public:
   /*
    * Template:ics_mke
    */
   /* Template _enablePeripheral  */
   
   //! Configure peripheral in start-up
   static constexpr bool configurePeripheralInStartUp = false;

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = ICS_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_Normal;

   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = ICS_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<ICS_Type> ics = baseAddress;
   
   /**
    * Get IC External reference clock
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getExternalReferenceClock() {
   
      return Osc0Info::getOscClock();
   }

   //! ICS Internal Reference Clock
   static constexpr unsigned icsirclk = 37500;
   
   /**
    * Set Internal Reference Clock [ICSIRCLK]
    *
    * @param icsIrClkEn Enables the internal reference clock for use by peripherals
    */
   static void enableIcsIrClock(IcsIrClkEn icsIrClkEn) {
      ics->C1 = (ics->C1&~ICS_C1_IRCLKEN_MASK) | icsIrClkEn;
   }

   /**
    * Get Internal Reference Clock [ICSIRCLK]
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getUngatedInternalReferenceClock() {
      return icsirclk;
   }

   /**
    * Get Internal Reference Clock [ICSIRCLK]
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getInternalReferenceClock() {
   
      switch(ics->C1&ICS_C1_IRCLKEN_MASK) {
         default: return 0;
         case IcsIrClkEn_Disabled : return 0;        ///< Disabled
         case IcsIrClkEn_Enabled  : return icsirclk; ///< Enabled

      }
   }

   /**
    * Set ICSOUTCLK Clock Source Select
    *
    * @param icsClkSrc Selects the clock source for ICSOUTCLK
    *        This option is determined by the Clock Mode selection
    */
   static void configureC1Clks(IcsClkSrc icsClkSrc) {
      ics->C1 = (ics->C1&~ICS_C1_CLKS_MASK) | icsClkSrc;
   }

   /**
    * Set FLL External Reference Divider
    *
    * @param icsFllPrescale Selects the amount to divide down the external reference clock for the FLL.
    *        The resulting frequency must be in [31.25 kHz to 39.0625 kHz] to be suitable for the FLL
    *        Division factors choices depends on clock Range [OSC_C2_RANGE]
    */
   static void configureC1Rdiv(IcsFllPrescale icsFllPrescale) {
      ics->C1 = (ics->C1&~ICS_C1_RDIV_MASK) | icsFllPrescale;
   }

   /**
    * Set Internal Reference Select
    *
    * @param icsIref Selects the reference clock source for the FLL
    *        This option is determined by the Clock Mode selection
    */
   static void configureC1Irefs(IcsIref icsIref) {
      ics->C1 = (ics->C1&~ICS_C1_IREFS_MASK) | icsIref;
   }

   /**
    * Set Internal Reference Clock [ICSIRCLK]
    *
    * @param icsIrClkEn Enables the internal reference clock for use by peripherals
    */
   static void configureC1Irclken(IcsIrClkEn icsIrClkEn) {
      ics->C1 = (ics->C1&~ICS_C1_IRCLKEN_MASK) | icsIrClkEn;
   }

   /**
    * Set Internal Reference [ICSIRCLK] Stop Enable
    *
    * @param icsIrefs Controls whether or not the internal reference clock remains enabled when the ICS enters Stop mode.
    *        (only if IRCLKEN is set or if ICS is in FEI, FBI, or FBILP modes before entering Stop mode)
    */
   static void configureC1Irefsten(IcsIrefs icsIrefs) {
      ics->C1 = (ics->C1&~ICS_C1_IREFSTEN_MASK) | icsIrefs;
   }

   /**
    * Set Bus Frequency Divider
    *
    * @param icsBusDivider This value can not be written or read back in some devices
    */
   static void configureC2Bdiv(IcsBusDivider icsBusDivider) {
      ics->C2 = (ics->C2&~ICS_C2_BDIV_MASK) | icsBusDivider;
   }

   /**
    * Set Low Power Select
    *
    * @param icsFllInLowpower Whether FLL continues operation when bypassed
    *        This option is determined by the Clock Mode selection
    */
   static void configureC2Lp(IcsFllInLowpower icsFllInLowpower) {
      ics->C2 = (ics->C2&~ICS_C2_LP_MASK) | icsFllInLowpower;
   }

   /**
    * Set Loss of Lock Interrupt Enable
    *
    * @param icsLossOfLockInterrupt Determines if an interrupt request is made following a loss of lock.
    *        This is indicated by ICS_S[LOLS] being set.
    */
   static void configureC4Lolie0(IcsLossOfLockInterrupt icsLossOfLockInterrupt) {
      ics->C4 = (ics->C4&~ICS_C4_LOLIE0_MASK) | icsLossOfLockInterrupt;
   }

   /**
    * Set Clock Monitor Enable
    *
    * @param icsClockMonitor Determines if a reset request is made following a loss of external clock indication.
    *        The CME0 bit must only be when using an external clock mode (FEE, FBE, or FBELP)
    */
   static void configureC4Cme(IcsClockMonitor icsClockMonitor) {
      ics->C4 = (ics->C4&~ICS_C4_CME_MASK) | icsClockMonitor;
   }

};

/** 
 * End group ICS_Group
 * @}
 */
/**
 * @addtogroup IRQ_Group IRQ, Direct Memory Access (DMA)
 * @brief Abstraction for Direct Memory Access (DMA)
 * @{
 */
/**
 * Peripheral information for IRQ, Direct Memory Access (DMA).
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class IrqInfo {
public:
   /*
    * Template:irq_mke
    */
};

/** 
 * End group IRQ_Group
 * @}
 */
/**
 * @addtogroup KBI_Group KBI, LCD, Segment LCD
 * @brief Abstraction for LCD, Segment LCD
 * @{
 */
/**
 * Peripheral information for KBI, LCD, Segment LCD.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Kbi0Info {
public:
   /*
    * Template:kbi0_mke02
    */
};

/**
 * Peripheral information for KBI, LCD, Segment LCD.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Kbi1Info {
public:
   /*
    * Template:kbi0_mke02
    */
};

/** 
 * End group KBI_Group
 * @}
 */
/**
 * @addtogroup PIT_Group PIT, Programmable Interrupt Timer
 * @brief Abstraction for Programmable Interrupt Timer
 * @{
 */
/**
 * Peripheral information for PIT, Programmable Interrupt Timer.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Pit Channel Number
    *
    * Selected PIT channel
    */
   enum PitChannelNum : uint8_t {
      PitChannelNum_0    = 0,          ///< Channel 0
      PitChannelNum_1    = 1,          ///< Channel 1
      PitChannelNum_2    = 2,          ///< Channel 2
      PitChannelNum_3    = 3,          ///< Channel 3
      PitChannelNum_None = 0b10000000, ///< Channel Not Allocated

   };

   /**
    * Module Disable
    *
    * Disabled PIT module clock
    */
   enum PitMcrMdis {
      PitMcrMdis_ClockEnabled  = PIT_MCR_MDIS(0), ///< Clock enabled
      PitMcrMdis_ClockDisabled = PIT_MCR_MDIS(1), ///< Clock disabled

   };

   /**
    * Freeze in Debug
    *
    * Determines if timers are stopped in Debug mode
    */
   enum PitDebugMode {
      PitDebugMode_Run    = PIT_MCR_FRZ(0), ///< Timers run in Debug
      PitDebugMode_Freeze = PIT_MCR_FRZ(1), ///< Timers stop in Debug

   };

   /**
    * Timer Channel Enable
    *
    * Allows operation of this channel
    */
   enum PitChannelEnable {
      PitChannelEnable_Disabled = PIT_TCTRL_TEN(0), ///< Channel disabled
      PitChannelEnable_Enabled  = PIT_TCTRL_TEN(1), ///< Channel enabled

   };

   /**
    * Timer Interrupt Enable
    *
    * Allows interrupts from this channel
    */
   enum PitChannelIrq {
      PitChannelIrq_Disabled = PIT_TCTRL_TIE(0), ///< Interrupts are disabled
      PitChannelIrq_Enabled  = PIT_TCTRL_TIE(1), ///< Interrupts are enabled

   };

   /**
    * Chain with previous channel
    *
    * Controls whether the timer channels are chained to create a larger counter
    */
   enum PitChannelChain {
      PitChannelChain_Disabled = PIT_TCTRL_CHN(0), ///< Timers are not chained
      PitChannelChain_Enabled  = PIT_TCTRL_CHN(1), ///< Timers are chained

   };

class PitBasicInfo {
   
public:
   /**
    * Type definition for Pit interrupt call back.
    */
   typedef void (*CallbackFunction)();
   
   /**
    * Class used to do initialisation of a Pit channel
    *
    * This class has a templated constructor that accepts various values:
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * // Initialisation values for Pit channel
    * // Parameters available may vary with device - see Pit::DefaultChannelInitValues[] for relevant example
    * static const Pit::ChannelInit pitInit {
    *       PitChannelNum_0,
    *
    *       PitChannelEnable_Enabled , // Timer Channel Enable - Channel enabled
    *       PitChannelChain_Disabled , // Chain with previous channel - Timers are not chained
    *       PitChannelIrq_Disabled ,   // Timer Interrupt Enable - Interrupts are disabled
    *       callBackFunction,          // Call-back function to use
    *       NvicPriority_Normal ,      // IRQ level for this peripheral - Normal
    *       3999_ticks,                // Reload value for channel (in ticks or seconds)
    *
    *       Pit::DefaultChannelInitValues[1], // An existing declaration may be referenced as the last item
    *                                            This becomes a base value modified by earlier values.
    * };
    *
    * // Initialise PIT channel from values specified above
    * Pit::configure(pitInit)
    * @endcode
    */
   class ChannelInit {
   
   public:
      /**
       * Copy Constructor
       */
      constexpr ChannelInit(const ChannelInit &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr ChannelInit() = default;
   
      /// Peripheral interrupt handling
      CallbackFunction callbackFunction = nullptr;

      /// Reload value channel 0
      Ticks ldval = 0_ticks;

      /// Timer Control Register
      uint8_t tctrl = 0;

      /// IRQ priority levels
      NvicPriority irqlevel = NvicPriority_Normal;
   
      /// Pit Channel Number
      PitChannelNum channelnumber = PitChannelNum_None;

      /**
       * Constructor for Peripheral interrupt handling
       *
       * @tparam   Types
       * @param    rest
       * @param callbackFunction If enabled, the handler may be set using the setCallback() function or
       *        by overriding the interrupt handler method in the peripheral class
       *        If not enabled, then interrupt handlers may be installed by naming them 
       *        (see weak names used in vector table).
       */
      template <typename... Types>
      constexpr ChannelInit(CallbackFunction callbackFunction, Types... rest) : ChannelInit(rest...) {
   
         this->callbackFunction = callbackFunction;
      }

      /**
       * Constructor for IRQ priority levels
       *
       * @tparam   Types
       * @param    rest
       * @param nvicPriority Priority level used to configure the NVIC
       *        Subset of available levels
       */
      template <typename... Types>
      constexpr ChannelInit(NvicPriority nvicPriority, Types... rest) : ChannelInit(rest...) {
   
         irqlevel = nvicPriority;
      }

      /**
       * Constructor for Pit Channel Number
       *
       * @tparam   Types
       * @param    rest
       * @param pitChannelNum Selected PIT channel
       */
      template <typename... Types>
      constexpr ChannelInit(PitChannelNum pitChannelNum, Types... rest) : ChannelInit(rest...) {
   
         channelnumber = pitChannelNum;
      }

      /**
       * Constructor for Reload value channel 0
       *
       * @tparam   Types
       * @param    rest
       * @param ticks   Value loaded in timer register on roll-over
       */
      template <typename... Types>
      constexpr ChannelInit(Ticks&  ticks, Types... rest) : ChannelInit(rest...) {
   
         ldval = ticks;
      }

      /**
       * Constructor for Timer Channel Enable
       *
       * @tparam   Types
       * @param    rest
       *
       * @param pitChannelEnable Allows operation of this channel
       */
      template <typename... Types>
      constexpr ChannelInit(PitChannelEnable pitChannelEnable, Types... rest) : ChannelInit(rest...) {
   
         tctrl = (tctrl&~PIT_TCTRL_TEN_MASK) | pitChannelEnable;
      }
   
      /**
       * Constructor for Timer Interrupt Enable
       *
       * @tparam   Types
       * @param    rest
       *
       * @param pitChannelIrq Allows interrupts from this channel
       */
      template <typename... Types>
      constexpr ChannelInit(PitChannelIrq pitChannelIrq, Types... rest) : ChannelInit(rest...) {
   
         tctrl = (tctrl&~PIT_TCTRL_TIE_MASK) | pitChannelIrq;
      }
   
      /**
       * Constructor for Chain with previous channel
       *
       * @tparam   Types
       * @param    rest
       *
       * @param pitChannelChain Controls whether the timer channels are chained to create a larger counter
       */
      template <typename... Types>
      constexpr ChannelInit(PitChannelChain pitChannelChain, Types... rest) : ChannelInit(rest...) {
   
         tctrl = (tctrl&~PIT_TCTRL_CHN_MASK) | pitChannelChain;
      }
   
   };// PitBasicInfo::ChannelInit

}; // PitBasicInfo

class PitInfo {
public:
   /*
    * Template:pit_2ch_chain_0x40037000
    */
   /* Template _enablePeripheral  */
   
   //! Configure peripheral in start-up
   static constexpr bool configurePeripheralInStartUp = false;

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = PIT_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = true;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_Normal;

   /* Template _enablePeripheral  */
   
   /**
    *  Enable clock to Pit
    */
   static void enableClock() {
      SIM->SCGC = SIM->SCGC | SIM_SCGC_PIT_MASK;
   }

   /**
    *  Disable clock to Pit
    */
   static void disableClock() {
      SIM->SCGC = SIM->SCGC & ~SIM_SCGC_PIT_MASK;
   }

   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = PIT_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<PIT_Type> pit = baseAddress;
   
   //! Number of PIT channels
   static constexpr uint32_t NumChannels  = 2;

   /**
    * Set Module Disable
    *
    * @param pitMcrMdis Disabled PIT module clock
    */
   static void configureMcrMdis(PitMcrMdis pitMcrMdis) {
      pit->MCR = (pit->MCR&~PIT_MCR_MDIS_MASK) | pitMcrMdis;
   }

   /**
    * Set Freeze in Debug
    *
    * @param pitDebugMode Determines if timers are stopped in Debug mode
    */
   static void configureMcrFrz(PitDebugMode pitDebugMode) {
      pit->MCR = (pit->MCR&~PIT_MCR_FRZ_MASK) | pitDebugMode;
   }

   /// Freeze in Debug
   static constexpr uint32_t mcr = 
      PitDebugMode_Freeze;  // Freeze in Debug - Timers stop in Debug; 

   /**
    * Pit interrupt call back
    */
   typedef PitBasicInfo::CallbackFunction CallbackFunction;
      /**
    * Class used to do initialisation of a Pit channel
    *
    * This class has a templated constructor that accepts various values:
    *
    * @note This constructor may be used to create a const instance in ROM
    *
    * Example:
    * @code
    * // Initialisation values for Pit channel
    * // Parameters available may vary with device - see Pit::DefaultChannelInitValues[] for relevant example
    * static const Pit::ChannelInit pitInit {
    *       PitChannelNum_0,
    *
    *       PitChannelEnable_Enabled , // Timer Channel Enable - Channel enabled
    *       PitChannelChain_Disabled , // Chain with previous channel - Timers are not chained
    *       PitChannelIrq_Disabled ,   // Timer Interrupt Enable - Interrupts are disabled
    *       callBackFunction,          // Call-back function to use
    *       NvicPriority_Normal ,      // IRQ level for this peripheral - Normal
    *       3999_ticks,                // Reload value for channel (in ticks or seconds)
    *
    *       Pit::DefaultChannelInitValues[1], // An existing declaration may be referenced as the last item
    *                                            This becomes a base value modified by earlier values.
    * };
    *
    * // Initialise PIT channel from values specified above
    * Pit::configure(pitInit)
    * @endcode
    */
   typedef PitBasicInfo::ChannelInit ChannelInit;
   
   /**
    * Default initialisation values for PIT channels
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr ChannelInit DefaultChannelInitValues[] = {
      {
      PitChannelNum_0,

      PitChannelEnable_Enabled , // Timer Channel Enable - Channel enabled
      PitChannelIrq_Disabled , // Timer Interrupt Enable - Interrupts are disabled
      23999_ticks,  // Reload value channel 0
      },
      {
      PitChannelNum_1,

      PitChannelEnable_Enabled , // Timer Channel Enable - Channel enabled
      PitChannelChain_Disabled , // Chain with previous channel - Timers are not chained
      PitChannelIrq_Disabled , // Timer Interrupt Enable - Interrupts are disabled
      0_ticks,  // Reload value channel 1
      },
   }; // DefaultChannelInitValues

   /**
    * Get clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static __attribute__((always_inline)) uint32_t getClockFrequency() {
      return SystemBusClock;
   }

};

/** 
 * End group PIT_Group
 * @}
 */
/**
 * @addtogroup PORT_Group PORT, PORT
 * @brief Abstraction for PORT
 * @{
 */
/**
 * Peripheral information for PORT, PORT.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Filter Division Set 1
    *
    * Selects the clock speed for the filter
    */
   enum PortFilterClock1 {
      PortFilterClock1_Busclk2  = PORT_IOFLT_FLTDIV1(0), ///< BUSCLK/2
      PortFilterClock1_Busclk4  = PORT_IOFLT_FLTDIV1(1), ///< BUSCLK/4
      PortFilterClock1_Busclk8  = PORT_IOFLT_FLTDIV1(2), ///< BUSCLK/8
      PortFilterClock1_Busclk16 = PORT_IOFLT_FLTDIV1(3), ///< BUSCLK/16

   };

   /**
    * Filter Division Set 2
    *
    * Selects the clock speed for the filter
    */
   enum PortFilterClock2 {
      PortFilterClock2_Busclk32   = PORT_IOFLT_FLTDIV2(0), ///< BUSCLK/32
      PortFilterClock2_Busclk64   = PORT_IOFLT_FLTDIV2(1), ///< BUSCLK/64
      PortFilterClock2_Busclk128  = PORT_IOFLT_FLTDIV2(2), ///< BUSCLK/128
      PortFilterClock2_Busclk256  = PORT_IOFLT_FLTDIV2(3), ///< BUSCLK/256
      PortFilterClock2_Busclk512  = PORT_IOFLT_FLTDIV2(4), ///< BUSCLK/512
      PortFilterClock2_Busclk1024 = PORT_IOFLT_FLTDIV2(5), ///< BUSCLK/1024
      PortFilterClock2_Busclk2048 = PORT_IOFLT_FLTDIV2(6), ///< BUSCLK/2048
      PortFilterClock2_Busclk4096 = PORT_IOFLT_FLTDIV2(7), ///< BUSCLK/4096

   };

   /**
    * Filter Division Set 3
    *
    * Selects the clock speed for the filter
    */
   enum PortFilterClock3 {
      PortFilterClock3_Lpoclk    = PORT_IOFLT_FLTDIV3(0), ///< LPOCLK
      PortFilterClock3_Lpoclk2   = PORT_IOFLT_FLTDIV3(1), ///< LPOCLK/2
      PortFilterClock3_Lpoclk4   = PORT_IOFLT_FLTDIV3(2), ///< LPOCLK/4
      PortFilterClock3_Lpoclk8   = PORT_IOFLT_FLTDIV3(3), ///< LPOCLK/8
      PortFilterClock3_Lpoclk16  = PORT_IOFLT_FLTDIV3(4), ///< LPOCLK/16
      PortFilterClock3_Lpoclk32  = PORT_IOFLT_FLTDIV3(5), ///< LPOCLK/32
      PortFilterClock3_Lpoclk64  = PORT_IOFLT_FLTDIV3(6), ///< LPOCLK/64
      PortFilterClock3_Lpoclk128 = PORT_IOFLT_FLTDIV3(7), ///< LPOCLK/128

   };

   /**
    * Filter Selection for Input from NMI
    *
    * 
    */
   enum PortNmiFilterSel {
      PortNmiFilterSel_NoFilter                                                     = PORT_IOFLT_FLTNMI(0), ///< No filter
      PortNmiFilterSel_SelectsFltdiv1_AndWillSwitchToFltdiv3InStopModeAutomatically = PORT_IOFLT_FLTNMI(1), ///< Selects FLTDIV1, and will switch to FLTDIV3 in Stop mode automatically
      PortNmiFilterSel_SelectsFltdiv2_AndWillSwitchToFltdiv3InStopModeAutomatically = PORT_IOFLT_FLTNMI(2), ///< Selects FLTDIV2, and will switch to FLTDIV3 in Stop mode automatically
      PortNmiFilterSel_Fltdiv3                                                      = PORT_IOFLT_FLTNMI(3), ///< FLTDIV3

   };

   /**
    * Filter Selection for Input from RESET
    *
    * 
    */
   enum PortResetFilterSel {
      PortResetFilterSel_NoFilter                                                     = PORT_IOFLT_FLTRST(0), ///< No filter
      PortResetFilterSel_SelectsFltdiv1_AndWillSwitchToFltdiv3InStopModeAutomatically = PORT_IOFLT_FLTRST(1), ///< Selects FLTDIV1, and will switch to FLTDIV3 in Stop mode automatically
      PortResetFilterSel_SelectsFltdiv2_AndWillSwitchToFltdiv3InStopModeAutomatically = PORT_IOFLT_FLTRST(2), ///< Selects FLTDIV2, and will switch to FLTDIV3 in Stop mode automatically
      PortResetFilterSel_Fltdiv3                                                      = PORT_IOFLT_FLTRST(3), ///< FLTDIV3

   };

   /**
    * Filter Selection for Input from KBI0
    *
    * 
    */
   enum PortKbi0FilterSel {
      PortKbi0FilterSel_NoFilter                                                     = PORT_IOFLT_FLTKBI0(0), ///< No filter
      PortKbi0FilterSel_SelectsFltdiv1_AndWillSwitchToFltdiv3InStopModeAutomatically = PORT_IOFLT_FLTKBI0(1), ///< Selects FLTDIV1, and will switch to FLTDIV3 in Stop mode automatically
      PortKbi0FilterSel_SelectsFltdiv2_AndWillSwitchToFltdiv3InStopModeAutomatically = PORT_IOFLT_FLTKBI0(2), ///< Selects FLTDIV2, and will switch to FLTDIV3 in Stop mode automatically
      PortKbi0FilterSel_Fltdiv3                                                      = PORT_IOFLT_FLTKBI0(3), ///< FLTDIV3

   };

   /**
    * Filter Selection for Input from KBI1
    *
    * 
    */
   enum PortKbi1FilterSel {
      PortKbi1FilterSel_NoFilter                                                     = PORT_IOFLT_FLTKBI1(0), ///< No filter
      PortKbi1FilterSel_SelectsFltdiv1_AndWillSwitchToFltdiv3InStopModeAutomatically = PORT_IOFLT_FLTKBI1(1), ///< Selects FLTDIV1, and will switch to FLTDIV3 in Stop mode automatically
      PortKbi1FilterSel_SelectsFltdiv2_AndWillSwitchToFltdiv3InStopModeAutomatically = PORT_IOFLT_FLTKBI1(2), ///< Selects FLTDIV2, and will switch to FLTDIV3 in Stop mode automatically
      PortKbi1FilterSel_Fltdiv3                                                      = PORT_IOFLT_FLTKBI1(3), ///< FLTDIV3

   };

   /**
    * Filter Selection for Input from SCL0/SDA0
    *
    * 
    */
   enum PortI2c0FilterSel {
      PortI2c0FilterSel_NoFilter = PORT_IOFLT_FLTIIC(0), ///< No Filter
      PortI2c0FilterSel_Fltdiv1  = PORT_IOFLT_FLTIIC(1), ///< FLTDIV1
      PortI2c0FilterSel_Fltdiv2  = PORT_IOFLT_FLTIIC(2), ///< FLTDIV2
      PortI2c0FilterSel_Busclk   = PORT_IOFLT_FLTIIC(3), ///< BUSCLK

   };

   /**
    * Filter Selection for Input from PWT_IN0/PWT_IN1
    *
    * 
    */
   enum PortPwtFilterSel {
      PortPwtFilterSel_NoFilter = PORT_IOFLT_FLTPWT(0), ///< No Filter
      PortPwtFilterSel_Fltdiv1  = PORT_IOFLT_FLTPWT(1), ///< FLTDIV1
      PortPwtFilterSel_Fltdiv2  = PORT_IOFLT_FLTPWT(2), ///< FLTDIV2
      PortPwtFilterSel_Fltdiv3  = PORT_IOFLT_FLTPWT(3), ///< FLTDIV3

   };

   /**
    * Filter Selection for Input from FTM0 Channels
    *
    * 
    */
   enum PortFtm0FilterSel {
      PortFtm0FilterSel_NoFilter = PORT_IOFLT_FLTFTM0(0), ///< No Filter
      PortFtm0FilterSel_Fltdiv1  = PORT_IOFLT_FLTFTM0(1), ///< FLTDIV1
      PortFtm0FilterSel_Fltdiv2  = PORT_IOFLT_FLTFTM0(2), ///< FLTDIV2
      PortFtm0FilterSel_Fltdiv3  = PORT_IOFLT_FLTFTM0(3), ///< FLTDIV3

   };

   /**
    * Filter Selection for Input from PTA
    *
    * 
    */
   enum PortPtaFilterSel {
      PortPtaFilterSel_Busclk  = PORT_IOFLT_FLTA(0), ///< BUSCLK
      PortPtaFilterSel_Fltdiv1 = PORT_IOFLT_FLTA(1), ///< FLTDIV1
      PortPtaFilterSel_Fltdiv2 = PORT_IOFLT_FLTA(2), ///< FLTDIV2
      PortPtaFilterSel_Fltdiv3 = PORT_IOFLT_FLTA(3), ///< FLTDIV3

   };

   /**
    * Filter Selection for Input from PTB
    *
    * 
    */
   enum PortPtbFilterSel {
      PortPtbFilterSel_Busclk  = PORT_IOFLT_FLTB(0), ///< BUSCLK
      PortPtbFilterSel_Fltdiv1 = PORT_IOFLT_FLTB(1), ///< FLTDIV1
      PortPtbFilterSel_Fltdiv2 = PORT_IOFLT_FLTB(2), ///< FLTDIV2
      PortPtbFilterSel_Fltdiv3 = PORT_IOFLT_FLTB(3), ///< FLTDIV3

   };

   /**
    * Filter Selection for Input from PTC
    *
    * 
    */
   enum PortPtcFilterSel {
      PortPtcFilterSel_Busclk  = PORT_IOFLT_FLTC(0), ///< BUSCLK
      PortPtcFilterSel_Fltdiv1 = PORT_IOFLT_FLTC(1), ///< FLTDIV1
      PortPtcFilterSel_Fltdiv2 = PORT_IOFLT_FLTC(2), ///< FLTDIV2
      PortPtcFilterSel_Fltdiv3 = PORT_IOFLT_FLTC(3), ///< FLTDIV3

   };

   /**
    * High drive enable for Port B bit 5
    *
    * 
    */
   enum PortHdrvePtb5 {
      PortHdrvePtb5_LowDriveStrength  = PORT_HDRVE_PTB5(0), ///< Low drive strength
      PortHdrvePtb5_HighDriveStrength = PORT_HDRVE_PTB5(1), ///< High drive strength

   };

   /**
    * High drive enable for Port C bit 1
    *
    * 
    */
   enum PortHdrvePtc1 {
      PortHdrvePtc1_LowDriveStrength  = PORT_HDRVE_PTC1(0), ///< Low drive strength
      PortHdrvePtc1_HighDriveStrength = PORT_HDRVE_PTC1(1), ///< High drive strength

   };

   /**
    * High drive enable for Port C bit 5
    *
    * 
    */
   enum PortHdrvePtc5 {
      PortHdrvePtc5_LowDriveStrength  = PORT_HDRVE_PTC5(0), ///< Low drive strength
      PortHdrvePtc5_HighDriveStrength = PORT_HDRVE_PTC5(1), ///< High drive strength

   };

class PortBasicInfo {
   
public:
   /**
    * Class used to do initialisation of the Port
    *
    * This class has a templated constructor that accepts various values.
    *
    * @note This constructor may be used to create a const instance in Flash
    *
    * Example:
    * @code
    * static const Port::Init init {
    *
    *   // Setup values
    *   PortFilterClock1_Busclk2 ,    // Filter Division Set 1 - BUSCLK/2
    *   PortFilterClock2_Busclk32 ,   // Filter Division Set 2 - BUSCLK/32
    *   PortFilterClock3_Lpoclk ,     // Filter Division Set 3 - LPOCLK
    *   PortResetFilterSel_NoFilter , // Filter Selection for Input from RESET - No filter
    *   PortNmiFilterSel_Fltdiv3 ,    // Filter Selection for Input from NMI - FLTDIV3
    *   PortPwtFilterSel_NoFilter ,   // Filter Selection for Input from PWT_IN0/PWT_IN1 - No Filter
    *   PortKbi1FilterSel_NoFilter ,  // Filter Selection for Input from KBI1 - No filter
    *   PortKbi0FilterSel_NoFilter ,  // Filter Selection for Input from KBI0 - No filter
    *   PortFtm0FilterSel_NoFilter ,  // Filter Selection for Input from FTM0 Channels - No Filter
    *   PortI2c0FilterSel_NoFilter ,  // Filter Selection for Input from SCL0/SDA0 - No Filter
    *   PortPtaFilterSel_Busclk ,     // Filter Selection for Input from PTA - BUSCLK
    *   PortPtbFilterSel_Busclk ,     // Filter Selection for Input from PTB - BUSCLK
    *   PortPtcFilterSel_Busclk,      // Filter Selection for Input from PTC - BUSCLK
    * };
    *
    * // Initialise Port from values specified above
    * Port::configure(init)
    * @endcode
    */
   class Init {
   
   public:
      /**
       * Copy Constructor
       */
      constexpr Init(const Init &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr Init() = default;
   
      /// Port Filter Register
      uint32_t ioflt = 0;

      /**
       * Constructor for Filter Division Set 3
       *
       * @tparam   Types
       * @param    rest
       *
       * @param portFilterClock3 Selects the clock speed for the filter
       */
      template <typename... Types>
      constexpr Init(PortFilterClock3 portFilterClock3, Types... rest) : Init(rest...) {
   
         ioflt = (ioflt&~PORT_IOFLT_FLTDIV3_MASK) | portFilterClock3;
      }
   
      /**
       * Constructor for Filter Division Set 2
       *
       * @tparam   Types
       * @param    rest
       *
       * @param portFilterClock2 Selects the clock speed for the filter
       */
      template <typename... Types>
      constexpr Init(PortFilterClock2 portFilterClock2, Types... rest) : Init(rest...) {
   
         ioflt = (ioflt&~PORT_IOFLT_FLTDIV2_MASK) | portFilterClock2;
      }
   
      /**
       * Constructor for Filter Division Set 1
       *
       * @tparam   Types
       * @param    rest
       *
       * @param portFilterClock1 Selects the clock speed for the filter
       */
      template <typename... Types>
      constexpr Init(PortFilterClock1 portFilterClock1, Types... rest) : Init(rest...) {
   
         ioflt = (ioflt&~PORT_IOFLT_FLTDIV1_MASK) | portFilterClock1;
      }
   
      /**
       * Constructor for Filter Selection for Input from NMI
       *
       * @tparam   Types
       * @param    rest
       *
       * @param portNmiFilterSel 
       */
      template <typename... Types>
      constexpr Init(PortNmiFilterSel portNmiFilterSel, Types... rest) : Init(rest...) {
   
         ioflt = (ioflt&~PORT_IOFLT_FLTNMI_MASK) | portNmiFilterSel;
      }
   
      /**
       * Constructor for Filter Selection for Input from KBI1
       *
       * @tparam   Types
       * @param    rest
       *
       * @param portKbi1FilterSel 
       */
      template <typename... Types>
      constexpr Init(PortKbi1FilterSel portKbi1FilterSel, Types... rest) : Init(rest...) {
   
         ioflt = (ioflt&~PORT_IOFLT_FLTKBI1_MASK) | portKbi1FilterSel;
      }
   
      /**
       * Constructor for Filter Selection for Input from KBI0
       *
       * @tparam   Types
       * @param    rest
       *
       * @param portKbi0FilterSel 
       */
      template <typename... Types>
      constexpr Init(PortKbi0FilterSel portKbi0FilterSel, Types... rest) : Init(rest...) {
   
         ioflt = (ioflt&~PORT_IOFLT_FLTKBI0_MASK) | portKbi0FilterSel;
      }
   
      /**
       * Constructor for Filter Selection for Input from RESET
       *
       * @tparam   Types
       * @param    rest
       *
       * @param portResetFilterSel 
       */
      template <typename... Types>
      constexpr Init(PortResetFilterSel portResetFilterSel, Types... rest) : Init(rest...) {
   
         ioflt = (ioflt&~PORT_IOFLT_FLTRST_MASK) | portResetFilterSel;
      }
   
      /**
       * Constructor for Filter Selection for Input from PWT_IN0/PWT_IN1
       *
       * @tparam   Types
       * @param    rest
       *
       * @param portPwtFilterSel 
       */
      template <typename... Types>
      constexpr Init(PortPwtFilterSel portPwtFilterSel, Types... rest) : Init(rest...) {
   
         ioflt = (ioflt&~PORT_IOFLT_FLTPWT_MASK) | portPwtFilterSel;
      }
   
      /**
       * Constructor for Filter Selection for Input from FTM0 Channels
       *
       * @tparam   Types
       * @param    rest
       *
       * @param portFtm0FilterSel 
       */
      template <typename... Types>
      constexpr Init(PortFtm0FilterSel portFtm0FilterSel, Types... rest) : Init(rest...) {
   
         ioflt = (ioflt&~PORT_IOFLT_FLTFTM0_MASK) | portFtm0FilterSel;
      }
   
      /**
       * Constructor for Filter Selection for Input from SCL0/SDA0
       *
       * @tparam   Types
       * @param    rest
       *
       * @param portI2c0FilterSel 
       */
      template <typename... Types>
      constexpr Init(PortI2c0FilterSel portI2c0FilterSel, Types... rest) : Init(rest...) {
   
         ioflt = (ioflt&~PORT_IOFLT_FLTIIC_MASK) | portI2c0FilterSel;
      }
   
      /**
       * Constructor for Filter Selection for Input from PTC
       *
       * @tparam   Types
       * @param    rest
       *
       * @param portPtcFilterSel 
       */
      template <typename... Types>
      constexpr Init(PortPtcFilterSel portPtcFilterSel, Types... rest) : Init(rest...) {
   
         ioflt = (ioflt&~PORT_IOFLT_FLTC_MASK) | portPtcFilterSel;
      }
   
      /**
       * Constructor for Filter Selection for Input from PTB
       *
       * @tparam   Types
       * @param    rest
       *
       * @param portPtbFilterSel 
       */
      template <typename... Types>
      constexpr Init(PortPtbFilterSel portPtbFilterSel, Types... rest) : Init(rest...) {
   
         ioflt = (ioflt&~PORT_IOFLT_FLTB_MASK) | portPtbFilterSel;
      }
   
      /**
       * Constructor for Filter Selection for Input from PTA
       *
       * @tparam   Types
       * @param    rest
       *
       * @param portPtaFilterSel 
       */
      template <typename... Types>
      constexpr Init(PortPtaFilterSel portPtaFilterSel, Types... rest) : Init(rest...) {
   
         ioflt = (ioflt&~PORT_IOFLT_FLTA_MASK) | portPtaFilterSel;
      }
   
   }; // PortBasicInfo::Init

}; // PortBasicInfo

class PortInfo {
public:
   /*
    * Template:port_mke04
    */
   /* Template _enablePeripheral  */
   
   //! Configure peripheral in start-up
   static constexpr bool configurePeripheralInStartUp = true;

   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = PORT_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<PORT_Type> port = baseAddress;
   
   /**
    * Set Filter Division Set 3
    *
    * @param portFilterClock3 Selects the clock speed for the filter
    */
   static void configureFilter3Clock(PortFilterClock3 portFilterClock3) {
      port->IOFLT = (port->IOFLT&~PORT_IOFLT_FLTDIV3_MASK) | portFilterClock3;
   }

   /**
    * Set Filter Division Set 2
    *
    * @param portFilterClock2 Selects the clock speed for the filter
    */
   static void configureFilter2Clock(PortFilterClock2 portFilterClock2) {
      port->IOFLT = (port->IOFLT&~PORT_IOFLT_FLTDIV2_MASK) | portFilterClock2;
   }

   /**
    * Set Filter Division Set 1
    *
    * @param portFilterClock1 Selects the clock speed for the filter
    */
   static void configureFilter1Clock(PortFilterClock1 portFilterClock1) {
      port->IOFLT = (port->IOFLT&~PORT_IOFLT_FLTDIV1_MASK) | portFilterClock1;
   }

   /**
    * Set Filter Selection for Input from NMI
    *
    * @param portNmiFilterSel 
    */
   static void configureNmiFilter(PortNmiFilterSel portNmiFilterSel) {
      port->IOFLT = (port->IOFLT&~PORT_IOFLT_FLTNMI_MASK) | portNmiFilterSel;
   }

   /**
    * Set Filter Selection for Input from KBI1
    *
    * @param portKbi1FilterSel 
    */
   static void configureKbi1Filter(PortKbi1FilterSel portKbi1FilterSel) {
      port->IOFLT = (port->IOFLT&~PORT_IOFLT_FLTKBI1_MASK) | portKbi1FilterSel;
   }

   /**
    * Set Filter Selection for Input from KBI0
    *
    * @param portKbi0FilterSel 
    */
   static void configureKbi0Filter(PortKbi0FilterSel portKbi0FilterSel) {
      port->IOFLT = (port->IOFLT&~PORT_IOFLT_FLTKBI0_MASK) | portKbi0FilterSel;
   }

   /**
    * Set Filter Selection for Input from RESET
    *
    * @param portResetFilterSel 
    */
   static void configureResetFilter(PortResetFilterSel portResetFilterSel) {
      port->IOFLT = (port->IOFLT&~PORT_IOFLT_FLTRST_MASK) | portResetFilterSel;
   }

   /**
    * Set Filter Selection for Input from PWT_IN0/PWT_IN1
    *
    * @param portPwtFilterSel 
    */
   static void configurePwtFilter(PortPwtFilterSel portPwtFilterSel) {
      port->IOFLT = (port->IOFLT&~PORT_IOFLT_FLTPWT_MASK) | portPwtFilterSel;
   }

   /**
    * Set Filter Selection for Input from FTM0 Channels
    *
    * @param portFtm0FilterSel 
    */
   static void configureFtm0Filter(PortFtm0FilterSel portFtm0FilterSel) {
      port->IOFLT = (port->IOFLT&~PORT_IOFLT_FLTFTM0_MASK) | portFtm0FilterSel;
   }

   /**
    * Set Filter Selection for Input from SCL0/SDA0
    *
    * @param portI2c0FilterSel 
    */
   static void configureI2c0Filter(PortI2c0FilterSel portI2c0FilterSel) {
      port->IOFLT = (port->IOFLT&~PORT_IOFLT_FLTIIC_MASK) | portI2c0FilterSel;
   }

   /**
    * Set Filter Selection for Input from PTC
    *
    * @param portPtcFilterSel 
    */
   static void configurePtcFilter(PortPtcFilterSel portPtcFilterSel) {
      port->IOFLT = (port->IOFLT&~PORT_IOFLT_FLTC_MASK) | portPtcFilterSel;
   }

   /**
    * Set Filter Selection for Input from PTB
    *
    * @param portPtbFilterSel 
    */
   static void configurePtbFilter(PortPtbFilterSel portPtbFilterSel) {
      port->IOFLT = (port->IOFLT&~PORT_IOFLT_FLTB_MASK) | portPtbFilterSel;
   }

   /**
    * Set Filter Selection for Input from PTA
    *
    * @param portPtaFilterSel 
    */
   static void configurePtaFilter(PortPtaFilterSel portPtaFilterSel) {
      port->IOFLT = (port->IOFLT&~PORT_IOFLT_FLTA_MASK) | portPtaFilterSel;
   }

      /** Default value for Pull-up control for Port C */
      static constexpr uint32_t puel = 
         PORT_PUEL_PTCPE(0x0) | // Pull-up control for Port C
         PORT_PUEL_PTBPE(0x0) | // Pull-up control for Port B
         PORT_PUEL_PTAPE(0x1);  // Pull-up control for Port A;
   
      /** Default value for High drive enable for Port C bit 5 */
      static constexpr uint32_t hdrve = 
         PortHdrvePtc5_LowDriveStrength | // High drive enable for Port C bit 5 - Low drive strength
         PortHdrvePtc1_LowDriveStrength | // High drive enable for Port C bit 1 - Low drive strength
         PortHdrvePtb5_HighDriveStrength;  // High drive enable for Port B bit 5 - High drive strength;
   
   /**
    * Class used to do initialisation of the Port
    *
    * This class has a templated constructor that accepts various values.
    *
    * @note This constructor may be used to create a const instance in Flash
    *
    * Example:
    * @code
    * static const Port::Init init {
    *
    *   // Setup values
    *   PortFilterClock1_Busclk2 ,    // Filter Division Set 1 - BUSCLK/2
    *   PortFilterClock2_Busclk32 ,   // Filter Division Set 2 - BUSCLK/32
    *   PortFilterClock3_Lpoclk ,     // Filter Division Set 3 - LPOCLK
    *   PortResetFilterSel_NoFilter , // Filter Selection for Input from RESET - No filter
    *   PortNmiFilterSel_Fltdiv3 ,    // Filter Selection for Input from NMI - FLTDIV3
    *   PortPwtFilterSel_NoFilter ,   // Filter Selection for Input from PWT_IN0/PWT_IN1 - No Filter
    *   PortKbi1FilterSel_NoFilter ,  // Filter Selection for Input from KBI1 - No filter
    *   PortKbi0FilterSel_NoFilter ,  // Filter Selection for Input from KBI0 - No filter
    *   PortFtm0FilterSel_NoFilter ,  // Filter Selection for Input from FTM0 Channels - No Filter
    *   PortI2c0FilterSel_NoFilter ,  // Filter Selection for Input from SCL0/SDA0 - No Filter
    *   PortPtaFilterSel_Busclk ,     // Filter Selection for Input from PTA - BUSCLK
    *   PortPtbFilterSel_Busclk ,     // Filter Selection for Input from PTB - BUSCLK
    *   PortPtcFilterSel_Busclk,      // Filter Selection for Input from PTC - BUSCLK
    * };
    *
    * // Initialise Port from values specified above
    * Port::configure(init)
    * @endcode
    */
   typedef PortBasicInfo::Init Init;
   
   /**
    * Default initialisation value for Port
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr Init DefaultInitValue = {
      PortFilterClock1_Busclk2 , // Filter Division Set 1 - BUSCLK/2
      PortFilterClock2_Busclk32 , // Filter Division Set 2 - BUSCLK/32
      PortFilterClock3_Lpoclk , // Filter Division Set 3 - LPOCLK
      PortResetFilterSel_NoFilter , // Filter Selection for Input from RESET - No filter
      PortNmiFilterSel_Fltdiv3 , // Filter Selection for Input from NMI - FLTDIV3
      PortPwtFilterSel_NoFilter , // Filter Selection for Input from PWT_IN0/PWT_IN1 - No Filter
      PortKbi1FilterSel_NoFilter , // Filter Selection for Input from KBI1 - No filter
      PortKbi0FilterSel_NoFilter , // Filter Selection for Input from KBI0 - No filter
      PortFtm0FilterSel_NoFilter , // Filter Selection for Input from FTM0 Channels - No Filter
      PortI2c0FilterSel_NoFilter , // Filter Selection for Input from SCL0/SDA0 - No Filter
      PortPtaFilterSel_Busclk , // Filter Selection for Input from PTA - BUSCLK
      PortPtbFilterSel_Busclk , // Filter Selection for Input from PTB - BUSCLK
      PortPtcFilterSel_Busclk,  // Filter Selection for Input from PTC - BUSCLK
   };

};

/** 
 * End group PORT_Group
 * @}
 */
/**
 * @addtogroup Power_Group POWER, Power
 * @brief Abstraction for Power
 * @{
 */
/**
 * Peripheral information for POWER, Power.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class PowerInfo {
public:
   /*
    * Template:power
    */
};

/** 
 * End group Power_Group
 * @}
 */
/**
 * @addtogroup PWT_Group PWT, PWT, Pulse Width Timer
 * @brief Abstraction for PWT, Pulse Width Timer
 * @{
 */
/**
 * Peripheral information for PWT, PWT, Pulse Width Timer.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class PwtInfo {
public:
   /*
    * Template:pwt_mke
    */
};

/** 
 * End group PWT_Group
 * @}
 */
/**
 * @addtogroup SPI_Group SPI, Serial Peripheral Interface
 * @brief Abstraction for Serial Peripheral Interface
 * @{
 */
/**
 * Peripheral information for SPI, Serial Peripheral Interface.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class Spi0Info {
public:
   /*
    * Template:spi0_mke_8bit
    */
};

/** 
 * End group SPI_Group
 * @}
 */
/**
 * @addtogroup UART_Group UART, Universal Asynchronous Receiver/Transmitter
 * @brief Abstraction for Universal Asynchronous Receiver/Transmitter
 * @{
 */
/**
 * Peripheral information for UART, Universal Asynchronous Receiver/Transmitter.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * UART default baud rate
    *
    * Used by default UART setup for stdio
    */
   enum UartBaudRate {
      UartBaudRate_110    = 110,    ///< 110
      UartBaudRate_300    = 300,    ///< 300
      UartBaudRate_600    = 600,    ///< 600
      UartBaudRate_1200   = 1200,   ///< 1200
      UartBaudRate_2400   = 2400,   ///< 2400
      UartBaudRate_4800   = 4800,   ///< 4800
      UartBaudRate_9600   = 9600,   ///< 9600
      UartBaudRate_14400  = 14400,  ///< 14400
      UartBaudRate_19200  = 19200,  ///< 19200
      UartBaudRate_28800  = 28800,  ///< 28800
      UartBaudRate_38400  = 38400,  ///< 38400
      UartBaudRate_56000  = 56000,  ///< 56000
      UartBaudRate_57600  = 57600,  ///< 57600
      UartBaudRate_115200 = 115200, ///< 115200

   };

   /**
    * Transmit complete action
    *
    * Enable interrupt on transmission complete
    */
   enum UartTxCompleteAction {
      UartTxCompleteAction_None      = UART_C2_TCIE(0), ///< None
      UartTxCompleteAction_Interrupt = UART_C2_TCIE(1), ///< Interrupt

   };

   /**
    * Idle line detect sction
    *
    * Enable interrupt on tidele line detect
    */
   enum UartIdleLineDetectAction {
      UartIdleLineDetectAction_None      = UART_C2_ILIE(0), ///< None
      UartIdleLineDetectAction_Interrupt = UART_C2_ILIE(1), ///< Interrupt

   };

   /**
    * Transmit empty DMA/Interrupt action
    *
    * Enable transmit holding register empty DMA/Interrupt action
    */
   enum UartTxEmptyAction {
      UartTxEmptyAction_None      = UART_C2_TIE(0), ///< None
      UartTxEmptyAction_Interrupt = UART_C2_TIE(1), ///< Interrupt

   };

   /**
    * Receive full interrupt action
    *
    * Enable receive buffer full interrupt action
    */
   enum UartRxFullAction {
      UartRxFullAction_None      = UART_C2_RIE(0), ///< None
      UartRxFullAction_Interrupt = UART_C2_RIE(1), ///< Interrupt

   };

class Uart0Info {
public:
   /*
    * Template:uart0_mke
    */
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = UART0_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<UART_Type> uart = baseAddress;
   
   //! Peripheral instance number
   static constexpr unsigned instance = 0;
   
   //! Map all allocated pins on a peripheral when enabled
   static constexpr bool mapPinsOnEnable = true;

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = UART0_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_NotInstalled;

   /**
    *  Enable clock to Uart0
    */
   static void enableClock() {
#ifdef PCC
      PccInfo::enableUart0Clock();
#else
      SIM->SCGC = SIM->SCGC | SIM_SCGC_UART0_MASK;
#endif
   }

   /**
    *  Disable clock to Uart0
    */
   static void disableClock() {
#ifdef PCC
      PccInfo::disableUart0Clock();
#else
      SIM->SCGC = SIM->SCGC & ~SIM_SCGC_UART0_MASK;
#endif
   }

   //! Indicates whether the UART needs a write to clear status errors
   static constexpr bool statusNeedsWrite = false;
   
   //! Default Baud rate used if not explicitly given
   static constexpr uint32_t defaultBaudRate = 115200;
   
   //! Default buffer size for receive queue when interrupt driven
   static constexpr unsigned receiveBufferSize = 50;
   
   //! Default buffer size for transmit queue when interrupt driven
   static constexpr unsigned transmitBufferSize = 50;

   /**
    * Get input clock frequency
    *
    * @return Input clock frequency as a uint32_t in Hz
    */
   static inline uint32_t getInputClockFrequency() {
      return SimInfo::getUart0Clock();
   }

};

/** 
 * End group UART_Group
 * @}
 */
/**
 * @addtogroup WDOG_Group WDOG, Watchdog Timer
 * @brief Abstraction for Watchdog Timer
 * @{
 */
/**
 * Peripheral information for WDOG, Watchdog Timer.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Watchdog enable
    *
    * Main enable for WDOG
    */
   enum WdogEnable : uint16_t {
      WdogEnable_Disabled = WDOG_CS1_EN(0), ///< Watchdog disabled
      WdogEnable_Enabled  = WDOG_CS1_EN(1), ///< Watchdog enabled

   };

   /**
    * Test Mode: Controls the fast test mode.
    *
    * Allows exercising all bits of the counter to confirm that the watchdog is functioning properly.
    * This write-once field is cleared on POR only
    */
   enum WdogTestMode : uint16_t {
      WdogTestMode_Disabled         = WDOG_CS1_TST(0), ///< Disabled
      WdogTestMode_UserMode         = WDOG_CS1_TST(1), ///< DIsabled - User mode
      WdogTestMode_TestModeLowByte  = WDOG_CS1_TST(2), ///< Enabled, Only CNTL, TOVALL used
      WdogTestMode_TestModeHighByte = WDOG_CS1_TST(3), ///< Enabled, Only CNTH, TOVALH used

   };

   /**
    * Enable watchdog in WAIT mode
    *
    * This write-once bit enables the watchdog to operate when the chip is in wait mode
    */
   enum WdogEnableInWait : uint16_t {
      WdogEnableInWait_Disabled = WDOG_CS1_WAIT(0), ///< Disabled in WAIT mode
      WdogEnableInWait_Enabled  = WDOG_CS1_WAIT(1), ///< Enabled in WAIT mode

   };

   /**
    * Enable watchdog in STOP mode
    *
    * This write-once bit enables the watchdog to operate when the chip is in stop mode
    */
   enum WdogEnableInStop : uint16_t {
      WdogEnableInStop_Disabled = WDOG_CS1_STOP(0), ///< Disabled in STOP mode
      WdogEnableInStop_Enabled  = WDOG_CS1_STOP(1), ///< Enabled in STOP mode

   };

   /**
    * Enable watchdog in DEBUG mode
    *
    * This write-once bit enables the watchdog to operate when the chip is in debug mode
    */
   enum WdogEnableInDebug : uint16_t {
      WdogEnableInDebug_Disabled = WDOG_CS1_DBG(0), ///< Disabled in DEBUG mode
      WdogEnableInDebug_Enabled  = WDOG_CS1_DBG(1), ///< Enabled in DEBUG mode

   };

   /**
    * Allow watchdog update
    *
    * Enables updates to watchdog write-once registers, after 
    * the initial configuration.
    * This still requires the unlock sequence
    */
   enum WdogAllowUpdate : uint16_t {
      WdogAllowUpdate_Disabled = WDOG_CS1_UPDATE(0), ///< Update Disabled
      WdogAllowUpdate_Enabled  = WDOG_CS1_UPDATE(1), ///< Update Enabled

   };

   /**
    * Enable watchdog windowing mode
    *
    * Windowing mode only allows refresh during a restricted window
    */
   enum WdogWindow : uint16_t {
      WdogWindow_Disabled = WDOG_CS2_WIN(0), ///< Windowing mode disabled
      WdogWindow_Enabled  = WDOG_CS2_WIN(1), ///< Windowing mode enabled

   };

   /**
    * Action on watchdog event
    *
    * This write-once bit allows an interrupt handler to record state prior to forcing a reset.
    * The reset occurs after a delay of 128 bus clocks following the interrupt vector fetch,
    */
   enum WdogAction : uint16_t {
      WdogAction_ImmediateReset      = WDOG_CS1_INT(0), ///< Immediate Reset
      WdogAction_ResetAfterInterrupt = WDOG_CS1_INT(1), ///< Interrupt followed by reset

   };

   /**
    * Watchdog clock source
    *
    * This write-once field indicates the clock source that feeds the watchdog counter
    */
   enum WdogClock : uint16_t {
      WdogClock_SystemBusClk = WDOG_CS2_CLK(0), ///< System Bus clock
      WdogClock_LpoClk       = WDOG_CS2_CLK(1), ///< 1 kHz low-power oscillator (LPOCLK)
      WdogClock_Icsirclk     = WDOG_CS2_CLK(2), ///< ICS internal reference clock (ICSIRCLK)
      WdogClock_ExternalClk  = WDOG_CS2_CLK(3), ///< External clock source (OSCERCLK)

   };

   /**
    * Prescaler for the watchdog clock source
    *
    * This write-once bit enables a fixed 256 pre-scaling of watchdog counter reference clock
    */
   enum WdogPrescale : uint16_t {
      WdogPrescale_Direct   = WDOG_CS2_PRES(0), ///< Prescale /1
      WdogPrescale_DivBy256 = WDOG_CS2_PRES(1), ///< Prescale /256

   };

   /**
    * Values for refresh and update registers
    *
    * Note values are transposed for direct write to CNT register
    */
   enum WdogRefresh {
      WdogRefresh_1 = 0x02A6, ///< 1st refresh value
      WdogRefresh_2 = 0x80B4, ///< 2nd refresh value

   };

   /**
    * Values for refresh and update registers
    *
    * Note values are transposed for direct write to CNT register
    */
   enum WdogUnlock {
      WdogUnlock_1 = 0x20C5, ///< 1st unlock value
      WdogUnlock_2 = 0x28D9, ///< 2nd unlock value

   };

class WdogInfo {
public:
   /*
    * Template:wdog_mke
    */
   /* Template _enablePeripheral  */
   
   //! Configure peripheral in start-up
   static constexpr bool configurePeripheralInStartUp = true;

   /* Template_irqOption.xml */

   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = WDOG_IRQS;

   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);

   //! Class based callback handler has been installed in vector table
   static constexpr bool irqHandlerInstalled = false;

   //! Default IRQ level
   static constexpr NvicPriority irqLevel =  NvicPriority_Normal;

   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = WDOG_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<WDOG_Type> wdog = baseAddress;
   
};

/** 
 * End group WDOG_Group
 * @}
 */
/** 
 * End group USBDM_Group
 * @}
 */

} // End namespace USBDM


// GPIO definitions are needed generally
#include "gpio.h"

///
/// @page PinSummary Pin Mapping
///
/// @section PinsByPinName Pins by Pin Name
///
///   Pin Name      | C Identifier                  |  Functions                                         |  Location                 |  Description
///  -------------- | ------------------------------|--------------------------------------------------- | ------------------------- | ----------------------------------------------------
///  PTA1           | Reference                     | ADC0_SE1                                           | 15                        | -
///  PTA2           | DetectLed                     | GPIOA_2                                            | 14                        | -
///  PTB0           | I_Sample2                     | ADC0_SE4                                           | 12                        | -
///  PTB1           | I_Sample                      | ADC0_SE5                                           | 11                        | -
///  PTB2           | HoldControl                   | ADC0_SE6                                           | 10                        | -
///  PTB3           | LevelControl                  | ADC0_SE7                                           | 9                         | -
///  PTB4           | Debug                         | GPIOA_12                                           | 8                         | -
///  PTB5           | DustCollector                 | GPIOA_13                                           | 7                         | -
///  PTB6           | HoldLed                       | GPIOA_14                                           | 6                         | -
///  PTB7           | DelayLed                      | GPIOA_15                                           | 5                         | -
///
///
/// @section PinsByLocation Pins by Location
///
///   Pin Name      | C Identifier                  |  Functions                                         |  Location                 |  Description
///  -------------- | ------------------------------|--------------------------------------------------- | ------------------------- | ----------------------------------------------------
///  PTB2           | HoldControl                   | ADC0_SE6                                           | 10                        | -
///  PTB1           | I_Sample                      | ADC0_SE5                                           | 11                        | -
///  PTB0           | I_Sample2                     | ADC0_SE4                                           | 12                        | -
///  PTA2           | DetectLed                     | GPIOA_2                                            | 14                        | -
///  PTA1           | Reference                     | ADC0_SE1                                           | 15                        | -
///  PTB7           | DelayLed                      | GPIOA_15                                           | 5                         | -
///  PTB6           | HoldLed                       | GPIOA_14                                           | 6                         | -
///  PTB5           | DustCollector                 | GPIOA_13                                           | 7                         | -
///  PTB4           | Debug                         | GPIOA_12                                           | 8                         | -
///  PTB3           | LevelControl                  | ADC0_SE7                                           | 9                         | -
///
///
/// @section PinsByFunction Pins by Peripheral
///
///   Pin Name      | C Identifier                  |  Functions                                         |  Location                 |  Description
///  -------------- | ------------------------------|--------------------------------------------------- | ------------------------- | ----------------------------------------------------
///  PTA1           | Reference                     | ADC0_SE1                                           | 15                        | -
///  PTB0           | I_Sample2                     | ADC0_SE4                                           | 12                        | -
///  PTB1           | I_Sample                      | ADC0_SE5                                           | 11                        | -
///  PTB2           | HoldControl                   | ADC0_SE6                                           | 10                        | -
///  PTB3           | LevelControl                  | ADC0_SE7                                           | 9                         | -
///  PTA2           | DetectLed                     | GPIOA_2                                            | 14                        | -
///  PTB4           | Debug                         | GPIOA_12                                           | 8                         | -
///  PTB5           | DustCollector                 | GPIOA_13                                           | 7                         | -
///  PTB6           | HoldLed                       | GPIOA_14                                           | 6                         | -
///  PTB7           | DelayLed                      | GPIOA_15                                           | 5                         | -
///
///

#endif /* PROJECT_HEADERS_PIN_MAPPING_H */
