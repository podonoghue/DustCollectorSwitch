/**
 * @file      pin_mapping.h (generated from MKE04Z4.usbdmHardware)
 * @version   1.3.0
 * @brief     Peripheral declarations for MKE04Z8VTG4
 *
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#ifndef PROJECT_HEADERS_PIN_MAPPING_H
#define PROJECT_HEADERS_PIN_MAPPING_H

#include <stdint.h>
#include <stddef.h>
#include <array>

#include "derivative.h"
#include "pcr.h"
#include "error.h"

/**
 * Namespace enclosing USBDM classes
 */
namespace USBDM {

/**
 * @addtogroup USBDM_Group USBDM Peripheral Interface
 * @brief Hardware Peripheral Interface and library
 * @{
 */
   /**
    * Class used to do vector initialisation
    *
    * This class has a templated constructor that accepts various values.
    *
    * @note This constructor may be used to create a const instance in Flash
    *
    */
   template <typename Init, typename CallbackFunction, typename EnumType, size_t NumVectors>
   class InitVectors : public Init {
   
   public:
      /**
       * Copy Constructor
       */
      constexpr InitVectors(const InitVectors &other) = default;
   
     /**
      * Copy constructor
      *
      * @tparam Types
      * @param rest         Remaining parameters
   
      * @param other   Object to use as default value
      */
     template <typename... Types>
     constexpr InitVectors(const InitVectors &other, Types... rest) : InitVectors(rest...) {
        priorities = other.priorities;
        callbacks  = other.callbacks;
     }
   
      /**
       * Other constructors are inherited
       *
       * @tparam Types
       * @param rest
       */
      template <typename... Types>
      constexpr InitVectors(Types... rest) : Init(rest...) {
      }
   
      /**
       * Initialise Interrupt callbacks
       * (Used when only a single vector)
       *
       * @tparam Types
       * @param rest         Remaining parameters
   
       * @param nvicPriority Priority for the handler
       * @param callback     Callback function to use
       */
      template <typename... Types>
      constexpr InitVectors(CallbackFunction callback, NvicPriority nvicPriority, Types... rest) : InitVectors(rest...) {
         priorities[0]  = nvicPriority;
         callbacks[0]   = callback;
      }
   
      /**
       * Initialise Interrupt callbacks
       * (Used when only a single vector)
       *
       * @tparam Types
       * @param rest         Remaining parameters
   
       * @param nvicPriority Priority for the handler
       * @param callback     Callback function to use
       */
      template <typename... Types>
      constexpr InitVectors(NvicPriority nvicPriority, CallbackFunction callback, Types... rest) : InitVectors(rest...) {
         priorities[0]  = nvicPriority;
         callbacks[0]   = callback;
      }
   
      /**
       * Initialise Interrupt callbacks
       * (Multiple vectors)
       *
       * @tparam Types
       * @param rest         Remaining parameters
   
       * @param irqNum       Interrupt number
       * @param nvicPriority Priority for the handler
       * @param callback     Callback function to use
       */
      template <typename... Types>
      constexpr InitVectors(EnumType irqNum, NvicPriority nvicPriority, CallbackFunction callback, Types... rest) : InitVectors(rest...) {
         priorities[irqNum]  = nvicPriority;
         callbacks[irqNum]   = callback;
      }
   
      /**
       * Information describing the priority and callback function for each interrupt
       */
       std::array<CallbackFunction, NumVectors> callbacks = {};
       std::array<NvicPriority,     NumVectors> priorities = {};
   
   }; // class ---Symbol not found or format incorrect for substitution  => key=/Common_Settings/_BasicInfo, default=null, modifier=null---::InitVectors
   
/* Template:common_settings.xml */

   /**
    * Enables mapping of all allocated pins during startup using mapAllPins()
    * Not available on this MCU
    */
   static constexpr bool MapAllPinsOnStartup = false;

   /**
    * Controls forcing all pins to be locked in mapAllPins()
    * Not available on this MCU
    */
   static constexpr uint32_t ForceLockedPins = 0;
   static constexpr uint32_t PinLock_Locked  = 0;

   /**
    * Enables forcing unbonded pins to analogue function in mapAllPins()
    * Not available on this MCU
    */
   static constexpr bool ForceLockoutUnbondedPins = false;
   
// Use when in-lining makes the release build smaller
#ifdef DEBUG_BUILD
#define INLINE_RELEASE __attribute__((noinline))
#else
#define INLINE_RELEASE __attribute__((always_inline))
#endif

#ifdef DEBUG_BUILD
#define NOINLINE_DEBUG __attribute__((noinline))
#else
#define NOINLINE_DEBUG
#endif

   /**
    * Calculate a Vector number using an offset from an existing number.
    * This is only useful if related vectors are consecutive e.g. DMA0_IRQn, DMA1_IRQn ...
    *
    * @param vector  Base vector to use
    * @param offset  Offset from base vector
    *
    * @return  Vector number calculated from vector+offset
    */
   constexpr IRQn_Type inline operator+(IRQn_Type vector, unsigned offset) {
      return static_cast<IRQn_Type>(static_cast<unsigned>(vector) + offset);
   }

   /**
    * Calculate a Vector number using an offset from an existing number.
    * This is only useful if related vectors are consecutive e.g. DMA0_IRQn, DMA1_IRQn ...
    *
    * @param vector  Base vector to use
    * @param offset  Offset from base vector
    *
    * @return  Vector number calculated from vector+offset
    */
   constexpr IRQn_Type inline operator+(IRQn_Type vector, int offset) {
      return vector + static_cast<unsigned>(offset);
   }

   /**
    * @tparam  T  Type of comparison object (inferred)
    * @param   a  Left-hand object for comparison
    * @param   b  Right-hand object for comparison
    *
    * @return Smaller of a or b
    */
   template<class T>
   constexpr T min(const T a, const T b) {
      return (b < a) ? b : a;
   }

   /**
    * @tparam  T  Type of comparison object (inferred)
    * @param   a  Left-hand object for comparison
    * @param   b  Right-hand object for comparison
    *
    * @return Larger of a or b
    */
   template<class T>
   constexpr T max(const T a, const T b) {
      return (b > a) ? b : a;
   }

   constexpr IRQn_Type IRQn_None = static_cast<IRQn_Type>(-20);

   /**
    * Determine the number of elements in an array
    *
    * @tparam T      Deduced array type
    * @tparam N      Deduced array size
    *
    * @return  Size of array in elements
    */
   template<typename T, size_t N>
      consteval size_t sizeofArray(T (&)[N]) {
         return N;
      }

   /**
    * Enter critical section
    *
    * Disables interrupts for a critical section
    *
    * @param cpuSR Variable to hold interrupt state so it can be restored
    *
    * @code
    * uint8_t cpuSR;
    * ...
    * enterCriticalSection(cpuSR);
    *  // Critical section
    * exitCriticalSection(cpuSR);
    * @endcode
    */
   static inline void enterCriticalSection(uint8_t &cpuSR) {
      __asm__ volatile (
            "  MRS   r0, PRIMASK       \n"   // Copy flags
            // It may be possible for a ISR to run here but it
            // would save/restore PRIMASK so this code is OK
            "  CPSID I                 \n"   // Disable interrupts
            "  STRB  r0, %[output]     \n"   // Save flags
            : [output] "=m" (cpuSR) : : "r0");
   }

   /**
    * Exit critical section
    *
    * Restores interrupt state saved by enterCriticalSection()
    *
    * @param cpuSR Variable to holding interrupt state to be restored
    */
   static inline void exitCriticalSection(uint8_t &cpuSR) {
      __asm__ volatile (
            "  LDRB r0, %[input]    \n"  // Retrieve original flags
            "  MSR  PRIMASK,r0;     \n"  // Restore
            : :[input] "m" (cpuSR) : "r0");
   }

   /**
    * Class to implement simple critical sections by disabling interrupts.
    *
    * Disables interrupts for a critical section.
    * This would be from the declaration of the object until the end of
    * enclosing block. An object of this class should be declared at the
    * start of a block. e.g.
    * @code
    *    {
    *       CriticalSection cs;
    *       ...
    *       Protected code
    *       ...
    *    }
    * @endcode
    *
    * @note uses PRIMASK
    */
   class CriticalSection {
   
   private:
      /** Used to record interrupt state on entry */
      volatile uint32_t cpuSR;
   
   public:
      /**
       * Constructor - Enter critical section
       *
       * Disables interrupts for a critical section
       * This would be from the declaration of the object until end of enclosing block.
       */
      CriticalSection() __attribute__((always_inline)) {
         __asm__ volatile (
               "  MRS   r0, PRIMASK       \n"   // Copy flags
               // It may be possible for a ISR to run here but it
               // would save/restore PRIMASK so this code is OK
               "  CPSID I                 \n"   // Disable interrupts
               "  STR  r0, %[output]      \n"   // Save flags
               : [output] "=m" (cpuSR) : : "r0");
      }
   
      /**
       * Destructor - Exit critical section
       *
       * Enables interrupts IFF previously disabled by this object
       * This would be done implicitly by exiting the enclosing block.
       */
      inline ~CriticalSection() __attribute__((always_inline)) {
         __asm__ volatile (
               "  LDR r0, %[input]     \n"  // Retrieve original flags
               "  MSR  PRIMASK,r0;     \n"  // Restore
               : :[input] "m" (cpuSR) : "r0");
      }
   };
/* END Template:common_settings.xml */

/*
 * Peripheral Information Classes
 */
/**
 * @addtogroup GPIO_Group GPIO, Digital Input/Output
 * @brief Abstraction for Digital Input/Output
 * @{
 */
/**
 * Peripheral information for GPIO, Digital Input/Output.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class GpioAInfo {

public:
   /*
    * Template:fgpioa_mke
    */
   /**
    * Basic enable of GpioA
    * Includes enabling clock and configuring all mapped pins if mapPinsOnEnable is selected in configuration
    */
   static void enable() {
   }
   
   /**
    * Disables GpioA
    */
   static void disable() {
   
      
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = GPIOA_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<GPIO_Type> gpio = baseAddress;
   
}; // class GpioAInfo

/** 
 * End group GPIO_Group
 * @}
 */
/**
 * @addtogroup PMC_Group PMC, Power Management Controller
 * @brief Abstraction for Power Management Controller
 * @{
 */
/**
 * Peripheral information for PMC, Power Management Controller.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Low-Voltage Detect Enable
    * (pmc_spmsc1_lvde)
    *
    * This write-once bit enables low-voltage detect logic
    */
   enum PmcLowVoltageDetect {
      PmcLowVoltageDetect_Disabled   = PMC_SPMSC1_LVDE(0),  ///< LVD logic disabled
      PmcLowVoltageDetect_Enabled    = PMC_SPMSC1_LVDE(1),  ///< LVD logic enabled
   };

   /**
    * Low-Voltage Warning Interrupt Enable
    * (pmc_spmsc1_lvwie)
    *
    * Enables hardware interrupt requests for LVWF
    */
   enum PmcLowVoltageWarningInterrupt {
      PmcLowVoltageWarningInterrupt_Disabled   = PMC_SPMSC1_LVWIE(0),  ///< Interrupt disabled
      PmcLowVoltageWarningInterrupt_Enabled    = PMC_SPMSC1_LVWIE(1),  ///< Interrupt enabled
   };

   /**
    * Low-Voltage Detect Reset Enable
    * (pmc_spmsc1_lvdre)
    *
    * 
    */
   enum PmcLowVoltageReset {
      PmcLowVoltageReset_Disabled   = PMC_SPMSC1_LVDRE(0),  ///< LVD events do not generate hardware resets
      PmcLowVoltageReset_Enabled    = PMC_SPMSC1_LVDRE(1),  ///< Force an MCU reset when an enabled low-voltage detect event occurs
   };

   /**
    * Low-Voltage Detect Stop Enable
    * (pmc_spmsc1_lvdse)
    *
    * 
    */
   enum PmcLowVoltageDetectInStop {
      PmcLowVoltageDetectInStop_Disabled   = PMC_SPMSC1_LVDSE(0),  ///< LVD events disabled during stop mode
      PmcLowVoltageDetectInStop_Enabled    = PMC_SPMSC1_LVDSE(1),  ///< LVD events enabled during stop mode
   };

   /**
    * Bandgap Buffer Enable
    * (pmc_spmsc1_bgbe)
    *
    * Enables an internal buffer for the bandgap voltage reference for use
    * as a ADC internal channel or ACMP reference
    */
   enum PmcBandgapBuffer {
      PmcBandgapBuffer_Disabled   = PMC_SPMSC1_BGBE(0),  ///< Bandgap buffer is disabled
      PmcBandgapBuffer_Enabled    = PMC_SPMSC1_BGBE(1),  ///< Bandgap buffer is enabled
   };

   /**
    * Low-Voltage Detect Level Select
    * (pmc_spmsc2_lvdv)
    *
    * Write-once bit
    */
   enum PmcLowVoltageDetectLevel {
      PmcLowVoltageDetectLevel_LowTripPoint    = PMC_SPMSC2_LVDV(0),  ///< Low trip point (VLVD = VLVDL)
      PmcLowVoltageDetectLevel_HighTripPoint   = PMC_SPMSC2_LVDV(1),  ///< High trip point (VLVD = VLVDH)
   };

   /**
    * Low-Voltage Warning Level Select
    * (pmc_spmsc2_lvwv)
    *
    * 
    */
   enum PmcLowVoltageWarningLevel {
      PmcLowVoltageWarningLevel_LowTripPoint    = PMC_SPMSC2_LVWV(0),  ///< Low trip point (VLVW = VLVW1)
      PmcLowVoltageWarningLevel_Mid1TripPoint   = PMC_SPMSC2_LVWV(1),  ///< Mid 1 trip point (VLVW = VLVW2)
      PmcLowVoltageWarningLevel_Mid2TripPoint   = PMC_SPMSC2_LVWV(2),  ///< Mid 2 trip point (VLVW = VLVW3)
      PmcLowVoltageWarningLevel_HighTripPoint   = PMC_SPMSC2_LVWV(3),  ///< High trip point (VLVW = VLVW4)
   };

class PmcBasicInfo {

public:
}; // class PmcBasicInfo 

class PmcInfo : public PmcBasicInfo {

public:
   /*
    * Template:pmc_mke
    */
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = PMC_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(irqNums[0]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[0], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(irqNums[0]);
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = PMC_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<PMC_Type> pmc = baseAddress;
   
   //! Frequency of Low Power Oscillator (LPO) Clock [~1kHz]
   static constexpr uint32_t system_low_power_clock = 1000UL;

   /**
    * Get LPO clock
    *
    * @return frequency in Hz as uint32_t
    */
   static constexpr uint32_t getLpoClock() {
      return system_low_power_clock;
   }

}; // class PmcInfo

/** 
 * End group PMC_Group
 * @}
 */
/**
 * @addtogroup OSC_Group OSC, Crystal Oscillator
 * @brief Abstraction for Crystal Oscillator
 * @{
 */
/**
 * Peripheral information for OSC, Crystal Oscillator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * OSC0 mode
    * (osc_cr_oscMode)
    *
    * Determines oscillator power mode and
    * whether an external clock or crystal is used.
    */
   enum OscMode {
      OscMode_ExternalClock         = OSC_CR_OSCOS(0)|OSC_CR_HGO(0),  ///< External clock
      OscMode_LowPowerOscillator    = OSC_CR_OSCOS(1)|OSC_CR_HGO(0),  ///< Low Power Oscillator
      OscMode_HighPowerOscillator   = OSC_CR_OSCOS(1)|OSC_CR_HGO(1),  ///< High Gain Oscillator
   };

   /**
    * OSC Enable
    * (osc_cr_oscen)
    *
    * Enables the OSC module. The OSC module can also be enabled by the ICS module
    */
   enum OscEnable : uint8_t {
      OscEnable_Disabled   = OSC_CR_OSCEN(0),  ///< OSC disabled
      OscEnable_Enabled    = OSC_CR_OSCEN(1),  ///< OSC enabled
   };

   /**
    * OSC Enable in Stop mode
    * (osc_cr_oscsten)
    *
    * Controls whether or not the OSC clock remains enabled when MCU enters Stop mode when OSCEN is set.
    * OSCSTEN has no effect if ICS requests OSC enable
    */
   enum OscInStopMode : uint8_t {
      OscInStopMode_Disabled   = OSC_CR_OSCSTEN(0),  ///< Disabled in Stop mode
      OscInStopMode_Enabled    = OSC_CR_OSCSTEN(1),  ///< Enabled in Stop mode
   };

   /**
    * OSC Output Select
    * (osc_cr_oscos)
    *
    * Selects the output clock of the OSC module
    */
   enum OscOutputSelect {
      OscOutputSelect_ExternalClock   = OSC_CR_OSCOS(0),  ///< External clock source
      OscOutputSelect_Oscillator      = OSC_CR_OSCOS(1),  ///< Oscillator clock source
   };

   /**
    * Frequency Range Select
    * (osc_cr_range)
    *
    * Selects the frequency range for the OSC module
    */
   enum OscFrequencyRange {
      OscFrequencyRange_LowRange    = OSC_CR_RANGE(0),  ///< Low range of 32 kHz
      OscFrequencyRange_HighRange   = OSC_CR_RANGE(1),  ///< High range of 4-20 MHz
   };

   /**
    * High Gain Oscillator Select
    * (osc_cr_hgo)
    *
    * Controls the OSC mode of operation
    */
   enum OscCrHgo : uint8_t {
      OscCrHgo_LowPowerMode   = OSC_CR_HGO(0),  ///< Low-power mode
      OscCrHgo_HighGainMode   = OSC_CR_HGO(1),  ///< High-gain mode
   };

   /**
    * OSC Initialization
    * (osc_cr_oscinit)
    *
    * This field is set after the initialization cycles of oscillator are completed
    */
   enum OscStatus : uint8_t {
      OscStatus_NotReady   = OSC_CR_OSCINIT(0),  ///< Initialization is not complete
      OscStatus_Ready      = OSC_CR_OSCINIT(1),  ///< Initialization is completed
   };

class OscBasicInfo {

public:
}; // class OscBasicInfo 

class Osc0Info : public OscBasicInfo {

public:
   /*
    * Template:osc0_mke
    */
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = OSC0_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<OSC_Type> osc = baseAddress;
   
   //! Peripheral instance number
   static constexpr unsigned instance = 0;
   
   //! Frequency of OSC Clock or Crystal
   static constexpr uint32_t osc_clock = 
      0_Hz;  // (osc_clock)                Frequency of OSC Clock or Crystal [OSCCLK]
   
   /**
    * Get OSC clock
    *
    * @return Clock frequency as uint32_t in Hz
    */
   static uint32_t getOscClock() {
      switch(osc->CR&(OSC_CR_OSCINIT_MASK|OSC_CR_OSCOS_MASK)) {
         case OSC_CR_OSCINIT(0)|OSC_CR_OSCOS(0):
         case OSC_CR_OSCINIT(1)|OSC_CR_OSCOS(0):
            // External clock - assume valid
            return osc_clock;
            break;
         case OSC_CR_OSCINIT(1)|OSC_CR_OSCOS(1):
            // Oscillator selected and valid
            return (osc->CR&OSC_CR_OSCINIT_MASK)?osc_clock:0;
         default :
            return 0;
         break;
      }
   }

}; // class Osc0Info

/** 
 * End group OSC_Group
 * @}
 */
/**
 * @addtogroup RTC_Group RTC, Real Time Clock
 * @brief Abstraction for Real Time Clock
 * @{
 */
/**
 * Peripheral information for RTC, Real Time Clock.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Real-Time Interrupt Enable
    * (rtc_sc_rtie)
    *
    * This bit enables real-time interrupts.
    * If RTIE is set, then an interrupt is generated when RTIF is set
    */
   enum RtcInterrupt {
      RtcInterrupt_Disabled   = RTC_SC_RTIE(0),  ///< Disabled
      RtcInterrupt_Enabled    = RTC_SC_RTIE(1),  ///< Enabled
   };

   /**
    * Real-Time Counter Output
    * (rtc_sc_rtco)
    *
    * Enables the toggling of RTCO pin on overflow
    */
   enum RtcOutput {
      RtcOutput_OutputDisabled   = RTC_SC_RTCO(0),  ///< Output Disabled
      RtcOutput_OutputEnabled    = RTC_SC_RTCO(1),  ///< Output Enabled
   };

   /**
    * Real-Time Clock Source Select
    * (rtc_sc_rtclks)
    *
    * Selects the clock source for the RTC prescaler.
    * This also determines the prescaler range. 
    * Changing the clock source clears the prescaler and RTCCNT counters.
    */
   enum RtcClockSource {
      RtcClockSource_OscerClk   = RTC_SC_RTCLKS(0),  ///< External clock
      RtcClockSource_Lpoclk     = RTC_SC_RTCLKS(1),  ///< Low Power Oscillator (LPOCLK)
      RtcClockSource_Icsirclk   = RTC_SC_RTCLKS(2),  ///< Internal reference clock (ICSIRCLK)
      RtcClockSource_BusClock   = RTC_SC_RTCLKS(3),  ///< Bus clock
   };

   /**
    * Real-Time Clock Prescaler Select
    * (rtc_sc_rtcps)
    *
    * Selects binary-based or decimal-based divide-by values for the clock source.
    * Changing the prescaler value clears the prescaler and RTCCNT counters
    * Division factor depends on clock source chosen by RTCLKS
    */
   enum RtcPrescaler {
      RtcPrescaler_Off                = RTC_SC_RTCPS(0),  ///< Off
      RtcPrescaler_DivideBy1or128     = RTC_SC_RTCPS(1),  ///< Divide by 128
      RtcPrescaler_DivideBy2or256     = RTC_SC_RTCPS(1),  ///< Divide by 256
      RtcPrescaler_DivideBy4or512     = RTC_SC_RTCPS(1),  ///< Divide by 512
      RtcPrescaler_DivideBy8or1024    = RTC_SC_RTCPS(1),  ///< Divide by 1024
      RtcPrescaler_DivideBy16or2048   = RTC_SC_RTCPS(1),  ///< Divide by 2048
      RtcPrescaler_DivideBy32or100    = RTC_SC_RTCPS(1),  ///< Divide by 100
      RtcPrescaler_DivideBy64or1000   = RTC_SC_RTCPS(1),  ///< Divide by 1000
   };

class RtcBasicInfo {

public:
}; // class RtcBasicInfo 

class RtcInfo : public RtcBasicInfo {

public:
   /*
    * Template:rtcntr_mke
    */
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = RTC_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(irqNums[0]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[0], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(irqNums[0]);
   }
   
   /**
    *  Enable clock to Rtc
    */
   static void enableClock() {
      SIM->SCGC = SIM->SCGC | SIM_SCGC_RTC_MASK;
   }
   
   /**
    *  Disable clock to Rtc
    */
   static void disableClock() {
      SIM->SCGC = SIM->SCGC & ~SIM_SCGC_RTC_MASK;
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = RTC_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<RTC_Type> rtc = baseAddress;
   
}; // class RtcInfo

/** 
 * End group RTC_Group
 * @}
 */
/**
 * @addtogroup ICS_Group ICS, Multipurpose Clock Generator
 * @brief Abstraction for Multipurpose Clock Generator
 * @{
 */
/**
 * Peripheral information for ICS, Multipurpose Clock Generator.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * ICS Clock Mode
    * (icsClockMode[0])
    *
    * Selects the basic clock mode for the Clock generator
    */
   enum IcsClockMode : uint8_t {
      IcsClockMode_FEI     = 0,  ///< FLL Engaged Internal (FEI)
      IcsClockMode_FEE     = 1,  ///< FLL Engaged External (FEE)
      IcsClockMode_FBI     = 2,  ///< FLL bypassed internal (FBI)
      IcsClockMode_FBE     = 4,  ///< FLL bypassed external (FBE)
      IcsClockMode_FBILP   = 3,  ///< FLL bypassed low power internal (FBILP)
      IcsClockMode_FBELP   = 5,  ///< FLL bypassed low power external (FBELP)
   };

   /**
    * Clock Monitor Enable
    * (ics_c4_cme[0])
    *
    * Determines if a reset request is made following a loss of external clock indication.
    * The CME0 bit must only be when using an external clock mode (FEE, FBE, or FBELP)
    */
   enum IcsClockMonitor {
      IcsClockMonitor_Disabled   = ICS_C4_CME(0),  ///< Clock monitor disabled
      IcsClockMonitor_Enabled    = ICS_C4_CME(1),  ///< Clock monitor enabled
   };

   /**
    * Loss of Lock Interrupt Enable
    * (ics_c4_lolie0[0])
    *
    * Determines if an interrupt request is made following a loss of lock.
    * This is indicated by ICS_S[LOLS] being set.
    */
   enum IcsLossOfLockInterrupt {
      IcsLossOfLockInterrupt_Disabled   = ICS_C4_LOLIE0(0),  ///< Interrupt disabled
      IcsLossOfLockInterrupt_Enabled    = ICS_C4_LOLIE0(1),  ///< Interrupt enabled
   };

   /**
    * Internal Reference Clock [ICSIRCLK] enable
    * (ics_c1_irclken[0])
    *
    * Enables the internal reference clock for use by peripherals
    */
   enum IcsIrClkEn {
      IcsIrClkEn_Disabled   = ICS_C1_IRCLKEN(0),  ///< Disabled
      IcsIrClkEn_Enabled    = ICS_C1_IRCLKEN(1),  ///< Enabled
   };

   /**
    * Internal Reference [ICSIRCLK] Stop Enable
    * (ics_c1_irefsten[0])
    *
    * Controls whether or not the internal reference clock remains enabled when the ICS enters Stop mode.
    * (only if IRCLKEN is set or if ICS is in FEI, FBI, or FBILP modes before entering Stop mode)
    */
   enum IcsIrefs {
      IcsIrefs_DisabledInStop   = ICS_C1_IREFSTEN(0),  ///< IR disabled in STOP
      IcsIrefs_EnabledInStop    = ICS_C1_IREFSTEN(1),  ///< IR enabled in STOP
   };

   /**
    * FLL External Reference Divider
    * (ics_c1_rdiv[0])
    *
    * Selects the amount to divide down the external reference clock for the FLL.
    * The resulting frequency must be in [31.25 kHz to 39.0625 kHz] to be suitable for the FLL
    * Division factors choices depends on clock Range [OSC_C2_RANGE]
    */
   enum IcsFllPrescale {
      IcsFllPrescale_Disabled        = ICS_C1_RDIV(0),  ///< Disabled
      IcsFllPrescale_LowDivBy1       = ICS_C1_RDIV(0),  ///< /1 (low)
      IcsFllPrescale_LowDivBy2       = ICS_C1_RDIV(1),  ///< /2 (low)
      IcsFllPrescale_LowDivBy3       = ICS_C1_RDIV(2),  ///< /4 (low)
      IcsFllPrescale_LowDivBy8       = ICS_C1_RDIV(3),  ///< /8 (low)
      IcsFllPrescale_LowDivBy16      = ICS_C1_RDIV(4),  ///< /16 (low)
      IcsFllPrescale_LowDivBy32      = ICS_C1_RDIV(5),  ///< /32 (low)
      IcsFllPrescale_LowDivBy64      = ICS_C1_RDIV(6),  ///< /64 (low)
      IcsFllPrescale_LowDivBy128     = ICS_C1_RDIV(7),  ///< /128 (low)
      IcsFllPrescale_HighDivBy32     = ICS_C1_RDIV(0),  ///< /32 (high)
      IcsFllPrescale_HighDivBy64     = ICS_C1_RDIV(1),  ///< /64 (high)
      IcsFllPrescale_HighDivBy128    = ICS_C1_RDIV(2),  ///< /128 (high)
      IcsFllPrescale_HighDivBy256    = ICS_C1_RDIV(3),  ///< /256 (high)
      IcsFllPrescale_HighDivBy512    = ICS_C1_RDIV(4),  ///< /512 (high)
      IcsFllPrescale_HighDivBy1024   = ICS_C1_RDIV(5),  ///< /1024 (high)
      IcsFllPrescale_Reserved6       = ICS_C1_RDIV(6),  ///< Reserved
      IcsFllPrescale_Reserved7       = ICS_C1_RDIV(7),  ///< Reserved
   };

   /**
    * Internal Reference Select
    * (ics_c1_irefs[0])
    *
    * Selects the reference clock source for the FLL
    * This option is determined by the Clock Mode selection
    */
   enum IcsIref {
      IcsIref_External   = ICS_C1_IREFS(0),  ///< External Reference Clock
      IcsIref_Internal   = ICS_C1_IREFS(1),  ///< Internal Reference Clock
   };

   /**
    * ICS Output Clock Source Select
    * (ics_c1_clks[0])
    *
    * Selects the clock source for ICSOUTCLK
    * This option is determined by the Clock Mode selection
    */
   enum IcsClkSrc {
      IcsClkSrc_Fll    = ICS_C1_CLKS(0),  ///< Output of FLL
      IcsClkSrc_Iref   = ICS_C1_CLKS(1),  ///< Internal reference clock
      IcsClkSrc_Eref   = ICS_C1_CLKS(2),  ///< External reference clock
   };

   /**
    * Output divider for ICS
    * (ics_c2_bdiv[0])
    *
    * This divides the output of the ICS.
    * If in FEI mode and the ICS internal clock is not trimmed,
    * then BDIV should be &amp;gt;1 to prevent an excessive bus speed
    */
   enum IcsBusDivider {
      IcsBusDivider_DivideBy1     = ICS_C2_BDIV(0),  ///< Divide by 1
      IcsBusDivider_DivideBy2     = ICS_C2_BDIV(1),  ///< Divide by 2
      IcsBusDivider_DivideBy4     = ICS_C2_BDIV(2),  ///< Divide by 4
      IcsBusDivider_DivideBy8     = ICS_C2_BDIV(3),  ///< Divide by 8
      IcsBusDivider_DivideBy16    = ICS_C2_BDIV(4),  ///< Divide by 16
      IcsBusDivider_DivideBy32    = ICS_C2_BDIV(5),  ///< Divide by 32
      IcsBusDivider_DivideBy64    = ICS_C2_BDIV(6),  ///< Divide by 64
      IcsBusDivider_DivideBy128   = ICS_C2_BDIV(7),  ///< Divide by 128
   };

   /**
    * Low Power Select
    * (ics_c2_lp[0])
    *
    * Whether FLL continues operation when bypassed
    * This option is determined by the Clock Mode selection
    */
   enum IcsFllInLowpower {
      IcsFllInLowpower_Enabled    = ICS_C2_LP(0),  ///< FLL is enabled in bypass modes
      IcsFllInLowpower_Disabled   = ICS_C2_LP(1),  ///< FLL is disabled in bypass modes
   };

   /*
    * Global clock constants
    * These are provided when minimal clock generator code is used.
    * They assume no clock changes are made after startup.
    * Values provided are from USBDM configuration.
    */
   
   /**
    *  ICS Fixed Frequency Clock [ICSFFCLK]
    *  Used as input clock to FLL and available to some peripherals
    *  Derived from External Reference Clock or Slow IRC
    *  (Minimal configuration - definition)
    */
   constexpr uint32_t SystemIcsFFClock = 37500;
   
   /**
    *  ICS Output Clock [ICSOUTCLK]
    *  ICS Main clock output
    *  (Minimal configuration - definition)
    */
   constexpr uint32_t SystemIcsOutClock = 48000000;
   
   /**
    *  ICS FLL Output clock [ICSFLLCLK]
    *  Output of FLL.
    *  Available as ICSFLLCLK and used for ICSOUTCLK in FEI or FEE clock modes
    *  (Minimal configuration - definition)
    */
   constexpr uint32_t SystemIcsFllClock = 48000000;
   
class IcsBasicInfo {

public:
}; // class IcsBasicInfo 

class IcsInfo : public IcsBasicInfo {

public:
   /*
    * Template:ics_mke
    */
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = ICS_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(irqNums[0]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[0], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(irqNums[0]);
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = ICS_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<ICS_Type> ics = baseAddress;
   
   /// ICS_C2 value used for ICS minimal configuration
   static constexpr uint8_t ics_c2 = 
      IcsBusDivider_DivideBy1 | // (ics_c2_bdiv[0])           Output divider for ICS - Divide by 1
      IcsFllInLowpower_Enabled;  // (ics_c2_lp[0])             Low Power Select - FLL is enabled in bypass modes;
   
   /**
    * Get ICS External reference clock
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getExternalReferenceClock() {
   
      return Osc0Info::getOscClock();
   }

   //! ICS Internal Reference Clock
   static constexpr unsigned icsirclk = 37500;
   
   /**
    * Set Internal Reference Clock [ICSIRCLK] enable
    *
    * @param icsIrClkEn Enables the internal reference clock for use by peripherals
    */
   static void enableIcsIrClock(IcsIrClkEn icsIrClkEn) {
      ics->C1 = (ics->C1&~ICS_C1_IRCLKEN_MASK) | icsIrClkEn;
   }

   /**
    * Get Internal Reference Clock [ICSIRCLK] enable
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getUngatedInternalReferenceClock() {
      return icsirclk;
   }

   /**
    * Get Internal Reference Clock [ICSIRCLK] enable
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getInternalReferenceClock() {
   
      switch(ics->C1&ICS_C1_IRCLKEN_MASK) {
         default: return 0;
         case IcsIrClkEn_Disabled : return 0;        ///< Disabled
         case IcsIrClkEn_Enabled  : return icsirclk; ///< Enabled

      }
   }

   /**
    * Set ICS Output Clock Source Select
    *
    * @param icsClkSrc Selects the clock source for ICSOUTCLK
    *        This option is determined by the Clock Mode selection
    */
   static void configureC1Clks(IcsClkSrc icsClkSrc) {
      ics->C1 = (ics->C1&~ICS_C1_CLKS_MASK) | icsClkSrc;
   }

   /**
    * Set FLL External Reference Divider
    *
    * @param icsFllPrescale Selects the amount to divide down the external reference clock for the FLL.
    *        The resulting frequency must be in [31.25 kHz to 39.0625 kHz] to be suitable for the FLL
    *        Division factors choices depends on clock Range [OSC_C2_RANGE]
    */
   static void configureC1Rdiv(IcsFllPrescale icsFllPrescale) {
      ics->C1 = (ics->C1&~ICS_C1_RDIV_MASK) | icsFllPrescale;
   }

   /**
    * Set Internal Reference Select
    *
    * @param icsIref Selects the reference clock source for the FLL
    *        This option is determined by the Clock Mode selection
    */
   static void configureC1Irefs(IcsIref icsIref) {
      ics->C1 = (ics->C1&~ICS_C1_IREFS_MASK) | icsIref;
   }

   /**
    * Set Internal Reference Clock [ICSIRCLK] enable
    *
    * @param icsIrClkEn Enables the internal reference clock for use by peripherals
    */
   static void configureC1Irclken(IcsIrClkEn icsIrClkEn) {
      ics->C1 = (ics->C1&~ICS_C1_IRCLKEN_MASK) | icsIrClkEn;
   }

   /**
    * Set Internal Reference [ICSIRCLK] Stop Enable
    *
    * @param icsIrefs Controls whether or not the internal reference clock remains enabled when the ICS enters Stop mode.
    *        (only if IRCLKEN is set or if ICS is in FEI, FBI, or FBILP modes before entering Stop mode)
    */
   static void configureC1Irefsten(IcsIrefs icsIrefs) {
      ics->C1 = (ics->C1&~ICS_C1_IREFSTEN_MASK) | icsIrefs;
   }

   /**
    * Set Output divider for ICS
    *
    * @param icsBusDivider This divides the output of the ICS.
    *        If in FEI mode and the ICS internal clock is not trimmed,
    *        then BDIV should be &gt;1 to prevent an excessive bus speed
    */
   static void configureC2Bdiv(IcsBusDivider icsBusDivider) {
      ics->C2 = (ics->C2&~ICS_C2_BDIV_MASK) | icsBusDivider;
   }

   /**
    * Set Low Power Select
    *
    * @param icsFllInLowpower Whether FLL continues operation when bypassed
    *        This option is determined by the Clock Mode selection
    */
   static void configureC2Lp(IcsFllInLowpower icsFllInLowpower) {
      ics->C2 = (ics->C2&~ICS_C2_LP_MASK) | icsFllInLowpower;
   }

   /**
    * Set Loss of Lock Interrupt Enable
    *
    * @param icsLossOfLockInterrupt Determines if an interrupt request is made following a loss of lock.
    *        This is indicated by ICS_S[LOLS] being set.
    */
   static void configureC4Lolie0(IcsLossOfLockInterrupt icsLossOfLockInterrupt) {
      ics->C4 = (ics->C4&~ICS_C4_LOLIE0_MASK) | icsLossOfLockInterrupt;
   }

   /**
    * Set Clock Monitor Enable
    *
    * @param icsClockMonitor Determines if a reset request is made following a loss of external clock indication.
    *        The CME0 bit must only be when using an external clock mode (FEE, FBE, or FBELP)
    */
   static void configureC4Cme(IcsClockMonitor icsClockMonitor) {
      ics->C4 = (ics->C4&~ICS_C4_CME_MASK) | icsClockMonitor;
   }

}; // class IcsInfo

/** 
 * End group ICS_Group
 * @}
 */
/**
 * @addtogroup SIM_Group SIM, System Integration Module
 * @brief Abstraction for System Integration Module
 * @{
 */
/**
 * Peripheral information for SIM, System Integration Module.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Core/System Clock Divider value
    * (sim_clkdiv_outdiv1[0])
    *
    * This field sets the divide value for the core/system clock
    */
   enum SimCoreClkDivider {
      SimCoreClkDivider_Direct   = SIM_CLKDIV_OUTDIV1(0),  ///< ICSOUTCLK/1
      SimCoreClkDivider_DivBy2   = SIM_CLKDIV_OUTDIV1(1),  ///< ICSOUTCLK/2
      SimCoreClkDivider_DivBy3   = SIM_CLKDIV_OUTDIV1(2),  ///< ICSOUTCLK/3
      SimCoreClkDivider_DivBy4   = SIM_CLKDIV_OUTDIV1(3),  ///< ICSOUTCLK/4
   };

   /**
    * Bus/Flash Clock Divider value
    * (sim_clkdiv_outdiv2[0])
    *
    * This field sets the divide value for the bus/FLASH, follows OUTDIV1
    */
   enum SimBusClkDivider {
      SimBusClkDivider_Direct   = SIM_CLKDIV_OUTDIV2(0),  ///< Core clock/1
      SimBusClkDivider_DivBy2   = SIM_CLKDIV_OUTDIV2(1),  ///< Core clock/2
   };

   /**
    * Timer Clock Divider value
    * (sim_clkdiv_outdiv3[0])
    *
    * This field sets the divide value for the timers(FTM0, FTM2,PWT)
    */
   enum SimTimerClkDivider {
      SimTimerClkDivider_Direct   = SIM_CLKDIV_OUTDIV3(0),  ///< ICSOUTCLK/1
      SimTimerClkDivider_DivBy2   = SIM_CLKDIV_OUTDIV3(1),  ///< ICSOUTCLK/2
   };

   /**
    * SWD Clock Gate Control
    * (sim_scgc_swd)
    *
    * 
    */
   enum SimScgcSwd {
      SimScgcSwd_ClockDisabled   = SIM_SCGC_SWD(0),  ///< Clock disabled
      SimScgcSwd_ClockEnabled    = SIM_SCGC_SWD(1),  ///< Clock enabled
   };

   /**
    * Single Wire Debug Port Pin Enable
    * (sim_sopt_swde)
    *
    * Controls: 
    * PTA4 as PTA4/ACMP0_OUT or SWD_DIO, 
    * PTA0 as PTA0/KBI0_P0/FTM0_CH0/RTC_CLKOUT/ACMP0_IN2/ADC0_SE0 or SWD_CLK functions
    */
   enum SimSWDEnable {
      SimSWDEnable_Pta4Pta0AsPeripheralPins   = SIM_SOPT_SWDE(0),  ///< PTA4, PTA0 available for peripherals
      SimSWDEnable_Pta4Pta0AsSwdPins          = SIM_SOPT_SWDE(1),  ///< PTA4, PTA0 mapped as SWD pins
   };

   /**
    * RESET Pin Enable
    * (sim_sopt_rstpe)
    *
    * This field can only be written once after any reset
    */
   enum SimResetEnable {
      SimResetEnable_Pta5AsPeripheralPin   = SIM_SOPT_RSTPE(0),  ///< PTA5 available for peripherals
      SimResetEnable_Pta5AsReset           = SIM_SOPT_RSTPE(1),  ///< PTA5 mapped as RESET
   };

   /**
    * NMI Pin Enable
    * (sim_sopt_nmie)
    *
    * This field can only be written once after any reset
    */
   enum SimNmiEnable {
      SimNmiEnable_Ptb4AsPeripheralPins   = SIM_SOPT_NMIE(0),  ///< PTB4 available for peripherals
      SimNmiEnable_Ptb4AsNmi              = SIM_SOPT_NMIE(1),  ///< PTB4 mapped as NMI
   };

   /**
    * BUS Clock Output select
    * (sim_sopt_busref)
    *
    * Enable bus reference clock output on PTC5 with prescaler
    */
   enum SimSoptRefClock {
      SimSoptRefClock_Disabled               = SIM_SOPT_CLKOE(0)|SIM_SOPT_BUSREF(0),  ///< Disabled (PTC5 available)
      SimSoptRefClock_BusClock               = SIM_SOPT_CLKOE(1)|SIM_SOPT_BUSREF(0),  ///< Bus clock
      SimSoptRefClock_BusClockDividedBy2     = SIM_SOPT_CLKOE(1)|SIM_SOPT_BUSREF(1),  ///< Bus clock divided by 2
      SimSoptRefClock_BusClockDividedBy4     = SIM_SOPT_CLKOE(1)|SIM_SOPT_BUSREF(2),  ///< Bus clock divided by 4
      SimSoptRefClock_BusClockDividedBy8     = SIM_SOPT_CLKOE(1)|SIM_SOPT_BUSREF(3),  ///< Bus clock divided by 8
      SimSoptRefClock_BusClockDividedBy16    = SIM_SOPT_CLKOE(1)|SIM_SOPT_BUSREF(4),  ///< Bus clock divided by 16
      SimSoptRefClock_BusClockDividedBy32    = SIM_SOPT_CLKOE(1)|SIM_SOPT_BUSREF(5),  ///< Bus clock divided by 32
      SimSoptRefClock_BusClockDividedBy64    = SIM_SOPT_CLKOE(1)|SIM_SOPT_BUSREF(6),  ///< Bus clock divided by 64
      SimSoptRefClock_BusClockDividedBy128   = SIM_SOPT_CLKOE(1)|SIM_SOPT_BUSREF(7),  ///< Bus clock divided by 128
   };

   /**
    * ACMP0 Clock Gate Control
    * (sim_scgc_acmp0)
    *
    * 
    */
   enum SimScgcAcmp0 {
      SimScgcAcmp0_ClockDisabled   = SIM_SCGC_ACMP0(0),  ///< Clock disabled
      SimScgcAcmp0_ClockEnabled    = SIM_SCGC_ACMP0(1),  ///< Clock enabled
   };

   /**
    * ACMP1 Clock Gate Control
    * (sim_scgc_acmp1)
    *
    * 
    */
   enum SimScgcAcmp1 {
      SimScgcAcmp1_ClockDisabled   = SIM_SCGC_ACMP1(0),  ///< Clock disabled
      SimScgcAcmp1_ClockEnabled    = SIM_SCGC_ACMP1(1),  ///< Clock enabled
   };

   /**
    * ACMP Trigger FTM2 selection
    * (sim_sopt_actrg)
    *
    * Selects ACMP output used as the trigger0 input of FTM2
    */
   enum SimSoptActrg {
      SimSoptActrg_Acmp0_out   = SIM_SOPT_ACTRG(0),  ///< ACMP0_OUT
      SimSoptActrg_Acmp1_out   = SIM_SOPT_ACTRG(1),  ///< ACMP1_OUT
   };

   /**
    * ADC Clock Gate Control
    * (sim_scgc_adc0)
    *
    * 
    */
   enum SimScgcAdc {
      SimScgcAdc_ClockDisabled   = SIM_SCGC_ADC0(0),  ///< Clock disabled
      SimScgcAdc_ClockEnabled    = SIM_SCGC_ADC0(1),  ///< Clock enabled
   };

   /**
    * ADC Hardware Trigger Source
    * (sim_sopt_adhwt)
    *
    * Selects the ADC hardware trigger source. All trigger sources start ADC conversion on rising-edge
    */
   enum SimSoptAdhwt {
      SimSoptAdhwt_RtcOverflow                     = SIM_SOPT_ADHWT(0),  ///< RTC overflow
      SimSoptAdhwt_Ftm0                            = SIM_SOPT_ADHWT(1),  ///< FTM0
      SimSoptAdhwt_Ftm2InitTriggerWith8BitDelay    = SIM_SOPT_ADHWT(2),  ///< FTM2 init trigger with 8-bit delay
      SimSoptAdhwt_Ftm2MatchTriggerWith8BitDelay   = SIM_SOPT_ADHWT(3),  ///< FTM2 match trigger with 8-bit delay
      SimSoptAdhwt_PitChannel0Overflow             = SIM_SOPT_ADHWT(4),  ///< PIT channel 0 overflow
      SimSoptAdhwt_PitChannel1Overflow             = SIM_SOPT_ADHWT(5),  ///< PIT channel 1 overflow
      SimSoptAdhwt_Acmp0Out                        = SIM_SOPT_ADHWT(6),  ///< ACMP0 OUT
      SimSoptAdhwt_Acmp1Out                        = SIM_SOPT_ADHWT(7),  ///< ACMP1 OUT
   };

   /**
    * CRC Clock Gate Control
    * (sim_scgc_crc)
    *
    * 
    */
   enum SimScgcCrc {
      SimScgcCrc_ClockDisabled   = SIM_SCGC_CRC(0),  ///< Clock disabled
      SimScgcCrc_ClockEnabled    = SIM_SCGC_CRC(1),  ///< Clock enabled
   };

   /**
    * FLASH Clock Gate Control
    * (sim_scgc_flash)
    *
    * 
    */
   enum SimScgcFlash {
      SimScgcFlash_ClockDisabled   = SIM_SCGC_FLASH(0),  ///< Clock disabled
      SimScgcFlash_ClockEnabled    = SIM_SCGC_FLASH(1),  ///< Clock enabled
   };

   /**
    * FTM2 Synchronisation Select
    * (sim_sopt_ftmsync)
    *
    * Writing this field generates a PWM synchronisation trigger to the FTM2 module
    */
   enum SimSoptFtmsync {
      SimSoptFtmsync_GenerateFtmTrigger   = SIM_SOPT_FTMSYNC(1),  ///< Generates trigger
   };

   /**
    * FTM0 Clock Gate Control
    * (sim_scgc_ftm0)
    *
    * 
    */
   enum SimScgcFtm0 {
      SimScgcFtm0_ClockDisabled   = SIM_SCGC_FTM0(0),  ///< Clock disabled
      SimScgcFtm0_ClockEnabled    = SIM_SCGC_FTM0(1),  ///< Clock enabled
   };

   /**
    * FTM0 TCLK Pin Select
    * (sim_pinsel_ftm0clkps)
    *
    * 
    */
   enum SimPinselFtm0clkps {
      SimPinselFtm0clkps_Tclk1   = SIM_PINSEL_FTM0CLKPS(0),  ///< Selects TCLK1 for FTM0 module
      SimPinselFtm0clkps_Tclk2   = SIM_PINSEL_FTM0CLKPS(1),  ///< Selects TCLK2 for FTM0 module
   };

   /**
    * FTM0 channel 0 Pin Select
    * (sim_pinsel_ftm0ps0)
    *
    * 
    */
   enum SimPinselFtm0ps0 {
      SimPinselFtm0ps0_Pta0   = SIM_PINSEL_FTM0PS0(0),  ///< PTA0
      SimPinselFtm0ps0_Ptb2   = SIM_PINSEL_FTM0PS0(1),  ///< PTB2
   };

   /**
    * FTM0 channel 1 Pin Select
    * (sim_pinsel_ftm0ps1)
    *
    * 
    */
   enum SimPinselFtm0ps1 {
      SimPinselFtm0ps1_Pta1   = SIM_PINSEL_FTM0PS1(0),  ///< PTA1
      SimPinselFtm0ps1_Ptb3   = SIM_PINSEL_FTM0PS1(1),  ///< PTB3
   };

   /**
    * FTM0 channel 0 Input Capture Source
    * (sim_sopt_ftmic)
    *
    * Selects the sources for FTM0CH0 as capture input
    */
   enum SimSoptFtmic {
      SimSoptFtmic_Ftm0_ch0Pin   = SIM_SOPT_FTMIC(0),  ///< FTM0_CH0 pin
      SimSoptFtmic_Acmp0_out     = SIM_SOPT_FTMIC(1),  ///< ACMP0_OUT
      SimSoptFtmic_Acmp1_out     = SIM_SOPT_FTMIC(2),  ///< ACMP1_OUT
      SimSoptFtmic_RtcOverflow   = SIM_SOPT_FTMIC(3),  ///< RTC overflow
   };

   /**
    * UART0_RX Capture on FTM0 channel 1
    * (sim_sopt_rxdce)
    *
    * Enables the UART0_RX to be captured by FTM0 channel 1
    */
   enum SimSoptRxdce {
      SimSoptRxdce_NotConnected                      = SIM_SOPT_RXDCE(0),  ///< Not connected
      SimSoptRxdce_Uart0_rxConnectedAsFtm0Channel1   = SIM_SOPT_RXDCE(1),  ///< UART0_RX connected as FTM0 channel 1
   };

   /**
    * FTM2 Clock Gate Control
    * (sim_scgc_ftm2)
    *
    * 
    */
   enum SimScgcFtm2 {
      SimScgcFtm2_ClockDisabled   = SIM_SCGC_FTM2(0),  ///< Clock disabled
      SimScgcFtm2_ClockEnabled    = SIM_SCGC_FTM2(1),  ///< Clock enabled
   };

   /**
    * FTM2 TCLK Pin Select
    * (sim_pinsel_ftm2clkps)
    *
    * 
    */
   enum SimPinselFtm2clkps {
      SimPinselFtm2clkps_Tclk1   = SIM_PINSEL_FTM2CLKPS(0),  ///< Selects TCLK1 for FTM2 module
      SimPinselFtm2clkps_Tclk2   = SIM_PINSEL_FTM2CLKPS(1),  ///< Selects TCLK2 for FTM2 module
   };

   /**
    * FTM2 Channel 2 Pin Select
    * (sim_pinsel_ftm2ps2)
    *
    * 
    */
   enum SimPinselFtm2ps2 {
      SimPinselFtm2ps2_Ptc2   = SIM_PINSEL_FTM2PS2(0),  ///< PTC2
      SimPinselFtm2ps2_Ptc4   = SIM_PINSEL_FTM2PS2(1),  ///< PTC4
   };

   /**
    * FTM2 Channel 3 Pin Select
    * (sim_pinsel_ftm2ps3)
    *
    * 
    */
   enum SimPinselFtm2ps3 {
      SimPinselFtm2ps3_Ptc3   = SIM_PINSEL_FTM2PS3(0),  ///< PTC3
      SimPinselFtm2ps3_Ptc5   = SIM_PINSEL_FTM2PS3(1),  ///< PTC5
   };

   /**
    * I2C0 Clock Gate Control
    * (sim_scgc_i2c)
    *
    * 
    */
   enum SimScgcI2c0 {
      SimScgcI2c0_ClockDisabled   = SIM_SCGC_I2C(0),  ///< Clock disabled
      SimScgcI2c0_ClockEnabled    = SIM_SCGC_I2C(1),  ///< Clock enabled
   };

   /**
    * I2C0 Pin Select
    * (sim_pinsel_i2c0ps)
    *
    * 
    */
   enum SimPinselI2c0ps {
      SimPinselI2c0ps_Pta3Pta2MappedToI2c0   = SIM_PINSEL_I2C0PS(0),  ///< PTA3,PTA2 mapped to SCL,SDA
      SimPinselI2c0ps_Ptb7Ptb6MappedToI2c0   = SIM_PINSEL_I2C0PS(1),  ///< PTB7,PTB6 mapped to SCL,SDA
   };

   /**
    * IRQ Clock Gate Control
    * (sim_scgc_irq)
    *
    * 
    */
   enum SimScgcIrq {
      SimScgcIrq_ClockDisabled   = SIM_SCGC_IRQ(0),  ///< Clock disabled
      SimScgcIrq_ClockEnabled    = SIM_SCGC_IRQ(1),  ///< Clock enabled
   };

   /**
    * KBI0 Clock Gate Control
    * (sim_scgc_kbi0)
    *
    * 
    */
   enum SimScgcKbi0 {
      SimScgcKbi0_ClockDisabled   = SIM_SCGC_KBI0(0),  ///< Clock disabled
      SimScgcKbi0_ClockEnabled    = SIM_SCGC_KBI0(1),  ///< Clock enabled
   };

   /**
    * KBI1 Clock Gate Control
    * (sim_scgc_kbi1)
    *
    * 
    */
   enum SimScgcKbi1 {
      SimScgcKbi1_ClockDisabled   = SIM_SCGC_KBI1(0),  ///< Clock disabled
      SimScgcKbi1_ClockEnabled    = SIM_SCGC_KBI1(1),  ///< Clock enabled
   };

   /**
    * PIT Clock Gate Control
    * (sim_scgc_pit)
    *
    * 
    */
   enum SimScgcPit {
      SimScgcPit_ClockDisabled   = SIM_SCGC_PIT(0),  ///< Clock disabled
      SimScgcPit_ClockEnabled    = SIM_SCGC_PIT(1),  ///< Clock enabled
   };

   /**
    * PWT Clock Gate Control
    * (sim_scgc_pwt)
    *
    * 
    */
   enum SimScgcPwt {
      SimScgcPwt_ClockDisabled   = SIM_SCGC_PWT(0),  ///< Clock disabled
      SimScgcPwt_ClockEnabled    = SIM_SCGC_PWT(1),  ///< Clock enabled
   };

   /**
    * PWT TCLK Pin Select
    * (sim_pinsel_pwtclkps)
    *
    * 
    */
   enum SimPinselPwtclkps {
      SimPinselPwtclkps_Tclk1   = SIM_PINSEL_PWTCLKPS(0),  ///< Selects TCLK1 for PWT module
      SimPinselPwtclkps_Tclk2   = SIM_PINSEL_PWTCLKPS(1),  ///< Selects TCLK2 for PWT module
   };

   /**
    * RTC Clock Gate Control
    * (sim_scgc_rtc)
    *
    * 
    */
   enum SimScgcRtc {
      SimScgcRtc_ClockDisabled   = SIM_SCGC_RTC(0),  ///< Clock disabled
      SimScgcRtc_ClockEnabled    = SIM_SCGC_RTC(1),  ///< Clock enabled
   };

   /**
    * SPI0 Clock Gate Control
    * (sim_scgc_spi0)
    *
    * 
    */
   enum SimScgcSpi0 {
      SimScgcSpi0_ClockDisabled   = SIM_SCGC_SPI0(0),  ///< Clock disabled
      SimScgcSpi0_ClockEnabled    = SIM_SCGC_SPI0(1),  ///< Clock enabled
   };

   /**
    * SPI0 Pin Select
    * (sim_pinsel_spi0ps)
    *
    * Selects the SPI0 Pinouts
    */
   enum SimPinselSpi0ps {
      SimPinselSpi0ps_Ptb2Ptb3Ptb4Ptb5MappedToSpi0   = SIM_PINSEL_SPI0PS(0),  ///< PTB2,PTB3,PTB4,PTB5 mapped to SPI0 pins
      SimPinselSpi0ps_Pta6Pta7Ptb1Ptb0MappedToSpi0   = SIM_PINSEL_SPI0PS(1),  ///< PTA6,PTA7,PTB1,PTB0 mapped to SPI0 pins
   };

   /**
    * UART0 Clock Gate Control
    * (sim_scgc_uart0)
    *
    * 
    */
   enum SimScgcUart0 {
      SimScgcUart0_ClockDisabled   = SIM_SCGC_UART0(0),  ///< Clock disabled
      SimScgcUart0_ClockEnabled    = SIM_SCGC_UART0(1),  ///< Clock enabled
   };

   /**
    * UART0 Pin Select
    * (sim_pinsel_uart0ps)
    *
    * 
    */
   enum SimPinselUart0ps {
      SimPinselUart0ps_MappedToPtb1Ptb0   = SIM_PINSEL_UART0PS(0),  ///< PTB1,PTB0 mapped to Tx,Rx
      SimPinselUart0ps_MappedToPta3Pta2   = SIM_PINSEL_UART0PS(1),  ///< PTA3,PTA2 mapped to Tx,Rx
   };

   /**
    * UART0_TX Modulation Select
    * (sim_sopt_txdme)
    *
    * Enables the UART0_TX output modulated by FTM0 channel 0
    */
   enum SimSoptTxdme {
      SimSoptTxdme_Uart0_txDirectlyConnectedToPin   = SIM_SOPT_TXDME(0),  ///< UART0_TX directly connected to pin
      SimSoptTxdme_Uart0_txModulatedByFtm0Channel   = SIM_SOPT_TXDME(1),  ///< UART0_TX modulated by FTM0 channel
   };

   /**
    * UART0_RX Filter Select
    * (sim_sopt_rxdfe)
    *
    * Enables the UART0_RX input to be filtered by ACMP.
    * When this function is enabled, any signal tagged with ACMP inputs can be regarded as UART0
    */
   enum SimSoptRxdfe {
      SimSoptRxdfe_Uart0ModuleDirectly   = SIM_SOPT_RXDFE(0),  ///< UART0 module directly
      SimSoptRxdfe_FilteredByAcmp0       = SIM_SOPT_RXDFE(1),  ///< Filtered by ACMP0
      SimSoptRxdfe_FilteredByAcmp1       = SIM_SOPT_RXDFE(2),  ///< Filtered by ACMP1
   };

   /**
    *  System Core Clock
    *  Clock for CORE (CPU) and SYSTEM (NVIC, RAM, ...)
    *  (Minimal configuration - definition)
    */
   constexpr uint32_t SystemCoreClock = 48000000;
   
   /**
    *  System Bus Clock
    *  Clock for Bus (PIT, I2C, SPI, UART, ...)
    *  (Minimal configuration - definition)
    */
   constexpr uint32_t SystemBusClock = 48000000;
   
   /**
    *  System Timer Clock
    *  Clock for timers (FTM, PWT, ...)
    *  (Minimal configuration - definition)
    */
   constexpr uint32_t SystemTimerClock = 48000000;
   
class SimBasicInfo {

public:
   /**
    * Class used to do initialisation of the Sim
    *
    * This class has a templated constructor that accepts various values.
    *
    * @note This constructor may be used to create a const instance in Flash
    *
    * Example:
    * @code
    * static const Sim::Init init {
    *
    *   // Setup values
    *
    *   0 , // FTM2 Trigger Delay
    *   SimSoptAdhwt_RtcOverflow , // ADC Hardware Trigger Source - RTC overflow
    *   SimSoptReferenceClockOutput_Disabled , // BUS Clock Output select - Disabled (PTC5 available)
    *   SimSoptTxdme_Uart0_txDirectlyConnectedToPin , // UART0_TX Modulation Select - UART0_TX directly connected to pin
    *   SimSoptRxdce_NotConnected , // UART0_RX Capture on FTM0 channel 1 - Not connected
    *   SimSoptRxdfe_Uart0ModuleDirectly , // UART0_RX Filter Select - UART0 module directly
    *   SimSoptFtmic_Ftm0_ch0Pin , // FTM0 channel 0 Input Capture Source - FTM0_CH0 pin
    *   SimSoptActrg_Acmp0_out , // ACMP Trigger FTM2 selection - ACMP0_OUT
    *   SimSWDEnable_Pta4Pta0AsSwdPins , // Single Wire Debug Port Pin Enable - PTA4, PTA0 mapped as SWD pins
    *   SimResetEnable_Pta5AsReset , // RESET Pin Enable - PTA5 mapped as RESET
    *   SimNmiEnable_Ptb4AsNmi , // NMI Pin Enable - PTB4 mapped as NMI
    *   SimPinselPwtclkps_SelectsTclk1ForPwtModule , // PWT TCLK Pin Select - Selects TCLK1 for PWT module
    *   SimPinselFtm2clkps_SelectsTclk1ForFtm2Module , // FTM2 TCLK Pin Select - Selects TCLK1 for FTM2 module
    *   SimPinselFtm0clkps_SelectsTclk1ForFtm0Module , // FTM0 TCLK Pin Select - Selects TCLK1 for FTM0 module
    *   SimPinselFtm2ps3_Ptc3 , // FTM2 Channel 3 Pin Select - PTC3
    *   SimPinselFtm2ps2_Ptc2 , // FTM2 Channel 2 Pin Select - PTC2
    *   SimPinselFtm0ps1_Pta1 , // FTM0 channel 1 Pin Select - PTA1
    *   SimPinselFtm0ps0_Pta0 , // FTM0 channel 0 Pin Select - PTA0
    *   SimPinselUart0ps_MappedToPtb1Ptb0 , // UART0 Pin Select - PTB1,PTB0 mapped to Tx,Rx
    *   SimPinselSpi0ps_Ptb2Ptb3Ptb4Ptb5MappedToSpi0 , // SPI0 Pin Select - PTB2,PTB3,PTB4,PTB5 mapped to SPI0 pins
    *   SimPinselI2c0ps_Pta3Pta2MappedToI2c0 , // I2C0 Pin Select - PTA3,PTA2 mapped to SCL,SDA
    *   SimScgcAcmp1_ClockDisabled , // ACMP1 Clock Gate Control - Clock disabled
    *   SimScgcAcmp0_ClockDisabled , // ACMP0 Clock Gate Control - Clock disabled
    *   SimScgcAdc_ClockDisabled , // ADC Clock Gate Control - Clock disabled
    *   SimScgcIrq_ClockDisabled , // IRQ Clock Gate Control - Clock disabled
    *   SimScgcKbi1_ClockDisabled , // KBI1 Clock Gate Control - Clock disabled
    *   SimScgcKbi0_ClockDisabled , // KBI0 Clock Gate Control - Clock disabled
    *   SimScgcUart0_ClockEnabled , // UART0 Clock Gate Control - Clock enabled
    *   SimScgcSpi0_ClockDisabled , // SPI0 Clock Gate Control - Clock disabled
    *   SimScgcI2c_ClockDisabled , // I2C0 Clock Gate Control - Clock disabled
    *   SimScgcSwd_ClockEnabled , // SWD Clock Gate Control - Clock enabled
    *   SimScgcFlash_ClockEnabled , // FLASH Clock Gate Control - Clock enabled
    *   SimScgcCrc_ClockDisabled , // CRC Clock Gate Control - Clock disabled
    *   SimScgcFtm2_ClockDisabled , // FTM2 Clock Gate Control - Clock disabled
    *   SimScgcFtm0_ClockDisabled , // FTM0 Clock Gate Control - Clock disabled
    *   SimScgcPwt_ClockDisabled , // PWT Clock Gate Control - Clock disabled
    *   SimScgcPit_ClockDisabled , // PIT Clock Gate Control - Clock disabled
    *   SimScgcRtc_ClockDisabled,  // RTC Clock Gate Control - Clock disabled
    * };
    *
    * // Initialise Sim from values specified above
    * Sim::configure(init)
    * @endcode
    */
   class Init {
   
   public:
      /**
       * Copy Constructor
       */
      constexpr Init(const Init &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr Init() = default;
   
      // FTM2 Trigger Delay (sim_sopt_delay)
      // ADC Hardware Trigger Source (sim_sopt_adhwt)
      // BUS Clock Output select (sim_sopt_busref)
      // UART0_TX Modulation Select (sim_sopt_txdme)
      // FTM2 Synchronisation Select (sim_sopt_ftmsync)
      // UART0_RX Capture on FTM0 channel 1 (sim_sopt_rxdce)
      // UART0_RX Filter Select (sim_sopt_rxdfe)
      // FTM0 channel 0 Input Capture Source (sim_sopt_ftmic)
      // ACMP Trigger FTM2 selection (sim_sopt_actrg)
      // Single Wire Debug Port Pin Enable (sim_sopt_swde)
      // RESET Pin Enable (sim_sopt_rstpe)
      // NMI Pin Enable (sim_sopt_nmie)
      uint32_t sopt = 0;

      // PWT TCLK Pin Select (sim_pinsel_pwtclkps)
      // FTM2 TCLK Pin Select (sim_pinsel_ftm2clkps)
      // FTM0 TCLK Pin Select (sim_pinsel_ftm0clkps)
      // FTM2 Channel 3 Pin Select (sim_pinsel_ftm2ps3)
      // FTM2 Channel 2 Pin Select (sim_pinsel_ftm2ps2)
      // FTM0 channel 1 Pin Select (sim_pinsel_ftm0ps1)
      // FTM0 channel 0 Pin Select (sim_pinsel_ftm0ps0)
      // UART0 Pin Select (sim_pinsel_uart0ps)
      // SPI0 Pin Select (sim_pinsel_spi0ps)
      // I2C0 Pin Select (sim_pinsel_i2c0ps)
      uint32_t pinsel = 0;

      // ACMP1 Clock Gate Control (sim_scgc_acmp1)
      // ACMP0 Clock Gate Control (sim_scgc_acmp0)
      // IRQ Clock Gate Control (sim_scgc_irq)
      // KBI1 Clock Gate Control (sim_scgc_kbi1)
      // KBI0 Clock Gate Control (sim_scgc_kbi0)
      // UART0 Clock Gate Control (sim_scgc_uart0)
      // SPI0 Clock Gate Control (sim_scgc_spi0)
      // I2C0 Clock Gate Control (sim_scgc_i2c)
      // SWD Clock Gate Control (sim_scgc_swd)
      // FLASH Clock Gate Control (sim_scgc_flash)
      // CRC Clock Gate Control (sim_scgc_crc)
      // FTM2 Clock Gate Control (sim_scgc_ftm2)
      // FTM0 Clock Gate Control (sim_scgc_ftm0)
      // PWT Clock Gate Control (sim_scgc_pwt)
      // PIT Clock Gate Control (sim_scgc_pit)
      // RTC Clock Gate Control (sim_scgc_rtc)
      uint32_t scgc = 0;

      /**
       * Constructor for ADC Hardware Trigger Source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simSoptAdhwt Selects the ADC hardware trigger source. All trigger sources start ADC conversion on rising-edge
       */
      template <typename... Types>
      constexpr Init(SimSoptAdhwt simSoptAdhwt, Types... rest) : Init(rest...) {
   
         sopt = (sopt&~SIM_SOPT_ADHWT_MASK) | simSoptAdhwt;
      }
   
      /**
       * Constructor for BUS Clock Output select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simSoptRefClock Enable bus reference clock output on PTC5 with prescaler
       */
      template <typename... Types>
      constexpr Init(SimSoptRefClock simSoptRefClock, Types... rest) : Init(rest...) {
   
         sopt = (sopt&~(SIM_SOPT_CLKOE_MASK|SIM_SOPT_BUSREF_MASK)) | simSoptRefClock;
      }
   
      /**
       * Constructor for UART0_TX Modulation Select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simSoptTxdme Enables the UART0_TX output modulated by FTM0 channel 0
       */
      template <typename... Types>
      constexpr Init(SimSoptTxdme simSoptTxdme, Types... rest) : Init(rest...) {
   
         sopt = (sopt&~SIM_SOPT_TXDME_MASK) | simSoptTxdme;
      }
   
      /**
       * Constructor for FTM2 Synchronisation Select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simSoptFtmsync Writing this field generates a PWM synchronisation trigger to the FTM2 module
       */
      template <typename... Types>
      constexpr Init(SimSoptFtmsync simSoptFtmsync, Types... rest) : Init(rest...) {
   
         sopt = (sopt&~SIM_SOPT_FTMSYNC_MASK) | simSoptFtmsync;
      }
   
      /**
       * Constructor for UART0_RX Capture on FTM0 channel 1
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simSoptRxdce Enables the UART0_RX to be captured by FTM0 channel 1
       */
      template <typename... Types>
      constexpr Init(SimSoptRxdce simSoptRxdce, Types... rest) : Init(rest...) {
   
         sopt = (sopt&~SIM_SOPT_RXDCE_MASK) | simSoptRxdce;
      }
   
      /**
       * Constructor for UART0_RX Filter Select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simSoptRxdfe Enables the UART0_RX input to be filtered by ACMP.
       *        When this function is enabled, any signal tagged with ACMP inputs can be regarded as UART0
       */
      template <typename... Types>
      constexpr Init(SimSoptRxdfe simSoptRxdfe, Types... rest) : Init(rest...) {
   
         sopt = (sopt&~SIM_SOPT_RXDFE_MASK) | simSoptRxdfe;
      }
   
      /**
       * Constructor for FTM0 channel 0 Input Capture Source
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simSoptFtmic Selects the sources for FTM0CH0 as capture input
       */
      template <typename... Types>
      constexpr Init(SimSoptFtmic simSoptFtmic, Types... rest) : Init(rest...) {
   
         sopt = (sopt&~SIM_SOPT_FTMIC_MASK) | simSoptFtmic;
      }
   
      /**
       * Constructor for ACMP Trigger FTM2 selection
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simSoptActrg Selects ACMP output used as the trigger0 input of FTM2
       */
      template <typename... Types>
      constexpr Init(SimSoptActrg simSoptActrg, Types... rest) : Init(rest...) {
   
         sopt = (sopt&~SIM_SOPT_ACTRG_MASK) | simSoptActrg;
      }
   
      /**
       * Constructor for Single Wire Debug Port Pin Enable
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simSWDEnable Controls: 
       *        PTA4 as PTA4/ACMP0_OUT or SWD_DIO, 
       *        PTA0 as PTA0/KBI0_P0/FTM0_CH0/RTC_CLKOUT/ACMP0_IN2/ADC0_SE0 or SWD_CLK functions
       */
      template <typename... Types>
      constexpr Init(SimSWDEnable simSWDEnable, Types... rest) : Init(rest...) {
   
         sopt = (sopt&~SIM_SOPT_SWDE_MASK) | simSWDEnable;
      }
   
      /**
       * Constructor for RESET Pin Enable
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simResetEnable This field can only be written once after any reset
       */
      template <typename... Types>
      constexpr Init(SimResetEnable simResetEnable, Types... rest) : Init(rest...) {
   
         sopt = (sopt&~SIM_SOPT_RSTPE_MASK) | simResetEnable;
      }
   
      /**
       * Constructor for NMI Pin Enable
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simNmiEnable This field can only be written once after any reset
       */
      template <typename... Types>
      constexpr Init(SimNmiEnable simNmiEnable, Types... rest) : Init(rest...) {
   
         sopt = (sopt&~SIM_SOPT_NMIE_MASK) | simNmiEnable;
      }
   
      /**
       * Constructor for PWT TCLK Pin Select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simPinselPwtclkps 
       */
      template <typename... Types>
      constexpr Init(SimPinselPwtclkps simPinselPwtclkps, Types... rest) : Init(rest...) {
   
         pinsel = (pinsel&~SIM_PINSEL_PWTCLKPS_MASK) | simPinselPwtclkps;
      }
   
      /**
       * Constructor for FTM2 TCLK Pin Select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simPinselFtm2clkps 
       */
      template <typename... Types>
      constexpr Init(SimPinselFtm2clkps simPinselFtm2clkps, Types... rest) : Init(rest...) {
   
         pinsel = (pinsel&~SIM_PINSEL_FTM2CLKPS_MASK) | simPinselFtm2clkps;
      }
   
      /**
       * Constructor for FTM0 TCLK Pin Select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simPinselFtm0clkps 
       */
      template <typename... Types>
      constexpr Init(SimPinselFtm0clkps simPinselFtm0clkps, Types... rest) : Init(rest...) {
   
         pinsel = (pinsel&~SIM_PINSEL_FTM0CLKPS_MASK) | simPinselFtm0clkps;
      }
   
      /**
       * Constructor for FTM2 Channel 3 Pin Select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simPinselFtm2ps3 
       */
      template <typename... Types>
      constexpr Init(SimPinselFtm2ps3 simPinselFtm2ps3, Types... rest) : Init(rest...) {
   
         pinsel = (pinsel&~SIM_PINSEL_FTM2PS3_MASK) | simPinselFtm2ps3;
      }
   
      /**
       * Constructor for FTM2 Channel 2 Pin Select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simPinselFtm2ps2 
       */
      template <typename... Types>
      constexpr Init(SimPinselFtm2ps2 simPinselFtm2ps2, Types... rest) : Init(rest...) {
   
         pinsel = (pinsel&~SIM_PINSEL_FTM2PS2_MASK) | simPinselFtm2ps2;
      }
   
      /**
       * Constructor for FTM0 channel 1 Pin Select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simPinselFtm0ps1 
       */
      template <typename... Types>
      constexpr Init(SimPinselFtm0ps1 simPinselFtm0ps1, Types... rest) : Init(rest...) {
   
         pinsel = (pinsel&~SIM_PINSEL_FTM0PS1_MASK) | simPinselFtm0ps1;
      }
   
      /**
       * Constructor for FTM0 channel 0 Pin Select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simPinselFtm0ps0 
       */
      template <typename... Types>
      constexpr Init(SimPinselFtm0ps0 simPinselFtm0ps0, Types... rest) : Init(rest...) {
   
         pinsel = (pinsel&~SIM_PINSEL_FTM0PS0_MASK) | simPinselFtm0ps0;
      }
   
      /**
       * Constructor for UART0 Pin Select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simPinselUart0ps 
       */
      template <typename... Types>
      constexpr Init(SimPinselUart0ps simPinselUart0ps, Types... rest) : Init(rest...) {
   
         pinsel = (pinsel&~SIM_PINSEL_UART0PS_MASK) | simPinselUart0ps;
      }
   
      /**
       * Constructor for SPI0 Pin Select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simPinselSpi0ps Selects the SPI0 Pinouts
       */
      template <typename... Types>
      constexpr Init(SimPinselSpi0ps simPinselSpi0ps, Types... rest) : Init(rest...) {
   
         pinsel = (pinsel&~SIM_PINSEL_SPI0PS_MASK) | simPinselSpi0ps;
      }
   
      /**
       * Constructor for I2C0 Pin Select
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simPinselI2c0ps 
       */
      template <typename... Types>
      constexpr Init(SimPinselI2c0ps simPinselI2c0ps, Types... rest) : Init(rest...) {
   
         pinsel = (pinsel&~SIM_PINSEL_I2C0PS_MASK) | simPinselI2c0ps;
      }
   
      /**
       * Constructor for ACMP1 Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simScgcAcmp1 
       */
      template <typename... Types>
      constexpr Init(SimScgcAcmp1 simScgcAcmp1, Types... rest) : Init(rest...) {
   
         scgc = (scgc&~SIM_SCGC_ACMP1_MASK) | simScgcAcmp1;
      }
   
      /**
       * Constructor for ACMP0 Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simScgcAcmp0 
       */
      template <typename... Types>
      constexpr Init(SimScgcAcmp0 simScgcAcmp0, Types... rest) : Init(rest...) {
   
         scgc = (scgc&~SIM_SCGC_ACMP0_MASK) | simScgcAcmp0;
      }
   
      /**
       * Constructor for IRQ Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simScgcIrq 
       */
      template <typename... Types>
      constexpr Init(SimScgcIrq simScgcIrq, Types... rest) : Init(rest...) {
   
         scgc = (scgc&~SIM_SCGC_IRQ_MASK) | simScgcIrq;
      }
   
      /**
       * Constructor for KBI1 Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simScgcKbi1 
       */
      template <typename... Types>
      constexpr Init(SimScgcKbi1 simScgcKbi1, Types... rest) : Init(rest...) {
   
         scgc = (scgc&~SIM_SCGC_KBI1_MASK) | simScgcKbi1;
      }
   
      /**
       * Constructor for KBI0 Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simScgcKbi0 
       */
      template <typename... Types>
      constexpr Init(SimScgcKbi0 simScgcKbi0, Types... rest) : Init(rest...) {
   
         scgc = (scgc&~SIM_SCGC_KBI0_MASK) | simScgcKbi0;
      }
   
      /**
       * Constructor for UART0 Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simScgcUart0 
       */
      template <typename... Types>
      constexpr Init(SimScgcUart0 simScgcUart0, Types... rest) : Init(rest...) {
   
         scgc = (scgc&~SIM_SCGC_UART0_MASK) | simScgcUart0;
      }
   
      /**
       * Constructor for SPI0 Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simScgcSpi0 
       */
      template <typename... Types>
      constexpr Init(SimScgcSpi0 simScgcSpi0, Types... rest) : Init(rest...) {
   
         scgc = (scgc&~SIM_SCGC_SPI0_MASK) | simScgcSpi0;
      }
   
      /**
       * Constructor for I2C0 Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simScgcI2c0 
       */
      template <typename... Types>
      constexpr Init(SimScgcI2c0 simScgcI2c0, Types... rest) : Init(rest...) {
   
         scgc = (scgc&~SIM_SCGC_I2C_MASK) | simScgcI2c0;
      }
   
      /**
       * Constructor for SWD Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simScgcSwd 
       */
      template <typename... Types>
      constexpr Init(SimScgcSwd simScgcSwd, Types... rest) : Init(rest...) {
   
         scgc = (scgc&~SIM_SCGC_SWD_MASK) | simScgcSwd;
      }
   
      /**
       * Constructor for FLASH Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simScgcFlash 
       */
      template <typename... Types>
      constexpr Init(SimScgcFlash simScgcFlash, Types... rest) : Init(rest...) {
   
         scgc = (scgc&~SIM_SCGC_FLASH_MASK) | simScgcFlash;
      }
   
      /**
       * Constructor for CRC Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simScgcCrc 
       */
      template <typename... Types>
      constexpr Init(SimScgcCrc simScgcCrc, Types... rest) : Init(rest...) {
   
         scgc = (scgc&~SIM_SCGC_CRC_MASK) | simScgcCrc;
      }
   
      /**
       * Constructor for FTM2 Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simScgcFtm2 
       */
      template <typename... Types>
      constexpr Init(SimScgcFtm2 simScgcFtm2, Types... rest) : Init(rest...) {
   
         scgc = (scgc&~SIM_SCGC_FTM2_MASK) | simScgcFtm2;
      }
   
      /**
       * Constructor for FTM0 Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simScgcFtm0 
       */
      template <typename... Types>
      constexpr Init(SimScgcFtm0 simScgcFtm0, Types... rest) : Init(rest...) {
   
         scgc = (scgc&~SIM_SCGC_FTM0_MASK) | simScgcFtm0;
      }
   
      /**
       * Constructor for PWT Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simScgcPwt 
       */
      template <typename... Types>
      constexpr Init(SimScgcPwt simScgcPwt, Types... rest) : Init(rest...) {
   
         scgc = (scgc&~SIM_SCGC_PWT_MASK) | simScgcPwt;
      }
   
      /**
       * Constructor for PIT Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simScgcPit 
       */
      template <typename... Types>
      constexpr Init(SimScgcPit simScgcPit, Types... rest) : Init(rest...) {
   
         scgc = (scgc&~SIM_SCGC_PIT_MASK) | simScgcPit;
      }
   
      /**
       * Constructor for RTC Clock Gate Control
       *
       * @tparam   Types
       * @param    rest
       *
       * @param simScgcRtc 
       */
      template <typename... Types>
      constexpr Init(SimScgcRtc simScgcRtc, Types... rest) : Init(rest...) {
   
         scgc = (scgc&~SIM_SCGC_RTC_MASK) | simScgcRtc;
      }
   
      /**
       * Constructor for FTM2 Trigger Delay
       *
       * @tparam   Types
       * @param    rest
       *
       * @param ticks Specifies the delay from FTM2 initial or match trigger to ADC hardware trigger when 1 is written to ADHWT.
       *        The 8-bit modulo value allows the delay from 0 to 255 upon the BUSREF clock settings.
       *        This is a one-shot counter that starts ticking when the trigger arrives and stops ticking when the counter 
       *        value reaches the modulo value that is defined
       */
      template <typename... Types>
      constexpr Init(const Ticks& ticks, Types... rest) : Init(rest...) {
   
         sopt = (sopt&~SIM_SOPT_DELAY_MASK) | SIM_SOPT_DELAY(ticks);
      }
   
   }; // class Sim::BasicInfo::Init

   /*
    * Global clocks constants
    * These are provided when minimal clock generator code is used.
    * They assume no clock changes are made after startup.
    * Values provided are from USBDM configuration.
    */
   
}; // class SimBasicInfo 

class SimInfo : public SimBasicInfo {

public:
   /*
    * Template:sim_mke04z4
    */
   /**
    * Basic enable of Sim
    * Includes enabling clock and configuring all mapped pins if mapPinsOnEnable is selected in configuration
    */
   static void enable() {
   }
   
   /**
    * Disables Sim
    */
   static void disable() {
   
      
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = SIM_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<SIM_Type> sim = baseAddress;
   
   /// This input is available as an external clock source for the timers
   static constexpr uint32_t Tclk1 =  0_Hz;  // (Tclk1)                    Timer External clock input #1;
   
   /// This input is available as an external clock source for the timers
   static constexpr uint32_t Tclk2 =  0_Hz;  // (Tclk2)                    Timer External clock input #2;
   
   /**
    * Get FTM0 TCLK Pin Select
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getFtm0ExternalClockFrequency() {
   
      switch(sim->PINSEL&SIM_PINSEL_FTM0CLKPS_MASK) {
         default: return 0;
         case SimPinselFtm0clkps_Tclk1 : return Tclk1; ///< Selects TCLK1 for FTM0 module
         case SimPinselFtm0clkps_Tclk2 : return Tclk2; ///< Selects TCLK2 for FTM0 module

      }
   }

   /**
    * Get FTM2 TCLK Pin Select
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getFtm2ExternalClockFrequency() {
   
      switch(sim->PINSEL&SIM_PINSEL_FTM2CLKPS_MASK) {
         default: return 0;
         case SimPinselFtm2clkps_Tclk1 : return Tclk1; ///< Selects TCLK1 for FTM2 module
         case SimPinselFtm2clkps_Tclk2 : return Tclk2; ///< Selects TCLK2 for FTM2 module

      }
   }

   /**
    * Get PWT TCLK Pin Select
    *
    * @return Clock frequency in Hz
    */
   static uint32_t getPwtExternalClockFrequency() {
   
      switch(sim->PINSEL&SIM_PINSEL_PWTCLKPS_MASK) {
         default: return 0;
         case SimPinselPwtclkps_Tclk1 : return Tclk1; ///< Selects TCLK1 for PWT module
         case SimPinselPwtclkps_Tclk2 : return Tclk2; ///< Selects TCLK2 for PWT module

      }
   }

   /**
    * FTM2 Synchronisation Select
    *
    * @param simSoptFtmsync Writing this field generates a PWM synchronisation trigger to the FTM2 module
    */
   static void triggerFtm2() {
      sim->SOPT |= SIM_SOPT_FTMSYNC_MASK;
   }

   /**
    * Set FTM2 Trigger Delay
    *
    * @param ticks Specifies the delay from FTM2 initial or match trigger to ADC hardware trigger when 1 is written to ADHWT.
    *        The 8-bit modulo value allows the delay from 0 to 255 upon the BUSREF clock settings.
    *        This is a one-shot counter that starts ticking when the trigger arrives and stops ticking when the counter 
    *        value reaches the modulo value that is defined
    */
   static void configureFtm2Delay(const Ticks& ticks) {
      sim->SOPT = (sim->SOPT&~SIM_SOPT_DELAY_MASK) | SIM_SOPT_DELAY(ticks);
   }

   /**
    * Set ADC Hardware Trigger Source
    *
    * @param simSoptAdhwt Selects the ADC hardware trigger source. All trigger sources start ADC conversion on rising-edge
    */
   static void configureSoptAdhwt(SimSoptAdhwt simSoptAdhwt) {
      sim->SOPT = (sim->SOPT&~SIM_SOPT_ADHWT_MASK) | simSoptAdhwt;
   }

   /**
    * Set BUS Clock Output select
    *
    * @param simSoptRefClock Enable bus reference clock output on PTC5 with prescaler
    */
   static void configureSoptClkOut(SimSoptRefClock simSoptRefClock) {
      sim->SOPT = (sim->SOPT&~(SIM_SOPT_CLKOE_MASK|SIM_SOPT_BUSREF_MASK)) | simSoptRefClock;
   }

   /**
    * Set UART0_TX Modulation Select
    *
    * @param simSoptTxdme Enables the UART0_TX output modulated by FTM0 channel 0
    */
   static void configureSoptTxdme(SimSoptTxdme simSoptTxdme) {
      sim->SOPT = (sim->SOPT&~SIM_SOPT_TXDME_MASK) | simSoptTxdme;
   }

   /**
    * Set UART0_RX Capture on FTM0 channel 1
    *
    * @param simSoptRxdce Enables the UART0_RX to be captured by FTM0 channel 1
    */
   static void configureSoptRxdce(SimSoptRxdce simSoptRxdce) {
      sim->SOPT = (sim->SOPT&~SIM_SOPT_RXDCE_MASK) | simSoptRxdce;
   }

   /**
    * Set FTM0 channel 0 Input Capture Source
    *
    * @param simSoptFtmic Selects the sources for FTM0CH0 as capture input
    */
   static void configureSoptFtmic(SimSoptFtmic simSoptFtmic) {
      sim->SOPT = (sim->SOPT&~SIM_SOPT_FTMIC_MASK) | simSoptFtmic;
   }

   /**
    * Set UART0_RX Filter Select
    *
    * @param simSoptRxdfe Enables the UART0_RX input to be filtered by ACMP.
    *        When this function is enabled, any signal tagged with ACMP inputs can be regarded as UART0
    */
   static void configureSoptRxdfe(SimSoptRxdfe simSoptRxdfe) {
      sim->SOPT = (sim->SOPT&~SIM_SOPT_RXDFE_MASK) | simSoptRxdfe;
   }

   /**
    * Set ACMP Trigger FTM2 selection
    *
    * @param simSoptActrg Selects ACMP output used as the trigger0 input of FTM2
    */
   static void configureSoptActrg(SimSoptActrg simSoptActrg) {
      sim->SOPT = (sim->SOPT&~SIM_SOPT_ACTRG_MASK) | simSoptActrg;
   }

   /**
    * Set Single Wire Debug Port Pin Enable
    *
    * @param simSWDEnable Controls: 
    *        PTA4 as PTA4/ACMP0_OUT or SWD_DIO, 
    *        PTA0 as PTA0/KBI0_P0/FTM0_CH0/RTC_CLKOUT/ACMP0_IN2/ADC0_SE0 or SWD_CLK functions
    */
   static void configureSingleWireDebugPins(SimSWDEnable simSWDEnable) {
      sim->SOPT = (sim->SOPT&~SIM_SOPT_SWDE_MASK) | simSWDEnable;
   }

   /**
    * Set RESET Pin Enable
    *
    * @param simResetEnable This field can only be written once after any reset
    */
   static void configureResetPin(SimResetEnable simResetEnable) {
      sim->SOPT = (sim->SOPT&~SIM_SOPT_RSTPE_MASK) | simResetEnable;
   }

   /**
    * Set NMI Pin Enable
    *
    * @param simNmiEnable This field can only be written once after any reset
    */
   static void configureNonMaskableInterruptPin(SimNmiEnable simNmiEnable) {
      sim->SOPT = (sim->SOPT&~SIM_SOPT_NMIE_MASK) | simNmiEnable;
   }

   /**
    * Set PWT TCLK Pin Select
    *
    * @param simPinselPwtclkps 
    */
   static void selectPwtExternalClockPin(SimPinselPwtclkps simPinselPwtclkps) {
      sim->PINSEL = (sim->PINSEL&~SIM_PINSEL_PWTCLKPS_MASK) | simPinselPwtclkps;
   }

   /**
    * Set FTM2 TCLK Pin Select
    *
    * @param simPinselFtm2clkps 
    */
   static void selectFtm2ExternalClockPin(SimPinselFtm2clkps simPinselFtm2clkps) {
      sim->PINSEL = (sim->PINSEL&~SIM_PINSEL_FTM2CLKPS_MASK) | simPinselFtm2clkps;
   }

   /**
    * Set FTM0 TCLK Pin Select
    *
    * @param simPinselFtm0clkps 
    */
   static void selectFtm0ExternalClockPin(SimPinselFtm0clkps simPinselFtm0clkps) {
      sim->PINSEL = (sim->PINSEL&~SIM_PINSEL_FTM0CLKPS_MASK) | simPinselFtm0clkps;
   }

   /**
    * Set FTM2 Channel 3 Pin Select
    *
    * @param simPinselFtm2ps3 
    */
   static void selectFtm2Ch3Pin(SimPinselFtm2ps3 simPinselFtm2ps3) {
      sim->PINSEL = (sim->PINSEL&~SIM_PINSEL_FTM2PS3_MASK) | simPinselFtm2ps3;
   }

   /**
    * Set FTM2 Channel 2 Pin Select
    *
    * @param simPinselFtm2ps2 
    */
   static void selectFtm2Ch2Pin(SimPinselFtm2ps2 simPinselFtm2ps2) {
      sim->PINSEL = (sim->PINSEL&~SIM_PINSEL_FTM2PS2_MASK) | simPinselFtm2ps2;
   }

   /**
    * Set FTM0 channel 1 Pin Select
    *
    * @param simPinselFtm0ps1 
    */
   static void selectFtm0Ch1Pin(SimPinselFtm0ps1 simPinselFtm0ps1) {
      sim->PINSEL = (sim->PINSEL&~SIM_PINSEL_FTM0PS1_MASK) | simPinselFtm0ps1;
   }

   /**
    * Set FTM0 channel 0 Pin Select
    *
    * @param simPinselFtm0ps0 
    */
   static void selectFtm0Ch0Pin(SimPinselFtm0ps0 simPinselFtm0ps0) {
      sim->PINSEL = (sim->PINSEL&~SIM_PINSEL_FTM0PS0_MASK) | simPinselFtm0ps0;
   }

   /**
    * Set UART0 Pin Select
    *
    * @param simPinselUart0ps 
    */
   static void selectUart0Pins(SimPinselUart0ps simPinselUart0ps) {
      sim->PINSEL = (sim->PINSEL&~SIM_PINSEL_UART0PS_MASK) | simPinselUart0ps;
   }

   /**
    * Set SPI0 Pin Select
    *
    * @param simPinselSpi0ps Selects the SPI0 Pinouts
    */
   static void selectSpi0Pins(SimPinselSpi0ps simPinselSpi0ps) {
      sim->PINSEL = (sim->PINSEL&~SIM_PINSEL_SPI0PS_MASK) | simPinselSpi0ps;
   }

   /**
    * Set I2C0 Pin Select
    *
    * @param simPinselI2c0ps 
    */
   static void selectI2c0Pins(SimPinselI2c0ps simPinselI2c0ps) {
      sim->PINSEL = (sim->PINSEL&~SIM_PINSEL_I2C0PS_MASK) | simPinselI2c0ps;
   }

   /**
    * Get ACMP0 Clock Gate Control
    */
   static bool getAcmp0ClockEnable() {
      return sim->SCGC & SIM_SCGC_ACMP0_MASK;
   }
   
   /**
    * Disable ACMP0 Clock Gate Control
    */
   static void enableAcmp0Clock() {
      sim->SCGC = sim->SCGC | SIM_SCGC_ACMP0_MASK;
   }
   
   /**
    * Enable ACMP0 Clock Gate Control
    */
   static void disableAcmp0Clock() {
      sim->SCGC = sim->SCGC & ~SIM_SCGC_ACMP0_MASK;
   }

   /**
    * Get ACMP1 Clock Gate Control
    */
   static bool getAcmp1ClockEnable() {
      return sim->SCGC & SIM_SCGC_ACMP1_MASK;
   }
   
   /**
    * Disable ACMP1 Clock Gate Control
    */
   static void enableAcmp1Clock() {
      sim->SCGC = sim->SCGC | SIM_SCGC_ACMP1_MASK;
   }
   
   /**
    * Enable ACMP1 Clock Gate Control
    */
   static void disableAcmp1Clock() {
      sim->SCGC = sim->SCGC & ~SIM_SCGC_ACMP1_MASK;
   }

   /**
    * Get IRQ Clock Gate Control
    */
   static bool getIrqClockEnable() {
      return sim->SCGC & SIM_SCGC_IRQ_MASK;
   }
   
   /**
    * Disable IRQ Clock Gate Control
    */
   static void enableIrqClock() {
      sim->SCGC = sim->SCGC | SIM_SCGC_IRQ_MASK;
   }
   
   /**
    * Enable IRQ Clock Gate Control
    */
   static void disableIrqClock() {
      sim->SCGC = sim->SCGC & ~SIM_SCGC_IRQ_MASK;
   }

   /**
    * Get KBI1 Clock Gate Control
    */
   static bool getKbi1ClockEnable() {
      return sim->SCGC & SIM_SCGC_KBI1_MASK;
   }
   
   /**
    * Disable KBI1 Clock Gate Control
    */
   static void enableKbi1Clock() {
      sim->SCGC = sim->SCGC | SIM_SCGC_KBI1_MASK;
   }
   
   /**
    * Enable KBI1 Clock Gate Control
    */
   static void disableKbi1Clock() {
      sim->SCGC = sim->SCGC & ~SIM_SCGC_KBI1_MASK;
   }

   /**
    * Get KBI0 Clock Gate Control
    */
   static bool getKbi0ClockEnable() {
      return sim->SCGC & SIM_SCGC_KBI0_MASK;
   }
   
   /**
    * Disable KBI0 Clock Gate Control
    */
   static void enableKbi0Clock() {
      sim->SCGC = sim->SCGC | SIM_SCGC_KBI0_MASK;
   }
   
   /**
    * Enable KBI0 Clock Gate Control
    */
   static void disableKbi0Clock() {
      sim->SCGC = sim->SCGC & ~SIM_SCGC_KBI0_MASK;
   }

   /**
    * Get UART0 Clock Gate Control
    */
   static bool getUart0ClockEnable() {
      return sim->SCGC & SIM_SCGC_UART0_MASK;
   }
   
   /**
    * Disable UART0 Clock Gate Control
    */
   static void enableUart0Clock() {
      sim->SCGC = sim->SCGC | SIM_SCGC_UART0_MASK;
   }
   
   /**
    * Enable UART0 Clock Gate Control
    */
   static void disableUart0Clock() {
      sim->SCGC = sim->SCGC & ~SIM_SCGC_UART0_MASK;
   }

   /**
    * Get SPI0 Clock Gate Control
    */
   static bool getSpi0ClockEnable() {
      return sim->SCGC & SIM_SCGC_SPI0_MASK;
   }
   
   /**
    * Disable SPI0 Clock Gate Control
    */
   static void enableSpi0Clock() {
      sim->SCGC = sim->SCGC | SIM_SCGC_SPI0_MASK;
   }
   
   /**
    * Enable SPI0 Clock Gate Control
    */
   static void disableSpi0Clock() {
      sim->SCGC = sim->SCGC & ~SIM_SCGC_SPI0_MASK;
   }

   /**
    * Get I2C0 Clock Gate Control
    */
   static bool getI2c0ClockEnable() {
      return sim->SCGC & SIM_SCGC_I2C_MASK;
   }
   
   /**
    * Disable I2C0 Clock Gate Control
    */
   static void enableI2c0Clock() {
      sim->SCGC = sim->SCGC | SIM_SCGC_I2C_MASK;
   }
   
   /**
    * Enable I2C0 Clock Gate Control
    */
   static void disableI2c0Clock() {
      sim->SCGC = sim->SCGC & ~SIM_SCGC_I2C_MASK;
   }

   /**
    * Get SWD Clock Gate Control
    */
   static bool getSwdClockEnable() {
      return sim->SCGC & SIM_SCGC_SWD_MASK;
   }
   
   /**
    * Disable SWD Clock Gate Control
    */
   static void enableSwdClock() {
      sim->SCGC = sim->SCGC | SIM_SCGC_SWD_MASK;
   }
   
   /**
    * Enable SWD Clock Gate Control
    */
   static void disableSwdClock() {
      sim->SCGC = sim->SCGC & ~SIM_SCGC_SWD_MASK;
   }

   /**
    * Get FLASH Clock Gate Control
    */
   static bool getFlashClockEnable() {
      return sim->SCGC & SIM_SCGC_FLASH_MASK;
   }
   
   /**
    * Disable FLASH Clock Gate Control
    */
   static void enableFlashClock() {
      sim->SCGC = sim->SCGC | SIM_SCGC_FLASH_MASK;
   }
   
   /**
    * Enable FLASH Clock Gate Control
    */
   static void disableFlashClock() {
      sim->SCGC = sim->SCGC & ~SIM_SCGC_FLASH_MASK;
   }

   /**
    * Get CRC Clock Gate Control
    */
   static bool getCrcClockEnable() {
      return sim->SCGC & SIM_SCGC_CRC_MASK;
   }
   
   /**
    * Disable CRC Clock Gate Control
    */
   static void enableCrcClock() {
      sim->SCGC = sim->SCGC | SIM_SCGC_CRC_MASK;
   }
   
   /**
    * Enable CRC Clock Gate Control
    */
   static void disableCrcClock() {
      sim->SCGC = sim->SCGC & ~SIM_SCGC_CRC_MASK;
   }

   /**
    * Get FTM0 Clock Gate Control
    */
   static bool getFtm0ClockEnable() {
      return sim->SCGC & SIM_SCGC_FTM0_MASK;
   }
   
   /**
    * Disable FTM0 Clock Gate Control
    */
   static void enableFtm0Clock() {
      sim->SCGC = sim->SCGC | SIM_SCGC_FTM0_MASK;
   }
   
   /**
    * Enable FTM0 Clock Gate Control
    */
   static void disableFtm0Clock() {
      sim->SCGC = sim->SCGC & ~SIM_SCGC_FTM0_MASK;
   }

   /**
    * Get FTM2 Clock Gate Control
    */
   static bool getFtm2ClockEnable() {
      return sim->SCGC & SIM_SCGC_FTM2_MASK;
   }
   
   /**
    * Disable FTM2 Clock Gate Control
    */
   static void enableFtm2Clock() {
      sim->SCGC = sim->SCGC | SIM_SCGC_FTM2_MASK;
   }
   
   /**
    * Enable FTM2 Clock Gate Control
    */
   static void disableFtm2Clock() {
      sim->SCGC = sim->SCGC & ~SIM_SCGC_FTM2_MASK;
   }

   /**
    * Get PWT Clock Gate Control
    */
   static bool getPwtClockEnable() {
      return sim->SCGC & SIM_SCGC_PWT_MASK;
   }
   
   /**
    * Disable PWT Clock Gate Control
    */
   static void enablePwtClock() {
      sim->SCGC = sim->SCGC | SIM_SCGC_PWT_MASK;
   }
   
   /**
    * Enable PWT Clock Gate Control
    */
   static void disablePwtClock() {
      sim->SCGC = sim->SCGC & ~SIM_SCGC_PWT_MASK;
   }

   /**
    * Get PIT Clock Gate Control
    */
   static bool getPitClockEnable() {
      return sim->SCGC & SIM_SCGC_PIT_MASK;
   }
   
   /**
    * Disable PIT Clock Gate Control
    */
   static void enablePitClock() {
      sim->SCGC = sim->SCGC | SIM_SCGC_PIT_MASK;
   }
   
   /**
    * Enable PIT Clock Gate Control
    */
   static void disablePitClock() {
      sim->SCGC = sim->SCGC & ~SIM_SCGC_PIT_MASK;
   }

   /**
    * Get RTC Clock Gate Control
    */
   static bool getRtcClockEnable() {
      return sim->SCGC & SIM_SCGC_RTC_MASK;
   }
   
   /**
    * Disable RTC Clock Gate Control
    */
   static void enableRtcClock() {
      sim->SCGC = sim->SCGC | SIM_SCGC_RTC_MASK;
   }
   
   /**
    * Enable RTC Clock Gate Control
    */
   static void disableRtcClock() {
      sim->SCGC = sim->SCGC & ~SIM_SCGC_RTC_MASK;
   }

   /**
    * Set Core/System Clock Divider value
    *
    * @param simCoreClkDivider This field sets the divide value for the core/system clock
    */
   static void setCoreClkDivider(SimCoreClkDivider simCoreClkDivider) {
      sim->CLKDIV = (sim->CLKDIV&~SIM_CLKDIV_OUTDIV1_MASK) | simCoreClkDivider;
   }

   /**
    * Set Bus/Flash Clock Divider value
    *
    * @param simBusClkDivider This field sets the divide value for the bus/FLASH, follows OUTDIV1
    */
   static void setBusClockDivider(SimBusClkDivider simBusClkDivider) {
      sim->CLKDIV = (sim->CLKDIV&~SIM_CLKDIV_OUTDIV2_MASK) | simBusClkDivider;
   }

   /**
    * Set Timer Clock Divider value
    *
    * @param simTimerClkDivider This field sets the divide value for the timers(FTM0, FTM2,PWT)
    */
   static void setTimerClockDivider(SimTimerClkDivider simTimerClkDivider) {
      sim->CLKDIV = (sim->CLKDIV&~SIM_CLKDIV_OUTDIV3_MASK) | simTimerClkDivider;
   }

   /**
    * Default initialisation value for Sim
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr Init DefaultInitValue = {
      SimSoptRefClock_Disabled , // (sim_sopt_busref)          BUS Clock Output select - Disabled (PTC5 available)
      SimSWDEnable_Pta4Pta0AsSwdPins , // (sim_sopt_swde)            Single Wire Debug Port Pin Enable - PTA4, PTA0 mapped as SWD pins
      SimResetEnable_Pta5AsReset , // (sim_sopt_rstpe)           RESET Pin Enable - PTA5 mapped as RESET
      SimPinselUart0ps_MappedToPta3Pta2 , // (sim_pinsel_uart0ps)       UART0 Pin Select - PTA3,PTA2 mapped to Tx,Rx
      SimScgcSwd_ClockEnabled , // (sim_scgc_swd)             SWD Clock Gate Control - Clock enabled
      SimScgcFlash_ClockEnabled , // (sim_scgc_flash)           FLASH Clock Gate Control - Clock enabled
   };

   /**
    * Configure SIM
    *
    * This only includes SOPT, PINSEL and SCGC
    */
   static void configure(const Init &configValue) {
      sim->SOPT            = configValue.sopt;
      sim->PINSEL          = configValue.pinsel;
      sim->SCGC            = configValue.scgc;
   }
   
   /**
    * Default initialisation for SIM
    */
   static void defaultConfigure() {
      configure(DefaultInitValue);
   }
   
   /*
    * Template:sim_commonTemplates.xml
    */ 
   //! Frequency of Low Power Oscillator (LPO) Clock [~1kHz]
   static constexpr uint32_t system_low_power_clock = 1000UL;

   /**
    * Get LPO clock
    *
    * @return frequency in Hz as uint32_t
    */
   static constexpr uint32_t getLpoClock() {
      return system_low_power_clock;
   }

   /** Reset clock divider value if clock not fully configured */
   static constexpr uint32_t sim_clkdiv = 
      SimCoreClkDivider_Direct | // (sim_clkdiv_outdiv1[0])    Core/System Clock Divider value - ICSOUTCLK/1
      SimBusClkDivider_Direct | // (sim_clkdiv_outdiv2[0])    Bus/Flash Clock Divider value - Core clock/1
      SimTimerClkDivider_Direct;  // (sim_clkdiv_outdiv3[0])    Timer Clock Divider value - ICSOUTCLK/1;
   
   /**
    * Get UART0 input clock frequency
    *
    * @return Clock frequency in Hz
    */
   static inline uint32_t getUart0Clock() {
      return SystemBusClock;
   }

}; // class SimInfo

/** 
 * End group SIM_Group
 * @}
 */
/**
 * @addtogroup Control_Group CONTROL, Control
 * @brief Abstraction for Control
 * @{
 */
/**
 * Peripheral information for CONTROL, Control.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class ControlInfo {

public:
   /*
    * Template:control
    */
}; // class ControlInfo

/** 
 * End group Control_Group
 * @}
 */
/**
 * @addtogroup CONSOLE_Group Console, Console Interface
 * @brief Abstraction for Console Interface
 * @{
 */
/**
 * Peripheral information for Console, Console Interface.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * UART baud rate
    * (console_baudrate)
    *
    * Baud rate for UART
    * Values available will depend on peripheral clock frequency
    */
   enum UartBaudRate : uint32_t {
      UartBaudRate_110      = 110,     ///< 110
      UartBaudRate_300      = 300,     ///< 300
      UartBaudRate_600      = 600,     ///< 600
      UartBaudRate_1200     = 1200,    ///< 1200
      UartBaudRate_2400     = 2400,    ///< 2400
      UartBaudRate_4800     = 4800,    ///< 4800
      UartBaudRate_9600     = 9600,    ///< 9600
      UartBaudRate_14400    = 14400,   ///< 14400
      UartBaudRate_19200    = 19200,   ///< 19200
      UartBaudRate_28800    = 28800,   ///< 28800
      UartBaudRate_38400    = 38400,   ///< 38400
      UartBaudRate_56000    = 56000,   ///< 56000
      UartBaudRate_57600    = 57600,   ///< 57600
      UartBaudRate_115200   = 115200,  ///< 115200
   };

class ConsoleInfo {

public:
   /*
    * Template:console
    */
}; // class ConsoleInfo

/** 
 * End group CONSOLE_Group
 * @}
 */
/**
 * @addtogroup FTM_Group FTM, PWM, Input capture and Output compare
 * @brief Abstraction for PWM, Input capture and Output compare
 * @{
 */
/**
 * Peripheral information for FTM, PWM, Input capture and Output compare.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class FtmInfo {

public:
   /*
    * Template:ftm
    */
}; // class FtmInfo

/** 
 * End group FTM_Group
 * @}
 */
/**
 * @addtogroup IRQ_Group IRQ, Direct Memory Access (DMA)
 * @brief Abstraction for Direct Memory Access (DMA)
 * @{
 */
/**
 * Peripheral information for IRQ, Direct Memory Access (DMA).
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * IRQ Pin Enable
    * (irq_sc_irqpe)
    *
    * Selectively enables the IRQ pin
    */
   enum IrqPinEnable {
      IrqPinEnable_Disabled   = IRQ_SC_IRQPE(0),  ///< Disabled
      IrqPinEnable_Enabled    = IRQ_SC_IRQPE(1),  ///< Enabled
   };

   /**
    * Interrupt Request (IRQ) Pull Device Disable
    * (irq_sc_irqpdd)
    *
    * Controls pull-up device on IRQ pin
    */
   enum IrqPullUp {
      IrqPullUp_Enabled    = IRQ_SC_IRQPDD(0),  ///< Pull-up Enabled
      IrqPullUp_Disabled   = IRQ_SC_IRQPDD(1),  ///< Pull-up Disabled
   };

   /**
    * IRQ Detection Mode
    * (irq_sc_irqmod)
    *
    * Selects edge/level and polarity to trigger event
    */
   enum IrqMode {
      IrqMode_FallingEdgeOnly         = IRQ_SC_IRQMOD(0)|IRQ_SC_IRQEDG(0),  ///< Falling Edge only
      IrqMode_FallingEdgeOrLowLevel   = IRQ_SC_IRQMOD(1)|IRQ_SC_IRQEDG(0),  ///< Falling Edge or Low level
      IrqMode_RisingEdgeOnly          = IRQ_SC_IRQMOD(0)|IRQ_SC_IRQEDG(1),  ///< Rising Edge only
      IrqMode_RisingEdgeOrHighLevel   = IRQ_SC_IRQMOD(1)|IRQ_SC_IRQEDG(1),  ///< Rising Edge or High level
   };

   /**
    * IRQ Acknowledge
    * (irq_sc_irqack)
    *
    * Acknowledges interrupt request events (write 1 to clear IRQF).
    * Writing 0 has no meaning or effect. Reads always return 0. 
    * If edge-and-level detection is selected, then IRQF cannot be cleared 
    * while the IRQ pin remains at its asserted level
    */
   enum IrqAcknowledge {
      IrqAcknowledge_Write1ToClear   = IRQ_SC_IRQACK(1),  ///< Write 1 to clear
   };

   /**
    * IRQ Interrupt Enable
    * (irq_sc_irqie)
    *
    * Determines whether IRQ events (IRQF=1) generate an interrupt request
    */
   enum IrqInterrupt {
      IrqInterrupt_Disabled   = IRQ_SC_IRQIE(0),  ///< Interrupts Disabled
      IrqInterrupt_Enabled    = IRQ_SC_IRQIE(1),  ///< Interrupts Enabled
   };

class IrqBasicInfo {

public:
}; // class IrqBasicInfo 

class IrqInfo : public IrqBasicInfo {

public:
   /*
    * Template:irq_mke
    */
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = IRQ_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(irqNums[0]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[0], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(irqNums[0]);
   }
   
   /**
    *  Enable clock to Irq
    */
   static void enableClock() {
      SIM->SCGC = SIM->SCGC | SIM_SCGC_IRQ_MASK;
   }
   
   /**
    *  Disable clock to Irq
    */
   static void disableClock() {
      SIM->SCGC = SIM->SCGC & ~SIM_SCGC_IRQ_MASK;
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = IRQ_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<IRQ_Type> irq = baseAddress;
   
}; // class IrqInfo

/** 
 * End group IRQ_Group
 * @}
 */
/**
 * @addtogroup PORT_Group PORT, PORT
 * @brief Abstraction for PORT
 * @{
 */
/**
 * Peripheral information for PORT, PORT.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * Filter Division Set 1
    * (port_ioflt_fltdiv1)
    *
    * Selects the clock speed for the filter
    */
   enum PortFilterClock1 {
      PortFilterClock1_Busclk2    = PORT_IOFLT_FLTDIV1(0),  ///< BUSCLK/2
      PortFilterClock1_Busclk4    = PORT_IOFLT_FLTDIV1(1),  ///< BUSCLK/4
      PortFilterClock1_Busclk8    = PORT_IOFLT_FLTDIV1(2),  ///< BUSCLK/8
      PortFilterClock1_Busclk16   = PORT_IOFLT_FLTDIV1(3),  ///< BUSCLK/16
   };

   /**
    * Filter Division Set 2
    * (port_ioflt_fltdiv2)
    *
    * Selects the clock speed for the filter
    */
   enum PortFilterClock2 {
      PortFilterClock2_Busclk32     = PORT_IOFLT_FLTDIV2(0),  ///< BUSCLK/32
      PortFilterClock2_Busclk64     = PORT_IOFLT_FLTDIV2(1),  ///< BUSCLK/64
      PortFilterClock2_Busclk128    = PORT_IOFLT_FLTDIV2(2),  ///< BUSCLK/128
      PortFilterClock2_Busclk256    = PORT_IOFLT_FLTDIV2(3),  ///< BUSCLK/256
      PortFilterClock2_Busclk512    = PORT_IOFLT_FLTDIV2(4),  ///< BUSCLK/512
      PortFilterClock2_Busclk1024   = PORT_IOFLT_FLTDIV2(5),  ///< BUSCLK/1024
      PortFilterClock2_Busclk2048   = PORT_IOFLT_FLTDIV2(6),  ///< BUSCLK/2048
      PortFilterClock2_Busclk4096   = PORT_IOFLT_FLTDIV2(7),  ///< BUSCLK/4096
   };

   /**
    * Filter Division Set 3
    * (port_ioflt_fltdiv3)
    *
    * Selects the clock speed for the filter
    */
   enum PortFilterClock3 {
      PortFilterClock3_Lpoclk      = PORT_IOFLT_FLTDIV3(0),  ///< LPOCLK
      PortFilterClock3_Lpoclk2     = PORT_IOFLT_FLTDIV3(1),  ///< LPOCLK/2
      PortFilterClock3_Lpoclk4     = PORT_IOFLT_FLTDIV3(2),  ///< LPOCLK/4
      PortFilterClock3_Lpoclk8     = PORT_IOFLT_FLTDIV3(3),  ///< LPOCLK/8
      PortFilterClock3_Lpoclk16    = PORT_IOFLT_FLTDIV3(4),  ///< LPOCLK/16
      PortFilterClock3_Lpoclk32    = PORT_IOFLT_FLTDIV3(5),  ///< LPOCLK/32
      PortFilterClock3_Lpoclk64    = PORT_IOFLT_FLTDIV3(6),  ///< LPOCLK/64
      PortFilterClock3_Lpoclk128   = PORT_IOFLT_FLTDIV3(7),  ///< LPOCLK/128
   };

   /**
    * Filter Selection for Input from NMI
    * (port_ioflt_fltnmi)
    *
    * 
    */
   enum PortNmiFilterSel {
      PortNmiFilterSel_NoFilter                                                       = PORT_IOFLT_FLTNMI(0),  ///< No filter
      PortNmiFilterSel_SelectsFltdiv1_AndWillSwitchToFltdiv3InStopModeAutomatically   = PORT_IOFLT_FLTNMI(1),  ///< Selects FLTDIV1, and will switch to FLTDIV3 in Stop mode automatically
      PortNmiFilterSel_SelectsFltdiv2_AndWillSwitchToFltdiv3InStopModeAutomatically   = PORT_IOFLT_FLTNMI(2),  ///< Selects FLTDIV2, and will switch to FLTDIV3 in Stop mode automatically
      PortNmiFilterSel_Fltdiv3                                                        = PORT_IOFLT_FLTNMI(3),  ///< FLTDIV3
   };

   /**
    * Filter Selection for Input from RESET
    * (port_ioflt_fltrst)
    *
    * 
    */
   enum PortResetFilterSel {
      PortResetFilterSel_NoFilter                                                       = PORT_IOFLT_FLTRST(0),  ///< No filter
      PortResetFilterSel_SelectsFltdiv1_AndWillSwitchToFltdiv3InStopModeAutomatically   = PORT_IOFLT_FLTRST(1),  ///< Selects FLTDIV1, and will switch to FLTDIV3 in Stop mode automatically
      PortResetFilterSel_SelectsFltdiv2_AndWillSwitchToFltdiv3InStopModeAutomatically   = PORT_IOFLT_FLTRST(2),  ///< Selects FLTDIV2, and will switch to FLTDIV3 in Stop mode automatically
      PortResetFilterSel_Fltdiv3                                                        = PORT_IOFLT_FLTRST(3),  ///< FLTDIV3
   };

   /**
    * Filter Selection for Input from KBI0
    * (port_ioflt_fltkbi0)
    *
    * 
    */
   enum PortKbi0FilterSel {
      PortKbi0FilterSel_NoFilter                                                       = PORT_IOFLT_FLTKBI0(0),  ///< No filter
      PortKbi0FilterSel_SelectsFltdiv1_AndWillSwitchToFltdiv3InStopModeAutomatically   = PORT_IOFLT_FLTKBI0(1),  ///< Selects FLTDIV1, and will switch to FLTDIV3 in Stop mode automatically
      PortKbi0FilterSel_SelectsFltdiv2_AndWillSwitchToFltdiv3InStopModeAutomatically   = PORT_IOFLT_FLTKBI0(2),  ///< Selects FLTDIV2, and will switch to FLTDIV3 in Stop mode automatically
      PortKbi0FilterSel_Fltdiv3                                                        = PORT_IOFLT_FLTKBI0(3),  ///< FLTDIV3
   };

   /**
    * Filter Selection for Input from KBI1
    * (port_ioflt_fltkbi1)
    *
    * 
    */
   enum PortKbi1FilterSel {
      PortKbi1FilterSel_NoFilter                                                       = PORT_IOFLT_FLTKBI1(0),  ///< No filter
      PortKbi1FilterSel_SelectsFltdiv1_AndWillSwitchToFltdiv3InStopModeAutomatically   = PORT_IOFLT_FLTKBI1(1),  ///< Selects FLTDIV1, and will switch to FLTDIV3 in Stop mode automatically
      PortKbi1FilterSel_SelectsFltdiv2_AndWillSwitchToFltdiv3InStopModeAutomatically   = PORT_IOFLT_FLTKBI1(2),  ///< Selects FLTDIV2, and will switch to FLTDIV3 in Stop mode automatically
      PortKbi1FilterSel_Fltdiv3                                                        = PORT_IOFLT_FLTKBI1(3),  ///< FLTDIV3
   };

   /**
    * Filter Selection for Input from SCL0/SDA0
    * (port_ioflt_fltiic)
    *
    * 
    */
   enum PortI2c0FilterSel {
      PortI2c0FilterSel_NoFilter   = PORT_IOFLT_FLTIIC(0),  ///< No Filter
      PortI2c0FilterSel_Fltdiv1    = PORT_IOFLT_FLTIIC(1),  ///< FLTDIV1
      PortI2c0FilterSel_Fltdiv2    = PORT_IOFLT_FLTIIC(2),  ///< FLTDIV2
      PortI2c0FilterSel_Busclk     = PORT_IOFLT_FLTIIC(3),  ///< BUSCLK
   };

   /**
    * Filter Selection for Input from PWT_IN0/PWT_IN1
    * (port_ioflt_fltpwt)
    *
    * 
    */
   enum PortPwtFilterSel {
      PortPwtFilterSel_NoFilter   = PORT_IOFLT_FLTPWT(0),  ///< No Filter
      PortPwtFilterSel_Fltdiv1    = PORT_IOFLT_FLTPWT(1),  ///< FLTDIV1
      PortPwtFilterSel_Fltdiv2    = PORT_IOFLT_FLTPWT(2),  ///< FLTDIV2
      PortPwtFilterSel_Fltdiv3    = PORT_IOFLT_FLTPWT(3),  ///< FLTDIV3
   };

   /**
    * Filter Selection for Input from FTM0 Channels
    * (port_ioflt_fltftm0)
    *
    * 
    */
   enum PortFtm0FilterSel {
      PortFtm0FilterSel_NoFilter   = PORT_IOFLT_FLTFTM0(0),  ///< No Filter
      PortFtm0FilterSel_Fltdiv1    = PORT_IOFLT_FLTFTM0(1),  ///< FLTDIV1
      PortFtm0FilterSel_Fltdiv2    = PORT_IOFLT_FLTFTM0(2),  ///< FLTDIV2
      PortFtm0FilterSel_Fltdiv3    = PORT_IOFLT_FLTFTM0(3),  ///< FLTDIV3
   };

   /**
    * Filter Selection for Input from PTA
    * (port_ioflt_flta)
    *
    * 
    */
   enum PortPtaFilterSel {
      PortPtaFilterSel_Busclk    = PORT_IOFLT_FLTA(0),  ///< BUSCLK
      PortPtaFilterSel_Fltdiv1   = PORT_IOFLT_FLTA(1),  ///< FLTDIV1
      PortPtaFilterSel_Fltdiv2   = PORT_IOFLT_FLTA(2),  ///< FLTDIV2
      PortPtaFilterSel_Fltdiv3   = PORT_IOFLT_FLTA(3),  ///< FLTDIV3
   };

   /**
    * Filter Selection for Input from PTB
    * (port_ioflt_fltb)
    *
    * 
    */
   enum PortPtbFilterSel {
      PortPtbFilterSel_Busclk    = PORT_IOFLT_FLTB(0),  ///< BUSCLK
      PortPtbFilterSel_Fltdiv1   = PORT_IOFLT_FLTB(1),  ///< FLTDIV1
      PortPtbFilterSel_Fltdiv2   = PORT_IOFLT_FLTB(2),  ///< FLTDIV2
      PortPtbFilterSel_Fltdiv3   = PORT_IOFLT_FLTB(3),  ///< FLTDIV3
   };

   /**
    * Filter Selection for Input from PTC
    * (port_ioflt_fltc)
    *
    * 
    */
   enum PortPtcFilterSel {
      PortPtcFilterSel_Busclk    = PORT_IOFLT_FLTC(0),  ///< BUSCLK
      PortPtcFilterSel_Fltdiv1   = PORT_IOFLT_FLTC(1),  ///< FLTDIV1
      PortPtcFilterSel_Fltdiv2   = PORT_IOFLT_FLTC(2),  ///< FLTDIV2
      PortPtcFilterSel_Fltdiv3   = PORT_IOFLT_FLTC(3),  ///< FLTDIV3
   };

   /**
    * Pull-up control for Port A
    * (port_puel_ptape)
    *
    * Each bit controls the pull-up for the corresponding pin
    */
   enum PortPullUpA : uint32_t {
      PortPullUpA_Pin0   = PORT_PUEL_PTAPE(1U<<0),  ///< Pull-up for Pin0
      PortPullUpA_Pin1   = PORT_PUEL_PTAPE(1U<<1),  ///< Pull-up for Pin1
      PortPullUpA_Pin2   = PORT_PUEL_PTAPE(1U<<2),  ///< Pull-up for Pin2
      PortPullUpA_Pin3   = PORT_PUEL_PTAPE(1U<<3),  ///< Pull-up for Pin3
      PortPullUpA_Pin4   = PORT_PUEL_PTAPE(1U<<4),  ///< Pull-up for Pin4
      PortPullUpA_Pin5   = PORT_PUEL_PTAPE(1U<<5),  ///< Pull-up for Pin5
      PortPullUpA_Pin6   = PORT_PUEL_PTAPE(1U<<6),  ///< Pull-up for Pin6
      PortPullUpA_Pin7   = PORT_PUEL_PTAPE(1U<<7),  ///< Pull-up for Pin7
   };

   /**
    * Pull-up control for Port B
    * (port_puel_ptbpe)
    *
    * Each bit controls the pull-up for the corresponding pin
    */
   enum PortPullUpB : uint32_t {
      PortPullUpB_Pin0   = PORT_PUEL_PTBPE(1U<<0),  ///< Pull-up for Pin0
      PortPullUpB_Pin1   = PORT_PUEL_PTBPE(1U<<1),  ///< Pull-up for Pin1
      PortPullUpB_Pin2   = PORT_PUEL_PTBPE(1U<<2),  ///< Pull-up for Pin2
      PortPullUpB_Pin3   = PORT_PUEL_PTBPE(1U<<3),  ///< Pull-up for Pin3
      PortPullUpB_Pin4   = PORT_PUEL_PTBPE(1U<<4),  ///< Pull-up for Pin4
      PortPullUpB_Pin5   = PORT_PUEL_PTBPE(1U<<5),  ///< Pull-up for Pin5
      PortPullUpB_Pin6   = PORT_PUEL_PTBPE(1U<<6),  ///< Pull-up for Pin6
      PortPullUpB_Pin7   = PORT_PUEL_PTBPE(1U<<7),  ///< Pull-up for Pin7
   };

   /**
    * Pull-up control for Port C
    * (port_puel_ptcpe)
    *
    * Each bit controls the pull-up for the corresponding pin
    */
   enum PortPullUpC : uint32_t {
      PortPullUpC_Pin0   = PORT_PUEL_PTCPE(1U<<0),  ///< Pull-up for Pin0
      PortPullUpC_Pin1   = PORT_PUEL_PTCPE(1U<<1),  ///< Pull-up for Pin1
      PortPullUpC_Pin2   = PORT_PUEL_PTCPE(1U<<2),  ///< Pull-up for Pin2
      PortPullUpC_Pin3   = PORT_PUEL_PTCPE(1U<<3),  ///< Pull-up for Pin3
      PortPullUpC_Pin4   = PORT_PUEL_PTCPE(1U<<4),  ///< Pull-up for Pin4
      PortPullUpC_Pin5   = PORT_PUEL_PTCPE(1U<<5),  ///< Pull-up for Pin5
   };

   /**
    * High drive enable for Port B bit 5
    * (port_hdrve_ptb5)
    *
    * 
    */
   enum PortHdrvePtb5 {
      PortHdrvePtb5_LowDriveStrength    = PORT_HDRVE_PTB5(0),  ///< Low drive strength
      PortHdrvePtb5_HighDriveStrength   = PORT_HDRVE_PTB5(1),  ///< High drive strength
   };

   /**
    * High drive enable for Port C bit 1
    * (port_hdrve_ptc1)
    *
    * 
    */
   enum PortHdrvePtc1 {
      PortHdrvePtc1_LowDriveStrength    = PORT_HDRVE_PTC1(0),  ///< Low drive strength
      PortHdrvePtc1_HighDriveStrength   = PORT_HDRVE_PTC1(1),  ///< High drive strength
   };

   /**
    * High drive enable for Port C bit 5
    * (port_hdrve_ptc5)
    *
    * 
    */
   enum PortHdrvePtc5 {
      PortHdrvePtc5_LowDriveStrength    = PORT_HDRVE_PTC5(0),  ///< Low drive strength
      PortHdrvePtc5_HighDriveStrength   = PORT_HDRVE_PTC5(1),  ///< High drive strength
   };

class PortBasicInfo {

public:
   /**
    * Class used to do initialisation of the Port
    *
    * This class has a templated constructor that accepts various values.
    *
    * @note This constructor may be used to create a const instance in Flash
    *
    * Example:
    * @code
    * static const Port::Init init {
    *
    *   // Setup values
    *   PortFilterClock1_Busclk2 ,    // Filter Division Set 1 - BUSCLK/2
    *   PortFilterClock2_Busclk32 ,   // Filter Division Set 2 - BUSCLK/32
    *   PortFilterClock3_Lpoclk ,     // Filter Division Set 3 - LPOCLK
    *   PortResetFilterSel_NoFilter , // Filter Selection for Input from RESET - No filter
    *   PortNmiFilterSel_Fltdiv3 ,    // Filter Selection for Input from NMI - FLTDIV3
    *   PortPwtFilterSel_NoFilter ,   // Filter Selection for Input from PWT_IN0/PWT_IN1 - No Filter
    *   PortKbi1FilterSel_NoFilter ,  // Filter Selection for Input from KBI1 - No filter
    *   PortKbi0FilterSel_NoFilter ,  // Filter Selection for Input from KBI0 - No filter
    *   PortFtm0FilterSel_NoFilter ,  // Filter Selection for Input from FTM0 Channels - No Filter
    *   PortI2c0FilterSel_NoFilter ,  // Filter Selection for Input from SCL0/SDA0 - No Filter
    *   PortPtaFilterSel_Busclk ,     // Filter Selection for Input from PTA - BUSCLK
    *   PortPtbFilterSel_Busclk ,     // Filter Selection for Input from PTB - BUSCLK
    *   PortPtcFilterSel_Busclk,      // Filter Selection for Input from PTC - BUSCLK
    * };
    *
    * // Initialise Port from values specified above
    * Port::configure(init)
    * @endcode
    */
   class Init {
   
   public:
      /**
       * Copy Constructor
       */
      constexpr Init(const Init &other) = default;
   
      /**
       * Default Constructor
       */
      constexpr Init() = default;
   
      /// Port Filter Register
      uint32_t ioflt = 0;

      /**
       * Constructor for Filter Division Set 3
       *
       * @tparam   Types
       * @param    rest
       *
       * @param portFilterClock3 Selects the clock speed for the filter
       */
      template <typename... Types>
      constexpr Init(PortFilterClock3 portFilterClock3, Types... rest) : Init(rest...) {
   
         ioflt = (ioflt&~PORT_IOFLT_FLTDIV3_MASK) | portFilterClock3;
      }
   
      /**
       * Constructor for Filter Division Set 2
       *
       * @tparam   Types
       * @param    rest
       *
       * @param portFilterClock2 Selects the clock speed for the filter
       */
      template <typename... Types>
      constexpr Init(PortFilterClock2 portFilterClock2, Types... rest) : Init(rest...) {
   
         ioflt = (ioflt&~PORT_IOFLT_FLTDIV2_MASK) | portFilterClock2;
      }
   
      /**
       * Constructor for Filter Division Set 1
       *
       * @tparam   Types
       * @param    rest
       *
       * @param portFilterClock1 Selects the clock speed for the filter
       */
      template <typename... Types>
      constexpr Init(PortFilterClock1 portFilterClock1, Types... rest) : Init(rest...) {
   
         ioflt = (ioflt&~PORT_IOFLT_FLTDIV1_MASK) | portFilterClock1;
      }
   
      /**
       * Constructor for Filter Selection for Input from NMI
       *
       * @tparam   Types
       * @param    rest
       *
       * @param portNmiFilterSel 
       */
      template <typename... Types>
      constexpr Init(PortNmiFilterSel portNmiFilterSel, Types... rest) : Init(rest...) {
   
         ioflt = (ioflt&~PORT_IOFLT_FLTNMI_MASK) | portNmiFilterSel;
      }
   
      /**
       * Constructor for Filter Selection for Input from KBI1
       *
       * @tparam   Types
       * @param    rest
       *
       * @param portKbi1FilterSel 
       */
      template <typename... Types>
      constexpr Init(PortKbi1FilterSel portKbi1FilterSel, Types... rest) : Init(rest...) {
   
         ioflt = (ioflt&~PORT_IOFLT_FLTKBI1_MASK) | portKbi1FilterSel;
      }
   
      /**
       * Constructor for Filter Selection for Input from KBI0
       *
       * @tparam   Types
       * @param    rest
       *
       * @param portKbi0FilterSel 
       */
      template <typename... Types>
      constexpr Init(PortKbi0FilterSel portKbi0FilterSel, Types... rest) : Init(rest...) {
   
         ioflt = (ioflt&~PORT_IOFLT_FLTKBI0_MASK) | portKbi0FilterSel;
      }
   
      /**
       * Constructor for Filter Selection for Input from RESET
       *
       * @tparam   Types
       * @param    rest
       *
       * @param portResetFilterSel 
       */
      template <typename... Types>
      constexpr Init(PortResetFilterSel portResetFilterSel, Types... rest) : Init(rest...) {
   
         ioflt = (ioflt&~PORT_IOFLT_FLTRST_MASK) | portResetFilterSel;
      }
   
      /**
       * Constructor for Filter Selection for Input from PWT_IN0/PWT_IN1
       *
       * @tparam   Types
       * @param    rest
       *
       * @param portPwtFilterSel 
       */
      template <typename... Types>
      constexpr Init(PortPwtFilterSel portPwtFilterSel, Types... rest) : Init(rest...) {
   
         ioflt = (ioflt&~PORT_IOFLT_FLTPWT_MASK) | portPwtFilterSel;
      }
   
      /**
       * Constructor for Filter Selection for Input from FTM0 Channels
       *
       * @tparam   Types
       * @param    rest
       *
       * @param portFtm0FilterSel 
       */
      template <typename... Types>
      constexpr Init(PortFtm0FilterSel portFtm0FilterSel, Types... rest) : Init(rest...) {
   
         ioflt = (ioflt&~PORT_IOFLT_FLTFTM0_MASK) | portFtm0FilterSel;
      }
   
      /**
       * Constructor for Filter Selection for Input from SCL0/SDA0
       *
       * @tparam   Types
       * @param    rest
       *
       * @param portI2c0FilterSel 
       */
      template <typename... Types>
      constexpr Init(PortI2c0FilterSel portI2c0FilterSel, Types... rest) : Init(rest...) {
   
         ioflt = (ioflt&~PORT_IOFLT_FLTIIC_MASK) | portI2c0FilterSel;
      }
   
      /**
       * Constructor for Filter Selection for Input from PTC
       *
       * @tparam   Types
       * @param    rest
       *
       * @param portPtcFilterSel 
       */
      template <typename... Types>
      constexpr Init(PortPtcFilterSel portPtcFilterSel, Types... rest) : Init(rest...) {
   
         ioflt = (ioflt&~PORT_IOFLT_FLTC_MASK) | portPtcFilterSel;
      }
   
      /**
       * Constructor for Filter Selection for Input from PTB
       *
       * @tparam   Types
       * @param    rest
       *
       * @param portPtbFilterSel 
       */
      template <typename... Types>
      constexpr Init(PortPtbFilterSel portPtbFilterSel, Types... rest) : Init(rest...) {
   
         ioflt = (ioflt&~PORT_IOFLT_FLTB_MASK) | portPtbFilterSel;
      }
   
      /**
       * Constructor for Filter Selection for Input from PTA
       *
       * @tparam   Types
       * @param    rest
       *
       * @param portPtaFilterSel 
       */
      template <typename... Types>
      constexpr Init(PortPtaFilterSel portPtaFilterSel, Types... rest) : Init(rest...) {
   
         ioflt = (ioflt&~PORT_IOFLT_FLTA_MASK) | portPtaFilterSel;
      }
   
   }; // PortBasicInfo::Init

}; // class PortBasicInfo 

class PortInfo {

public:
   /*
    * Template:port_mke04
    */
   /**
    * Basic enable of Port
    * Includes enabling clock and configuring all mapped pins if mapPinsOnEnable is selected in configuration
    */
   static void enable() {
   }
   
   /**
    * Disables Port
    */
   static void disable() {
   
      
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = PORT_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<PORT_Type> port = baseAddress;
   
   /**
    * Set Filter Division Set 3
    *
    * @param portFilterClock3 Selects the clock speed for the filter
    */
   static void configureFilter3Clock(PortFilterClock3 portFilterClock3) {
      port->IOFLT = (port->IOFLT&~PORT_IOFLT_FLTDIV3_MASK) | portFilterClock3;
   }

   /**
    * Set Filter Division Set 2
    *
    * @param portFilterClock2 Selects the clock speed for the filter
    */
   static void configureFilter2Clock(PortFilterClock2 portFilterClock2) {
      port->IOFLT = (port->IOFLT&~PORT_IOFLT_FLTDIV2_MASK) | portFilterClock2;
   }

   /**
    * Set Filter Division Set 1
    *
    * @param portFilterClock1 Selects the clock speed for the filter
    */
   static void configureFilter1Clock(PortFilterClock1 portFilterClock1) {
      port->IOFLT = (port->IOFLT&~PORT_IOFLT_FLTDIV1_MASK) | portFilterClock1;
   }

   /**
    * Set Filter Selection for Input from NMI
    *
    * @param portNmiFilterSel 
    */
   static void configureNmiFilter(PortNmiFilterSel portNmiFilterSel) {
      port->IOFLT = (port->IOFLT&~PORT_IOFLT_FLTNMI_MASK) | portNmiFilterSel;
   }

   /**
    * Set Filter Selection for Input from KBI1
    *
    * @param portKbi1FilterSel 
    */
   static void configureKbi1Filter(PortKbi1FilterSel portKbi1FilterSel) {
      port->IOFLT = (port->IOFLT&~PORT_IOFLT_FLTKBI1_MASK) | portKbi1FilterSel;
   }

   /**
    * Set Filter Selection for Input from KBI0
    *
    * @param portKbi0FilterSel 
    */
   static void configureKbi0Filter(PortKbi0FilterSel portKbi0FilterSel) {
      port->IOFLT = (port->IOFLT&~PORT_IOFLT_FLTKBI0_MASK) | portKbi0FilterSel;
   }

   /**
    * Set Filter Selection for Input from RESET
    *
    * @param portResetFilterSel 
    */
   static void configureResetFilter(PortResetFilterSel portResetFilterSel) {
      port->IOFLT = (port->IOFLT&~PORT_IOFLT_FLTRST_MASK) | portResetFilterSel;
   }

   /**
    * Set Filter Selection for Input from PWT_IN0/PWT_IN1
    *
    * @param portPwtFilterSel 
    */
   static void configurePwtFilter(PortPwtFilterSel portPwtFilterSel) {
      port->IOFLT = (port->IOFLT&~PORT_IOFLT_FLTPWT_MASK) | portPwtFilterSel;
   }

   /**
    * Set Filter Selection for Input from FTM0 Channels
    *
    * @param portFtm0FilterSel 
    */
   static void configureFtm0Filter(PortFtm0FilterSel portFtm0FilterSel) {
      port->IOFLT = (port->IOFLT&~PORT_IOFLT_FLTFTM0_MASK) | portFtm0FilterSel;
   }

   /**
    * Set Filter Selection for Input from SCL0/SDA0
    *
    * @param portI2c0FilterSel 
    */
   static void configureI2c0Filter(PortI2c0FilterSel portI2c0FilterSel) {
      port->IOFLT = (port->IOFLT&~PORT_IOFLT_FLTIIC_MASK) | portI2c0FilterSel;
   }

   /**
    * Set Filter Selection for Input from PTC
    *
    * @param portPtcFilterSel 
    */
   static void configurePtcFilter(PortPtcFilterSel portPtcFilterSel) {
      port->IOFLT = (port->IOFLT&~PORT_IOFLT_FLTC_MASK) | portPtcFilterSel;
   }

   /**
    * Set Filter Selection for Input from PTB
    *
    * @param portPtbFilterSel 
    */
   static void configurePtbFilter(PortPtbFilterSel portPtbFilterSel) {
      port->IOFLT = (port->IOFLT&~PORT_IOFLT_FLTB_MASK) | portPtbFilterSel;
   }

   /**
    * Set Filter Selection for Input from PTA
    *
    * @param portPtaFilterSel 
    */
   static void configurePtaFilter(PortPtaFilterSel portPtaFilterSel) {
      port->IOFLT = (port->IOFLT&~PORT_IOFLT_FLTA_MASK) | portPtaFilterSel;
   }

      /** Default value for Pull-up control for Port A, Pull-up control for Port B and Pull-up control for Port C */
      static constexpr uint32_t puel = 
         PortPullUpA(0) |                         // (port_puel_ptape)          Pull-up control for Port A
         PortPullUpB(0) |                         // (port_puel_ptbpe)          Pull-up control for Port B
         PortPullUpC(0);                          // (port_puel_ptcpe)          Pull-up control for Port C;
   
      /** Default value for High drive enable for Port B bit 5, High drive enable for Port C bit 1 and High drive enable for Port C bit 5 */
      static constexpr uint32_t hdrve = 
         PortHdrvePtb5_HighDriveStrength |        // (port_hdrve_ptb5)          High drive enable for Port B bit 5 - High drive strength
         PortHdrvePtc1_LowDriveStrength |         // (port_hdrve_ptc1)          High drive enable for Port C bit 1 - Low drive strength
         PortHdrvePtc5_LowDriveStrength;          // (port_hdrve_ptc5)          High drive enable for Port C bit 5 - Low drive strength;
   
   /**
    * Class used to do initialisation of the Port
    *
    * This class has a templated constructor that accepts various values.
    *
    * @note This constructor may be used to create a const instance in Flash
    *
    * Example:
    * @code
    * static const Port::Init init {
    *
    *   // Setup values
    *   PortFilterClock1_Busclk2 ,    // Filter Division Set 1 - BUSCLK/2
    *   PortFilterClock2_Busclk32 ,   // Filter Division Set 2 - BUSCLK/32
    *   PortFilterClock3_Lpoclk ,     // Filter Division Set 3 - LPOCLK
    *   PortResetFilterSel_NoFilter , // Filter Selection for Input from RESET - No filter
    *   PortNmiFilterSel_Fltdiv3 ,    // Filter Selection for Input from NMI - FLTDIV3
    *   PortPwtFilterSel_NoFilter ,   // Filter Selection for Input from PWT_IN0/PWT_IN1 - No Filter
    *   PortKbi1FilterSel_NoFilter ,  // Filter Selection for Input from KBI1 - No filter
    *   PortKbi0FilterSel_NoFilter ,  // Filter Selection for Input from KBI0 - No filter
    *   PortFtm0FilterSel_NoFilter ,  // Filter Selection for Input from FTM0 Channels - No Filter
    *   PortI2c0FilterSel_NoFilter ,  // Filter Selection for Input from SCL0/SDA0 - No Filter
    *   PortPtaFilterSel_Busclk ,     // Filter Selection for Input from PTA - BUSCLK
    *   PortPtbFilterSel_Busclk ,     // Filter Selection for Input from PTB - BUSCLK
    *   PortPtcFilterSel_Busclk,      // Filter Selection for Input from PTC - BUSCLK
    * };
    *
    * // Initialise Port from values specified above
    * Port::configure(init)
    * @endcode
    */
   typedef PortBasicInfo::Init Init;
   
   /**
    * Default initialisation value for Port
    * This value is created from Configure.usbdmProject settings
    */
   static constexpr Init DefaultInitValue = {
      PortNmiFilterSel_Fltdiv3 ,                  // (port_ioflt_fltnmi)        Filter Selection for Input from NMI - FLTDIV3
   };

}; // class PortInfo

/** 
 * End group PORT_Group
 * @}
 */
/**
 * @addtogroup Power_Group POWER, Power
 * @brief Abstraction for Power
 * @{
 */
/**
 * Peripheral information for POWER, Power.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
class PowerInfo {

public:
   /*
    * Template:power
    */
}; // class PowerInfo

/** 
 * End group Power_Group
 * @}
 */
/** 
 * End group USBDM_Group
 * @}
 */

} // End namespace USBDM


///
/// @page PinSummary Pin Mapping
///
/// @section PinsByPinName Pins by Pin Name
///
///   Pin Name      | C Identifier                  |  Functions                                         |  Location                 |  Description
///  -------------- | ------------------------------|--------------------------------------------------- | ------------------------- | ----------------------------------------------------
///  PTA0           | SWDCLK                        | SWD_CLK                                            | 16                        | SWD CLK
///  PTA1           | Reference                     | ADC0_SE1                                           | 15                        | Reference level for ISample OPAMPs
///  PTA2           | -                             | UART0_RX                                           | 14                        | Debug Rx
///  PTA3           | -                             | UART0_TX                                           | 13                        | Debug Tx
///  PTA4           | SWDIO                         | SWD_DIO                                            | 2                         | SWD DIO
///  PTA5           | RESET_b                       | RESET_b                                            | 1                         | RESET reserved
///  PTB0           | I_Sample                      | ADC0_SE4                                           | 12                        | Current Sample
///  PTB1           | DelayControl                  | ADC0_SE5                                           | 11                        | Delay Control
///  PTB2           | HoldControl                   | ADC0_SE6                                           | 10                        | Hold time control
///  PTB3           | LevelControl                  | ADC0_SE7                                           | 9                         | Current threshold control
///  PTB4           | Debug/Pins                    | GPIOA_12                                           | 8                         | Debug output/Debug, DustCollector, HoldLed, DelayLed
///  PTB5           | DustCollector/Pins            | GPIOA_13                                           | 7                         | Controls dust collector
///  PTB6           | HoldLed/Pins                  | GPIOA_14                                           | 6                         | LED indicating hold
///  PTB7           | DelayLed/Switch/Pins          | GPIOA_15                                           | 5                         | LED indicating delay
///
///
/// @section PinsByLocation Pins by Location
///
///   Pin Name      | C Identifier                  |  Functions                                         |  Location                 |  Description
///  -------------- | ------------------------------|--------------------------------------------------- | ------------------------- | ----------------------------------------------------
///  PTA5           | RESET_b                       | RESET_b                                            | 1                         | RESET reserved
///  PTB2           | HoldControl                   | ADC0_SE6                                           | 10                        | Hold time control
///  PTB1           | DelayControl                  | ADC0_SE5                                           | 11                        | Delay Control
///  PTB0           | I_Sample                      | ADC0_SE4                                           | 12                        | Current Sample
///  PTA3           | -                             | UART0_TX                                           | 13                        | Debug Tx
///  PTA2           | -                             | UART0_RX                                           | 14                        | Debug Rx
///  PTA1           | Reference                     | ADC0_SE1                                           | 15                        | Reference level for ISample OPAMPs
///  PTA0           | SWDCLK                        | SWD_CLK                                            | 16                        | SWD CLK
///  PTA4           | SWDIO                         | SWD_DIO                                            | 2                         | SWD DIO
///  PTB7           | DelayLed/Switch/Pins          | GPIOA_15                                           | 5                         | LED indicating delay
///  PTB6           | HoldLed/Pins                  | GPIOA_14                                           | 6                         | LED indicating hold
///  PTB5           | DustCollector/Pins            | GPIOA_13                                           | 7                         | Controls dust collector
///  PTB4           | Debug/Pins                    | GPIOA_12                                           | 8                         | Debug output/Debug, DustCollector, HoldLed, DelayLed
///  PTB3           | LevelControl                  | ADC0_SE7                                           | 9                         | Current threshold control
///
///
/// @section PinsByFunction Pins by Peripheral
///
///   Pin Name      | C Identifier                  |  Functions                                         |  Location                 |  Description
///  -------------- | ------------------------------|--------------------------------------------------- | ------------------------- | ----------------------------------------------------
///  PTA1           | Reference                     | ADC0_SE1                                           | 15                        | Reference level for ISample OPAMPs
///  PTB0           | I_Sample                      | ADC0_SE4                                           | 12                        | Current Sample
///  PTB1           | DelayControl                  | ADC0_SE5                                           | 11                        | Delay Control
///  PTB2           | HoldControl                   | ADC0_SE6                                           | 10                        | Hold time control
///  PTB3           | LevelControl                  | ADC0_SE7                                           | 9                         | Current threshold control
///  PTB4           | Debug/Pins                    | GPIOA_12                                           | 8                         | Debug output/Debug, DustCollector, HoldLed, DelayLed
///  PTB5           | DustCollector/Pins            | GPIOA_13                                           | 7                         | Controls dust collector
///  PTB6           | HoldLed/Pins                  | GPIOA_14                                           | 6                         | LED indicating hold
///  PTB7           | DelayLed/Switch/Pins          | GPIOA_15                                           | 5                         | LED indicating delay
///  PTA5           | RESET_b                       | RESET_b                                            | 1                         | RESET reserved
///  PTA0           | SWDCLK                        | SWD_CLK                                            | 16                        | SWD CLK
///  PTA4           | SWDIO                         | SWD_DIO                                            | 2                         | SWD DIO
///  PTA2           | -                             | UART0_RX                                           | 14                        | Debug Rx
///  PTA3           | -                             | UART0_TX                                           | 13                        | Debug Tx
///
///

#endif /* PROJECT_HEADERS_PIN_MAPPING_H */
