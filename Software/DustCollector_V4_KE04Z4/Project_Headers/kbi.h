/**
 * @file      kbi.h (180.ARM_Peripherals/Project_Headers/kbi-MKE.h)
 * @brief    Abstraction layer for KBI interface
 */

#ifndef PROJECT_HEADERS_KBI_H_
#define PROJECT_HEADERS_KBI_H_

/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "pin_mapping.h"

// No handler defined for KBI0
// No handler defined for KBI1


#if false // /KBI/_BasicInfoGuard

namespace USBDM {

/**
 * Peripheral information for KBI, Keyboard Interrupts.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * KBI Pin Index
    * (kbi_pe_indexshared)
    *
    * Selects KBI pin
    */
   enum KbiPinIndex : uint8_t {
      KbiPinIndex_Pin0   = 0,  ///< Enable Pin #0
      KbiPinIndex_Pin1   = 1,  ///< Enable Pin #1
      KbiPinIndex_Pin2   = 2,  ///< Enable Pin #2
      KbiPinIndex_Pin3   = 3,  ///< Enable Pin #3
      KbiPinIndex_Pin4   = 4,  ///< Enable Pin #4
      KbiPinIndex_Pin5   = 5,  ///< Enable Pin #5
      KbiPinIndex_Pin6   = 6,  ///< Enable Pin #6
      KbiPinIndex_Pin7   = 7,  ///< Enable Pin #7
   };

   /**
    * KBI0 Pin Index
    * (kbi_pe_index)
    *
    * Selects KBI0 pin
    */
   static constexpr KbiPinIndex Kbi0PinIndex_PTA0   = KbiPinIndex_Pin0;  ///< Pin PTA0
   static constexpr KbiPinIndex Kbi0PinIndex_PTA1   = KbiPinIndex_Pin1;  ///< Pin PTA1
   static constexpr KbiPinIndex Kbi0PinIndex_PTA2   = KbiPinIndex_Pin2;  ///< Pin PTA2
   static constexpr KbiPinIndex Kbi0PinIndex_PTA3   = KbiPinIndex_Pin3;  ///< Pin PTA3
   static constexpr KbiPinIndex Kbi0PinIndex_PTB0   = KbiPinIndex_Pin4;  ///< Pin PTB0
   static constexpr KbiPinIndex Kbi0PinIndex_PTB1   = KbiPinIndex_Pin5;  ///< Pin PTB1
   static constexpr KbiPinIndex Kbi0PinIndex_PTB2   = KbiPinIndex_Pin6;  ///< Pin PTB2
   static constexpr KbiPinIndex Kbi0PinIndex_PTB3   = KbiPinIndex_Pin7;  ///< Pin PTB3


   /**
    * KBI Common Pin Enable Masks
    * (kbi_pe_kbipeShared)
    *
    * These are used for the underlying pin enable masks for all KBIs
    */
   enum KbiEnableMask : uint8_t {
      KbiEnableMask_Pin0   = 1U<<0,  ///< Enable Pin Mask #0
      KbiEnableMask_Pin1   = 1U<<1,  ///< Enable Pin Mask #1
      KbiEnableMask_Pin2   = 1U<<2,  ///< Enable Pin Mask #2
      KbiEnableMask_Pin3   = 1U<<3,  ///< Enable Pin Mask #3
      KbiEnableMask_Pin4   = 1U<<4,  ///< Enable Pin Mask #4
      KbiEnableMask_Pin5   = 1U<<5,  ///< Enable Pin Mask #5
      KbiEnableMask_Pin6   = 1U<<6,  ///< Enable Pin Mask #6
      KbiEnableMask_Pin7   = 1U<<7,  ///< Enable Pin Mask #7
   };


   /**
    * Combines two KbiEnableMask values (by ORing)
    * Used to create new KbiEnableMask mask
    * 
    * @param left    Left operand
    * @param right   Right operand
    * 
    * @return  Combined value
    */
   constexpr KbiEnableMask operator|(KbiEnableMask left, KbiEnableMask right) {
      return KbiEnableMask(long(left)|long(right));
   }
   
   /**
    * Combines two KbiEnableMask values (by ANDing) to produce a bool result
    * Used to check a value against a KbiEnableMask mask
    * 
    * @param left    Left operand
    * @param right   Right operand
    * 
    * @return boolean value indicating if the result is non-zero
    */
   constexpr bool operator&(KbiEnableMask left, KbiEnableMask right) {
      return bool(long(left)&long(right));
   }
   
   /**
    * KBI0 Pin Enables
    * (kbi_pe_kbipe)
    *
    * Bitmask selecting enabled pins
    */
   static constexpr KbiEnableMask Kbi0EnableMask_PTA0   = KbiEnableMask(1U<<0);  ///< null
   static constexpr KbiEnableMask Kbi0EnableMask_PTA1   = KbiEnableMask(1U<<1);  ///< null
   static constexpr KbiEnableMask Kbi0EnableMask_PTA2   = KbiEnableMask(1U<<2);  ///< null
   static constexpr KbiEnableMask Kbi0EnableMask_PTA3   = KbiEnableMask(1U<<3);  ///< null
   static constexpr KbiEnableMask Kbi0EnableMask_PTB0   = KbiEnableMask(1U<<4);  ///< null
   static constexpr KbiEnableMask Kbi0EnableMask_PTB1   = KbiEnableMask(1U<<5);  ///< null
   static constexpr KbiEnableMask Kbi0EnableMask_PTB2   = KbiEnableMask(1U<<6);  ///< null
   static constexpr KbiEnableMask Kbi0EnableMask_PTB3   = KbiEnableMask(1U<<7);  ///< null


   /**
    * KBI Common Pin Polarity Masks
    * (kbi_es_sharedPolarityMask)
    *
    * These are used for the underlying pin polarity masks for all KBIs
    * Mask value indicates Rising-edge/high-level selected
    */
   enum KbiPolarityMask : uint8_t {
      KbiPolarityMask_Pin0   = 1U<<0,  ///< Enable Pin Mask #0
      KbiPolarityMask_Pin1   = 1U<<1,  ///< Enable Pin Mask #1
      KbiPolarityMask_Pin2   = 1U<<2,  ///< Enable Pin Mask #2
      KbiPolarityMask_Pin3   = 1U<<3,  ///< Enable Pin Mask #3
      KbiPolarityMask_Pin4   = 1U<<4,  ///< Enable Pin Mask #4
      KbiPolarityMask_Pin5   = 1U<<5,  ///< Enable Pin Mask #5
      KbiPolarityMask_Pin6   = 1U<<6,  ///< Enable Pin Mask #6
      KbiPolarityMask_Pin7   = 1U<<7,  ///< Enable Pin Mask #7
   };


   /**
    * Combines two KbiPolarityMask values (by ORing)
    * Used to create new KbiPolarityMask mask
    * 
    * @param left    Left operand
    * @param right   Right operand
    * 
    * @return  Combined value
    */
   constexpr KbiPolarityMask operator|(KbiPolarityMask left, KbiPolarityMask right) {
      return KbiPolarityMask(long(left)|long(right));
   }
   
   /**
    * Combines two KbiPolarityMask values (by ANDing) to produce a bool result
    * Used to check a value against a KbiPolarityMask mask
    * 
    * @param left    Left operand
    * @param right   Right operand
    * 
    * @return boolean value indicating if the result is non-zero
    */
   constexpr bool operator&(KbiPolarityMask left, KbiPolarityMask right) {
      return bool(long(left)&long(right));
   }
   
   /**
    * Kbi0 Edge Selects
    * (kbi_es_kbedg)
    *
    * Bitmask selecting polarity : 0=Falling edge/low level; 1=Rising edge/high level
    */
   static constexpr KbiPolarityMask Kbi0PolarityMask_PTA0   = KbiPolarityMask(1U<<0);  ///< null
   static constexpr KbiPolarityMask Kbi0PolarityMask_PTA1   = KbiPolarityMask(1U<<1);  ///< null
   static constexpr KbiPolarityMask Kbi0PolarityMask_PTA2   = KbiPolarityMask(1U<<2);  ///< null
   static constexpr KbiPolarityMask Kbi0PolarityMask_PTA3   = KbiPolarityMask(1U<<3);  ///< null
   static constexpr KbiPolarityMask Kbi0PolarityMask_PTB0   = KbiPolarityMask(1U<<4);  ///< null
   static constexpr KbiPolarityMask Kbi0PolarityMask_PTB1   = KbiPolarityMask(1U<<5);  ///< null
   static constexpr KbiPolarityMask Kbi0PolarityMask_PTB2   = KbiPolarityMask(1U<<6);  ///< null
   static constexpr KbiPolarityMask Kbi0PolarityMask_PTB3   = KbiPolarityMask(1U<<7);  ///< null


   /**
    * KBI Interrupt Flag
    * (kbi_sc_kbf)
    *
    * Indicates when a KBI interrupt request is detected.
    * Writes have no effect on KBF.
    */
   enum KbiEvent : uint8_t {
      KbiEvent_None                = KBI_SC_KBF(0),  ///< Not detected
      KbiEvent_InterruptDetected   = KBI_SC_KBF(1),  ///< Detected
   };

   /**
    * KBI Acknowledge
    * (kbi_sc_kback)
    *
    * Writing a 1 to KBACK is part of the flag clearing mechanism
    */
   enum KbiAck : uint8_t {
      KbiAck_Write1ToClear   = KBI_SC_KBACK(1),  ///< Clear
   };

   /**
    * KBI Interrupt Enable
    * (kbi_sc_kbie)
    *
    * Determines whether a KBI interrupt is enabled or not.
    */
   enum KbiInterrupt : uint8_t {
      KbiInterrupt_Disabled   = KBI_SC_KBIE(0),  ///< Interrupt disabled
      KbiInterrupt_Enabled    = KBI_SC_KBIE(1),  ///< Interrupt enabled
   };

   /**
    * KBI Detection Mode
    * (kbi_sc_kbmod)
    *
    * KBMOD (along with ES[KBEDG]) controls the detection mode of the KBI interrupt pins.
    */
   enum KbiDetectionMode : uint8_t {
      KbiDetectionMode_EdgesOnly       = KBI_SC_KBMOD(0),  ///< Edges only
      KbiDetectionMode_EdgesOrLevels   = KBI_SC_KBMOD(1),  ///< Edges or levels
   };

class KbiBasicInfo {

public:
}; // class KbiBasicInfo 

class Kbi0Info : public KbiBasicInfo {

public:
   /*
    * Template:kbi0_mke02
    */
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = KBI0_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(irqNums[0]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[0], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(irqNums[0]);
   }
   
   /**
    *  Enable clock to Kbi0
    */
   static void enableClock() {
      SIM->SCGC = SIM->SCGC | SIM_SCGC_KBI0_MASK;
   }
   
   /**
    *  Disable clock to Kbi0
    */
   static void disableClock() {
      SIM->SCGC = SIM->SCGC & ~SIM_SCGC_KBI0_MASK;
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = KBI0_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<KBI_Type> kbi = baseAddress;
   
   //! Peripheral instance number
   static constexpr unsigned instance = 0;
   
}; // class Kbi0Info

/**
 * Peripheral information for KBI, Keyboard Interrupts.
 * 
 * This may include pin information, constants, register addresses, and default register values,
 * along with simple accessor functions.
 */
   /**
    * KBI1 Pin Index
    * (kbi_pe_index)
    *
    * Selects KBI1 pin
    */
   static constexpr KbiPinIndex Kbi1PinIndex_PTC4   = KbiPinIndex_Pin0;  ///< Pin PTC4
   static constexpr KbiPinIndex Kbi1PinIndex_PTC5   = KbiPinIndex_Pin1;  ///< Pin PTC5
   static constexpr KbiPinIndex Kbi1PinIndex_PTC0   = KbiPinIndex_Pin2;  ///< Pin PTC0
   static constexpr KbiPinIndex Kbi1PinIndex_PTC1   = KbiPinIndex_Pin3;  ///< Pin PTC1
   static constexpr KbiPinIndex Kbi1PinIndex_PTC2   = KbiPinIndex_Pin4;  ///< Pin PTC2
   static constexpr KbiPinIndex Kbi1PinIndex_PTC3   = KbiPinIndex_Pin5;  ///< Pin PTC3
   static constexpr KbiPinIndex Kbi1PinIndex_PTB4   = KbiPinIndex_Pin6;  ///< Pin PTB4
   static constexpr KbiPinIndex Kbi1PinIndex_PTB5   = KbiPinIndex_Pin7;  ///< Pin PTB5


   /**
    * KBI1 Pin Enables
    * (kbi_pe_kbipe)
    *
    * Bitmask selecting enabled pins
    */
   static constexpr KbiEnableMask Kbi1EnableMask_PTC4   = KbiEnableMask(1U<<0);  ///< null
   static constexpr KbiEnableMask Kbi1EnableMask_PTC5   = KbiEnableMask(1U<<1);  ///< null
   static constexpr KbiEnableMask Kbi1EnableMask_PTC0   = KbiEnableMask(1U<<2);  ///< null
   static constexpr KbiEnableMask Kbi1EnableMask_PTC1   = KbiEnableMask(1U<<3);  ///< null
   static constexpr KbiEnableMask Kbi1EnableMask_PTC2   = KbiEnableMask(1U<<4);  ///< null
   static constexpr KbiEnableMask Kbi1EnableMask_PTC3   = KbiEnableMask(1U<<5);  ///< null
   static constexpr KbiEnableMask Kbi1EnableMask_PTB4   = KbiEnableMask(1U<<6);  ///< null
   static constexpr KbiEnableMask Kbi1EnableMask_PTB5   = KbiEnableMask(1U<<7);  ///< null


   /**
    * Kbi1 Edge Selects
    * (kbi_es_kbedg)
    *
    * Bitmask selecting polarity : 0=Falling edge/low level; 1=Rising edge/high level
    */
   static constexpr KbiPolarityMask Kbi1PolarityMask_PTC4   = KbiPolarityMask(1U<<0);  ///< null
   static constexpr KbiPolarityMask Kbi1PolarityMask_PTC5   = KbiPolarityMask(1U<<1);  ///< null
   static constexpr KbiPolarityMask Kbi1PolarityMask_PTC0   = KbiPolarityMask(1U<<2);  ///< null
   static constexpr KbiPolarityMask Kbi1PolarityMask_PTC1   = KbiPolarityMask(1U<<3);  ///< null
   static constexpr KbiPolarityMask Kbi1PolarityMask_PTC2   = KbiPolarityMask(1U<<4);  ///< null
   static constexpr KbiPolarityMask Kbi1PolarityMask_PTC3   = KbiPolarityMask(1U<<5);  ///< null
   static constexpr KbiPolarityMask Kbi1PolarityMask_PTB4   = KbiPolarityMask(1U<<6);  ///< null
   static constexpr KbiPolarityMask Kbi1PolarityMask_PTB5   = KbiPolarityMask(1U<<7);  ///< null


class Kbi1Info : public KbiBasicInfo {

public:
   /*
    * Template:kbi0_mke02
    */
   //! IRQ numbers for hardware
   static constexpr IRQn_Type irqNums[]  = KBI1_IRQS;
   
   //! Number of IRQs for hardware
   static constexpr uint32_t irqCount  = sizeofArray(irqNums);
   
   /**
    * Enable interrupts in NVIC
    */
   static void enableNvicInterrupts() {
      NVIC_EnableIRQ(irqNums[0]);
   }
   
   /**
    * Enable and set priority of interrupts in NVIC
    * Any pending NVIC interrupts are first cleared.
    *
    * @param[in]  nvicPriority  Interrupt priority
    */
   static void enableNvicInterrupts(NvicPriority nvicPriority) {
      enableNvicInterrupt(irqNums[0], nvicPriority);
   }
   
   /**
    * Disable interrupts in NVIC
    */
   static void disableNvicInterrupts() {
      NVIC_DisableIRQ(irqNums[0]);
   }
   
   /**
    *  Enable clock to Kbi1
    */
   static void enableClock() {
      SIM->SCGC = SIM->SCGC | SIM_SCGC_KBI1_MASK;
   }
   
   /**
    *  Disable clock to Kbi1
    */
   static void disableClock() {
      SIM->SCGC = SIM->SCGC & ~SIM_SCGC_KBI1_MASK;
   }
   
   //! Hardware base address as uint32_t
   static constexpr uint32_t baseAddress = KBI1_BasePtr;
   
   //! Hardware base pointer
   static constexpr HardwarePtr<KBI_Type> kbi = baseAddress;
   
   //! Peripheral instance number
   static constexpr unsigned instance = 1;
   
}; // class Kbi1Info


template <class Info>
class KbiBase_T : public Info {

protected:
   /** Hardware instance */
   static constexpr HardwarePtr<KBI_Type> kbi = Info::baseAddress;

// No /KBI/protectedMethods found
public:
// No /KBI/publicMethods found
// No /KBI/InitMethod found
};




}; // namespace USBDM

#endif // /KBI/_BasicInfoGuard

#endif /* PROJECT_HEADERS_KBI_H_ */
