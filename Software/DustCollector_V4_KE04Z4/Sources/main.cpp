/**
 ============================================================================
 * @file    main.cpp (180.ARM_Peripherals/Sources/main.cpp)
 * @brief   Dust extractor control
 *
 *  Created on: 7/4/2023
 *      Author: podonoghue
 ============================================================================
 */
#include "hardware.h"
#include "ics.h"
#include "adc.h"
#include "queue.h"

using namespace USBDM;

// ADC Resolution - 10-bit unsigned (single-ended mode)
constexpr AdcResolution ADC_RESOLUTION = AdcResolution_12bit_se;

// How often the callback is executed (in us)
constexpr unsigned       TICK_TIME        = 100; // 100 us

// Timer Ticks (as multiple of TICK_TIME)
constexpr unsigned       TIMER_TICK_TIME  = 1000; // 100 us * 1000 = 100 ms ~ 1/10 s

// Number of samples to average current over
constexpr unsigned EXPECTED_PERIOD_IN_TICKS = round(20_ms/(TICK_TIME/1000000.0));

/**
 * Events generated by handler
 */
USBDM::Queue<10> eventQueue;

/**
 * State machine states
 */
enum State {s_IDLE, s_DELAY, s_OPERATING, s_HOLD, s_MANUAL};

// State machine state
static State state = s_IDLE;

// Delay time in e_TICKs
static unsigned delayTimeInTicks;

// Hold time in e_TICKs
static unsigned holdTimeInTicks;

//#undef DEBUG_BUILD

#if defined(DEBUG_BUILD)
static const char *getEventName(Event state) {

   static const char *names[] = {
         "e_NONE", "e_SWITCH", "e_LOAD_ON", "e_LOAD_OFF", "e_TICK"
   };
   if (state > sizeofArray(names)) {
      return "Illegal";
   }
   return names[state];
}

static const char *getStateName(State state) {

   static const char *names[] = {
         "Idle", "Delay", "Operating", "Hold", "Manual"
   };
   if (state > sizeofArray(names)) {
      return "Illegal";
   }
   return names[state];
}
#endif

/**
 * Get detect level as raw ADC value
 */
unsigned getDetectLevel() {
   return 2*LevelControl::readAnalogue()/3;
}

/**
 * Get Delay value in 100 ms ticks [500ms..4s]
 */
unsigned getDelayControl() {
   constexpr unsigned MIN_DELAY =  5;
   constexpr unsigned MAX_DELAY = 40;

   unsigned value = DelayControl::readAnalogue();
   value *= (MAX_DELAY-MIN_DELAY);
   value /= UserAdc::getSingleEndedMaximum(ADC_RESOLUTION);
   value += MIN_DELAY;

   return value;
}

/**
 * Get Hold value in 100 ms ticks [1s..10s]
 */
unsigned getHoldControl() {
   constexpr unsigned MIN_HOLD =  10;
   constexpr unsigned MAX_HOLD = 100;

   unsigned value = HoldControl::readAnalogue();
   value *= (MAX_HOLD-MIN_HOLD);
   value /= UserAdc::getSingleEndedMaximum(ADC_RESOLUTION);
   value += MIN_HOLD;

   return value;
}

// Number of sample taken this period
static unsigned samplesThisPeriod = 100;

// Used to determine if load is operating
static int detectLevel = 10000;

/**
 * Timer callback that:
 *  - Checks if the load is operating
 *  - Queues events:
 *    -
 */
void timerCallback() {

   //=============================================
   // Used to count time intervals in 'ticks'
   //=============================================
   static unsigned timeCounter = 0;

   if (timeCounter++>TIMER_TICK_TIME) {
      eventQueue.enQueue(Event::e_TICK);
      timeCounter = 0;
   }

   //=============================================
   // Switch debounce
   //=============================================

   static unsigned debounceCount      = 0;
   static bool     lastSwitch         = false;

   constexpr unsigned DEBOUNCE_TIME = 100;

   if ((state == State::s_IDLE)||state == State::s_MANUAL) {
      // Sample switch
      Switch::setIn();
      bool currentSwitch = Switch::read();

      // If changes start again
      if (currentSwitch != lastSwitch) {
         lastSwitch = currentSwitch;
         debounceCount = 0;
      }

      // Signal debounced switch press
      if ((debounceCount++ == DEBOUNCE_TIME)&&currentSwitch) {
         eventQueue.enQueue(Event::e_SWITCH_PRESSED);
      }
   }

   //=============================================
   // Zero crossing detection with hysteresis
   //=============================================

   // Instantaneous current sample
   int sample    = I_Sample::readAnalogue();

   // Instantaneous reference sample
   int reference = Reference::readAnalogue();

   // Instantaneous current
   int current = sample-reference;

   // Hysteresis used for zero crossing
   static constexpr int HYSTERESIS        = 100;

   // Adjusted +/- HYSTERESIS
   static int zeroCrossingLevel = 0;

   bool zeroCrossingDetected = false;
   if (current>zeroCrossingLevel) {
      if (zeroCrossingLevel>0) {
//         Debug::toggle();
         zeroCrossingLevel = -HYSTERESIS;
         zeroCrossingDetected = true;
      }
   }
   else {
      zeroCrossingLevel = +HYSTERESIS;
   }

   //============================================
   // Peak-to-peak current updated every period
   //============================================

   static int maxCurrent  = 0;
   static int minCurrent  = 0;
   static bool lastLoadOn = false;

   samplesThisPeriod++;

   bool endOfPeriod = zeroCrossingDetected||(samplesThisPeriod>(EXPECTED_PERIOD_IN_TICKS+2));

   if (!endOfPeriod) {
      if (current > maxCurrent) {
         maxCurrent = current;
      }
      if (current < minCurrent) {
         minCurrent = current;
      }
   }
   else {
      // Power proportional to Ipp^2
      int power = (maxCurrent - minCurrent);
      power *= power;

      maxCurrent  = 0;
      minCurrent  = 0;
      samplesThisPeriod = 0;

      // Update control samples
      delayTimeInTicks = getDelayControl();
      holdTimeInTicks  = getHoldControl();
      detectLevel      = getDetectLevel();

      bool currentLoadOn = power > (detectLevel*detectLevel);
      Debug::write(currentLoadOn);
      if (currentLoadOn != lastLoadOn) {
         // Load changed
         eventQueue.enQueue(currentLoadOn?Event::e_LOAD_ON:Event::e_LOAD_OFF);
         lastLoadOn = currentLoadOn;
      }
   }
   return;
}

//using PollingTimerChannel = Pit::Channel<0>;

/**
 * Initialise I/O
 */
void initialise() {

   Pins::setInOut();
   DelayLed::setOut();
   HoldLed::setOut();
   DustCollector::setOut();
   Switch::setInput();
   DustCollector::setHdrive(HighDrive_on);
   Switch::setPup(PullDirection_up);

   static constexpr UserAdc::Init adcInit {
      AdcResolution_12bit_se ,         // ADC resolution - 12-bit
      AdcClockSource_BusClock ,        // Input Clock Select - Bus clock
      AdcClockDivider_DivBy8 ,         // Clock Divide Select - Divide by 8
      AdcReferenceSel_VrefhAndVrefl ,  // Voltage Reference Selection - VREFH and VREFL
      AdcSampleMode_LongSampleTime ,   // Sample Time Configuration - Long sample
      AdcPower_Normal ,                // Low-Power Configuration - Normal

      // Configured ADC channels (GPIO disabled)
      I_Sample::CHANNEL,
      Reference::CHANNEL,
      HoldControl::CHANNEL,
      LevelControl::CHANNEL,
      };

   UserAdc::configure(adcInit);

   static constexpr UserTimer::Init timerInit {
      PitOperation_Enabled,
      PitDebugMode_StopInDebug,
   };
   UserTimer::configure(timerInit);

   static constexpr UserTimer::ChannelInit timerChannelInit {
      PollingTimerChannel::CHANNEL,

      PitChannelEnable_Enabled ,                     // Timer Channel Enabled
      PitChannelAction_Interrupt ,                   // Timer Interrupt Enabled
      NvicPriority_Normal ,                          // IRQ level
      Ticks((TICK_TIME*(SystemBusClock/1000000))-1), // Time interval for channel (microseconds*(fBus)/1,000,000) - 1
      timerCallback,                                 // Call-back
      };
   UserTimer::configure(timerChannelInit);

   Debug::setOutput();
}

int main() {

#if defined(DEBUG_BUILD)
   console.writeln("\nStarting");
#endif

   initialise();

   // Update time parameters on startup
   delayTimeInTicks = getDelayControl();
   holdTimeInTicks  = getHoldControl();
   detectLevel      = getDetectLevel();

#if defined(DEBUG_BUILD)
   console.writeln("Delay time   = ", delayTimeInTicks*100, " ms");
   console.writeln("Hold  time   = ", holdTimeInTicks*100,  " ms");
   console.writeln("Detect level = ", detectLevel );
#endif

   for(;;) {
      // Time in TIMER_TICK_TIME 100 ms
      static unsigned timeCounter = 0;

      Event event = eventQueue.deQueue();

      if (event == Event::e_NONE) {
         // No event
         continue;
      }
#if defined(DEBUG_BUILD)
      if (event != Event::e_TICK) {
         console.writeln("Event: ", getEventName(event));
      }

      static State lastState = s_OPERATING;
      if (state != lastState) {
         // Report state change
         console.writeln("State changed to ", getStateName(state));
         lastState = state;
      }
#endif
      if (event == Event::e_TICK) {
         timeCounter++;
      }
      switch(state) {
         default:
         case s_IDLE:
            // Make sure dust collector is off
            DustCollector::off();
            Switch::setIn();

            // Check for load
            if (event == Event::e_LOAD_ON) {
               state = s_DELAY;
               timeCounter = 0;
            }
            if (event == Event::e_SWITCH_PRESSED) {
               state = s_MANUAL;
            }
            break;
         case s_DELAY:
            // Indicate in delay
            DelayLed::setOut();
            DelayLed::on();

            // Make sure Collector off
            DustCollector::off();

            if (event == Event::e_LOAD_OFF) {
               // Load went away while delaying
               state = s_IDLE;
               DelayLed::off();
            }
            else if (timeCounter>delayTimeInTicks) {
               // Completed delay time
               state = s_OPERATING;
               DelayLed::off();
            }
            break;
         case s_OPERATING:
            // Dust collector on
            DustCollector::on();

            if (event == Event::e_LOAD_OFF) {
               // Load gone
               state = s_HOLD;
               timeCounter = 0;
            }
            break;
         case s_MANUAL:
            // Dust collector on
            DustCollector::on();

            if (event == Event::e_SWITCH_PRESSED) {
               state = s_IDLE;
            }
            break;
         case s_HOLD:
            // Indicate in hold
            HoldLed::on();

            // Dust collector on
            DustCollector::on();

            if (event == Event::e_LOAD_ON) {
               // Load returned before delay expired
               state = s_OPERATING;
               HoldLed::off();
            }
            else if (timeCounter>holdTimeInTicks) {
               // Completed hold time
               state = s_IDLE;
               HoldLed::off();
            }
            break;
      }

   }
   return 0;
}
