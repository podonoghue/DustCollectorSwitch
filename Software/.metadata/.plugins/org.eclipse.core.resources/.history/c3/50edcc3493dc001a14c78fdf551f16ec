/*
 ============================================================================
 * @file    main.cpp (180.ARM_Peripherals/Sources/main.cpp)
 * @brief   Basic C++ demo
 *
 *  Created on: 10/1/2016
 *      Author: podonoghue
 ============================================================================
 */
#include "hardware.h"

// Allow access to USBDM methods without USBDM:: prefix
using namespace USBDM;

/*************************************************
 * Global objects representing hardware
 **************************************************/

using PortAall = GpioAField<13,  0>; // 13,12,5,4,2,1, (19,18=xtal; 3,0 = debug)
using PortAw   = GpioAField<13, 12>;
using PortAx   = GpioAField< 5,  4>;
using PortAy   = GpioAField< 2,  1>;
//                                     32109876543210 // 13,12,5,4,2,1, (19,18=xtal; 3,0 = debug)
constexpr uint32_t portA_pattern   = 0b01000000010010;
constexpr uint32_t portA_direction = 0b11000000110110;
constexpr uint32_t portA_testMask  = 0b11000000110110;
constexpr uint32_t portA_adc_SE0   = 0b11000000000100;

using PortBall = GpioBField< 3,  0>; // 3-0 (19,18=Touch; 17,16=serial)
//                                     3210 // 3-0 (19,18=Touch; 17,16=serial)
constexpr uint32_t portB_pattern   = 0b0101;
constexpr uint32_t portB_direction = 0b1111;
constexpr uint32_t portB_testMask  = 0b1111;
constexpr uint32_t portB_adc_SE0   = 0b1100;

using PortCall = GpioCField<11,  0>; // 11-0 (11,6=Accel_INT can't be tested)
//                                     109876543210 // 11-0 (11,6=Accel_INT can't be tested)
constexpr uint32_t portC_pattern   = 0b001010010101;
constexpr uint32_t portC_direction = 0b011110111111;
constexpr uint32_t portC_testMask  = 0b011110111111;
constexpr uint32_t portC_adc_SE0   = 0b010000000100;

using PortDall = GpioDField< 7,  0>; // 7-0
//                                     76543210 7-0
constexpr uint32_t portD_pattern   = 0b01010101;
constexpr uint32_t portD_direction = 0b11111111;
constexpr uint32_t portD_testMask  = 0b11111111;
constexpr uint32_t portD_adc_SE0   = 0b00001110;

using PortEall = GpioEField< 1,  0>; // 1-0
//                                     10 // 1-0
constexpr uint32_t portE_pattern   = 0b01;
constexpr uint32_t portE_direction = 0b11;
constexpr uint32_t portE_testMask  = 0b11;
constexpr uint32_t portE_adc_SE0   = 0b00;

constexpr uint32_t testPattern  = 0b01010101010101010101010101010101U;

// Threshold to check SE0 low/high input against
constexpr unsigned LOW_DRIVE_SE0  = 10000;
constexpr unsigned HIGH_DRIVE_SE0 = 60000;

// Threshold to check SE3 low/high input against
constexpr unsigned LOW_DRIVE_SE3  = 20000;
constexpr unsigned HIGH_DRIVE_SE3 = 45000;

// Analogue input
using AdcTestChannel_SE0 = Adc0::Channel<0>;
using AdcTestChannel_SE3 = Adc0::Channel<3>;

using PassLed = GpioC<10, ActiveHigh>; // Green
using FailLed = GpioA<13, ActiveHigh>; // Red

// Resolution used for ADC conversions
constexpr AdcResolution adcResolution = AdcResolution_16bit_se;

// Reference range of ADC
constexpr float         ADC_REF = 3.3; /* volts */

/**
 * Convert ADC Value to volts
 *
 * @param adcValue
 *
 * @return
 */
float convertToVolts(unsigned adcValue) {
   return (adcValue*ADC_REF)/Adc0::getSingleEndedMaximum(adcResolution);
}

void reportTest(const char *name, unsigned index, unsigned lowCheck, unsigned highCheck, bool useSE0, bool pass) {
   console.setFloatFormat(1, Padding_LeadingSpaces, 3);
   console.setPadding(Padding_LeadingSpaces).setWidth(3);
   console.write(" ")
         .write(name).write(index)
         .write(" {").write(convertToVolts(lowCheck)).write(" V, ")
         .write(convertToVolts(highCheck)).write(" V} ")
         .write(pass?"OK  ":"FAIL");
   console.setPadding(Padding_LeadingSpaces).setWidth(5);
   console.write(" {").write((lowCheck)).write(", ").write((highCheck)).write("}");
   console.writeln(useSE0?"SE0":"SE3");
   console.resetFormat();
}

/**
 * Checks result of low-drive test on port
 *
 * @param use_se0    True => Use SE0 to check, False => Use SE3
 * @param lowTest    Result from low test
 * @param pass       Whether test failed
 */
void doLowDriveTest(bool use_se0, unsigned &lowTest, bool &pass) {
   if (use_se0) {
      lowTest = AdcTestChannel_SE0::readAnalogue();
      pass = pass & (lowTest < LOW_DRIVE_SE0);
   }
   else {
      lowTest = AdcTestChannel_SE3::readAnalogue();
      pass = pass & (lowTest < LOW_DRIVE_SE3);
   }
}

/**
 * Checks result of high-drive test on port
 *
 * @param use_se0    True => Use SE0 to check, False => Use SE3
 * @param lowTest    Result from high test
 * @param pass       Whether test failed
 */
void doHighDriveTest(bool use_se0, unsigned &highTest, bool &pass) {
   if (use_se0) {
      highTest = AdcTestChannel_SE0::readAnalogue();
      pass = pass & (highTest > HIGH_DRIVE_SE0);
   }
   else {
      highTest = AdcTestChannel_SE3::readAnalogue();
      pass = pass & (highTest > HIGH_DRIVE_SE3);
   }
}

void reportFailedPins(const char *name, unsigned resultMask) {
   for (unsigned index=0; index<=31; index++) {
      unsigned mask = 1<<index;
      if ((resultMask & mask) == 0) {
         continue;
      }
      console.write("Failed ").write(name).writeln(index);
   }
}

/**
 * Does simple Port I/O test on Port A pins
 */
bool testPortA() {
   uint32_t testValue;

   PortAw::setInOut(
         PinPull_None,
         PinDriveStrength_High,
         PinDriveMode_PushPull,
         PinAction_None,
         PinFilter_None,
         PinSlewRate_Slow);
   PortAx::setInOut(
         PinPull_None,
         PinDriveStrength_High,
         PinDriveMode_PushPull,
         PinAction_None,
         PinFilter_None,
         PinSlewRate_Slow);
   PortAy::setInOut(
         PinPull_None,
         PinDriveStrength_High,
         PinDriveMode_PushPull,
         PinAction_None,
         PinFilter_None,
         PinSlewRate_Slow);
   PortAall::setDirection(portA_direction);

   PortAall::write(testPattern);
   testValue = PortAall::read();
   uint32_t failed1 = (testValue^testPattern)&portA_testMask;
   console.write("Port A - Test 1 = ").write(failed1, Radix_2);

   PortAall::write(~testPattern);
   testValue = PortAall::read();
   uint32_t failed2 = (testValue^~testPattern)&portA_testMask;
   console.write(", Test 2 = ").writeln(failed2, Radix_2);
   reportFailedPins("A", failed1);
   reportFailedPins("A", failed2);

   PortAall::setDirection(0);
   return (failed1 == 0) && (failed2 == 0);
}

/**
 * Does simple Port I/O test on Port B pins
 */
bool testPortB() {
   uint32_t testValue;

   PortBall::setInOut(
         PinPull_None,
         PinDriveStrength_High,
         PinDriveMode_PushPull,
         PinAction_None,
         PinFilter_None,
         PinSlewRate_Slow);
   PortBall::setDirection(portB_direction);

   PortBall::write(testPattern);
   testValue = PortBall::read();
   uint32_t failed1 = (testValue^testPattern)&portB_testMask;
   console.write("Port B - Test 1 = ").write(failed1, Radix_2);

   PortBall::write(~testPattern);
   testValue = PortBall::read();
   uint32_t failed2 = (testValue^~testPattern)&portB_testMask;
   console.write(", Test 2 = ").writeln(failed2, Radix_2);
   reportFailedPins("B", failed1);
   reportFailedPins("B", failed2);

   PortBall::setDirection(0);

   return (failed1 == 0) && (failed2 == 0);
}

/**
 * Does simple Port I/O test on Port C pins
 */
bool testPortC() {
   uint32_t testValue;

   PortCall::setInOut(
         PinPull_None,
         PinDriveStrength_High,
         PinDriveMode_PushPull,
         PinAction_None,
         PinFilter_None,
         PinSlewRate_Slow);
   PortCall::setDirection(portC_direction);

   PortCall::write(testPattern);
   testValue = PortCall::read();
   uint32_t failed1 = (testValue^testPattern)&portC_testMask;
   console.write("Port C - Test 1 = ").write(failed1, Radix_2);

   PortCall::write(~testPattern);
   testValue = PortCall::read();
   uint32_t failed2 = (testValue^~testPattern)&portC_testMask;
   console.write(", Test 2 = ").writeln(failed2, Radix_2);
   reportFailedPins("C", failed1);
   reportFailedPins("C", failed2);

   PortCall::setDirection(0);

   return (failed1 == 0) && (failed2 == 0);
}

/**
 * Does simple Port I/O test on Port D pins
 */
bool testPortD() {
   uint32_t testValue;

   PortDall::setInOut(
         PinPull_None,
         PinDriveStrength_High,
         PinDriveMode_PushPull,
         PinAction_None,
         PinFilter_None,
         PinSlewRate_Slow);
   PortDall::setDirection(portD_direction);

   PortDall::write(testPattern);
   testValue = PortDall::read();
   uint32_t failed1 = (testValue^testPattern)&portD_testMask;
   console.write("Port D - Test 1 = ").write(failed1, Radix_2);

   PortDall::write(~testPattern);
   testValue = PortDall::read();
   uint32_t failed2 = (testValue^~testPattern)&portD_testMask;
   console.write(", Test 2 = ").writeln(failed2, Radix_2);
   reportFailedPins("D", failed1);
   reportFailedPins("D", failed2);

   PortDall::setDirection(0);

   return (failed1 == 0) && (failed2 == 0);
}

/**
 * Does simple Port I/O test on Port E pins
 */
bool testPortE() {
   uint32_t testValue;

   PortEall::setInOut(
         PinPull_None,
         PinDriveStrength_High,
         PinDriveMode_PushPull,
         PinAction_None,
         PinFilter_None,
         PinSlewRate_Slow);
   PortEall::setDirection(portE_direction);

   PortEall::write(testPattern);
   testValue = PortEall::read();
   uint32_t failed1 = (testValue^testPattern)&portE_testMask;
   console.write("Port E - Test 1 = ").write(failed1, Radix_2);

   PortEall::write(~testPattern);
   testValue = PortEall::read();
   uint32_t failed2 = (testValue^~testPattern)&portE_testMask;
   console.write(", Test 2 = ").writeln(failed2, Radix_2);
   reportFailedPins("E", failed1);
   reportFailedPins("E", failed2);

   PortEall::setDirection(0);

   return (failed1 == 0) && (failed2 == 0);
}

/**
 * Does a drive test on Port A
 * Drive a single pin of port high/low and uses a connected ADC channel to
 * confirm output level.
 */
bool testPortA_drive() {
   PortAall::setDirection(0);
   PortBall::setDirection(0);
   PortCall::setDirection(0);
   PortDall::setDirection(0);
   PortEall::setDirection(0);

   AdcTestChannel_SE0::Adc::configure(adcResolution);
   AdcTestChannel_SE0::setInput();
   AdcTestChannel_SE3::setInput();
//   unsigned midValue_A = AdcTestChannel_SE0::readAnalogue();
//   unsigned midValue_B = AdcTestChannel_SE3::readAnalogue();

   bool success = true;
   for (unsigned index=PortAall::RIGHT; index<=PortAall::LEFT; index++) {
      unsigned mask = 1<<index;
      if ((portA_testMask & mask) == 0) {
         continue;
      }
      bool use_SE0 = (portA_adc_SE0 & mask) != 0;
      bool pass = true;
      unsigned lowCheck, highCheck;

      PortAall::setDirection(mask);

      PortAall::write(0);
      doLowDriveTest(use_SE0, lowCheck, pass);

      PortAall::write(-1);
      doHighDriveTest(use_SE0, highCheck, pass);

      reportTest("A", index, lowCheck, highCheck, use_SE0, pass);
      success = success && pass;
   }
   return success;
}

/**
 * Does a drive test on Port B
 * Drive a single pin of port high/low and uses a connected ADC channel to
 * confirm output level.
 */
bool testPortB_drive() {
   PortAall::setDirection(0);
   PortBall::setDirection(0);
   PortCall::setDirection(0);
   PortDall::setDirection(0);
   PortEall::setDirection(0);

   AdcTestChannel_SE0::Adc::configure(adcResolution);
   AdcTestChannel_SE0::setInput();
   AdcTestChannel_SE3::setInput();
//   unsigned midValue_A = AdcTestChannel_SE0::readAnalogue();
//   unsigned midValue_B = AdcTestChannel_SE3::readAnalogue();

   bool success = true;
   for (unsigned index=PortBall::RIGHT; index<=PortBall::LEFT; index++) {
      unsigned mask = 1<<index;
      if ((portB_testMask & mask) == 0) {
         continue;
      }
      bool use_SE0 = (portB_adc_SE0 & mask) != 0;
      bool pass = true;
      unsigned lowCheck, highCheck;

      PortBall::setDirection(mask);

      PortBall::write(0);
      doLowDriveTest(use_SE0, lowCheck, pass);

      PortBall::write(-1);
      doHighDriveTest(use_SE0, highCheck, pass);

      reportTest("B", index, lowCheck, highCheck, use_SE0, pass);
      success = success && pass;
   }
   return success;
}

/**
 * Does a drive test on Port C
 * Drive a single pin of port high/low and uses a connected ADC channel to
 * confirm output level.
 */
bool testPortC_drive() {
   PortAall::setDirection(0);
   PortBall::setDirection(0);
   PortCall::setDirection(0);
   PortDall::setDirection(0);
   PortEall::setDirection(0);

   AdcTestChannel_SE0::Adc::configure(adcResolution);
   AdcTestChannel_SE0::setInput();
   AdcTestChannel_SE3::setInput();
//   unsigned midValue_A = AdcTestChannel_SE0::readAnalogue();
//   unsigned midValue_B = AdcTestChannel_SE3::readAnalogue();

   bool success = true;
   for (unsigned index=PortCall::RIGHT; index<=PortCall::LEFT; index++) {
      unsigned mask = 1<<index;
      if ((portC_testMask & mask) == 0) {
         continue;
      }
      bool use_SE0 = (portC_adc_SE0 & mask) != 0;
      bool pass = true;
      unsigned lowCheck, highCheck;

      PortCall::setDirection(mask);

      PortCall::write(0);
      doLowDriveTest(use_SE0, lowCheck, pass);

      PortCall::write(-1);
      doHighDriveTest(use_SE0, highCheck, pass);

      reportTest("C", index, lowCheck, highCheck, use_SE0, pass);
      success = success && pass;
   }
   return success;
}

/**
 * Does a drive test on Port D
 * Drive a single pin of port high/low and uses a connected ADC channel to
 * confirm output level.
 */
bool testPortD_drive() {
   PortAall::setDirection(0);
   PortBall::setDirection(0);
   PortCall::setDirection(0);
   PortDall::setDirection(0);
   PortEall::setDirection(0);

   AdcTestChannel_SE0::Adc::configure(adcResolution);
   AdcTestChannel_SE0::setInput();
   AdcTestChannel_SE3::setInput();
//   unsigned midValue_A = AdcTestChannel_SE0::readAnalogue();
//   unsigned midValue_B = AdcTestChannel_SE3::readAnalogue();

   bool success = true;
   for (unsigned index=PortDall::RIGHT; index<=PortDall::LEFT; index++) {
      unsigned mask = 1<<index;
      if ((portD_testMask & mask) == 0) {
         continue;
      }
      bool use_SE0 = (portD_adc_SE0 & mask) != 0;
      bool pass = true;
      unsigned lowCheck, highCheck;

      PortDall::setDirection(mask);

      PortDall::write(0);
      doLowDriveTest(use_SE0, lowCheck, pass);

      PortDall::write(-1);
      doHighDriveTest(use_SE0, highCheck, pass);

      reportTest("D", index, lowCheck, highCheck, use_SE0, pass);
      success = success && pass;
   }
   return success;
}

/**
 * Does a drive test on Port E
 * Drive a single pin of port high/low and uses a connected ADC channel to
 * confirm output level.
 */
bool testPortE_drive() {
   PortAall::setDirection(0);
   PortBall::setDirection(0);
   PortCall::setDirection(0);
   PortDall::setDirection(0);
   PortEall::setDirection(0);

   AdcTestChannel_SE0::Adc::configure(adcResolution);
   AdcTestChannel_SE0::setInput();
   AdcTestChannel_SE3::setInput();
//   unsigned midValue_A = AdcTestChannel_SE0::readAnalogue();
//   unsigned midValue_B = AdcTestChannel_SE3::readAnalogue();

   bool success = true;
   for (unsigned index=PortEall::RIGHT; index<=PortEall::LEFT; index++) {
      unsigned mask = 1<<index;
      if ((portE_testMask & mask) == 0) {
         continue;
      }
      bool use_SE0 = (portE_adc_SE0 & mask) != 0;
      bool pass = true;
      unsigned lowCheck, highCheck;

      PortEall::setDirection(mask);

      PortEall::write(0);
      doLowDriveTest(use_SE0, lowCheck, pass);

      PortEall::write(-1);
      doHighDriveTest(use_SE0, highCheck, pass);

      reportTest("E", index, lowCheck, highCheck, use_SE0, pass);
      success = success && pass;
   }
   return success;
}


int main() {
   console.writeln("Starting\n");
   console.write("SystemCoreClock = ").writeln(SystemCoreClock);
   console.write("SystemBusClock  = ").writeln(SystemBusClock);

   // Conduct all tests and get overall pass/fail
   bool ok = true;
   ok = ok & testPortA();
   ok = ok & testPortB();
   ok = ok & testPortC();
   ok = ok & testPortD();
   ok = ok & testPortE();
   ok = ok & testPortA_drive();
   ok = ok & testPortB_drive();
   ok = ok & testPortC_drive();
   ok = ok & testPortD_drive();
   ok = ok & testPortE_drive();

   if (ok) {
      console.write("Passed all tests");
   }
   else {
      console.write("Failed some tests");
   }

   // Report result on LEDs
   PassLed::setOutput(PinDriveStrength_High, PinDriveMode_PushPull, PinSlewRate_Slow);
   FailLed::setOutput(PinDriveStrength_High, PinDriveMode_PushPull, PinSlewRate_Slow);
//   BlueLed::setOutput(PinDriveStrength_High, PinDriveMode_PushPull, PinSlewRate_Slow);
   for(;;) {
      if (ok) {
         PassLed::toggle();
      }
      else {
         FailLed::toggle();
      }
      waitMS(200);
   }
   return 0;
}

/*
Results from good board

Starting

SystemCoreClock = 48000000
SystemBusClock  = 48000000
Port A - Test 1 = 0, Test 2 = 0
Port B - Test 1 = 0, Test 2 = 0
Port C - Test 1 = 0, Test 2 = 0
Port D - Test 1 = 0, Test 2 = 0
Port E - Test 1 = 0, Test 2 = 0
 A  1 {  0.9 V,   2.6 V} OK   {18228, 51758}
 A  2 {  0.0 V,   3.1 V} OK   {  872, 61008}
 A  4 {  0.9 V,   2.6 V} OK   {18077, 51952}
 A  5 {  0.8 V,   2.5 V} OK   {16385, 49656}
 A 12 {  0.3 V,   3.1 V} OK   { 5695, 60993}
 A 13 {  0.3 V,   3.2 V} OK   { 5707, 63000}
 B  0 {  0.8 V,   2.6 V} OK   {16134, 50672}
 B  1 {  0.7 V,   2.5 V} OK   {14615, 49078}
 B  2 {  0.3 V,   3.1 V} OK   { 5722, 61056}
 B  3 {  0.3 V,   3.1 V} OK   { 5708, 60968}
 C  0 {  0.9 V,   2.6 V} OK   {18066, 51332}
 C  1 {  0.8 V,   2.5 V} OK   {16363, 49684}
 C  2 {  0.3 V,   3.1 V} OK   { 5695, 60976}
 C  3 {  0.7 V,   2.6 V} OK   {14341, 51653}
 C  4 {  0.8 V,   2.5 V} OK   {16395, 49622}
 C  5 {  0.8 V,   2.5 V} OK   {16382, 49680}
 C  7 {  0.8 V,   2.5 V} OK   {16408, 49644}
 C  8 {  0.8 V,   2.5 V} OK   {16386, 49640}
 C  9 {  0.8 V,   2.5 V} OK   {16435, 49618}
 C 10 {  0.3 V,   3.2 V} OK   { 5736, 63000}
 D  0 {  0.9 V,   2.6 V} OK   {18143, 51371}
 D  1 {  0.3 V,   3.1 V} OK   { 5744, 60936}
 D  2 {  0.3 V,   3.1 V} OK   { 5751, 60928}
 D  3 {  0.3 V,   3.1 V} OK   { 5732, 60936}
 D  4 {  0.9 V,   2.6 V} OK   {17971, 51618}
 D  5 {  0.8 V,   2.5 V} OK   {16380, 49696}
 D  6 {  0.8 V,   2.5 V} OK   {16395, 49624}
 D  7 {  0.8 V,   2.5 V} OK   {16369, 49682}
 E  0 {  0.8 V,   2.5 V} OK   {16394, 50098}
 E  1 {  0.8 V,   2.5 V} OK   {16385, 49608}
Passed all tests
 */
